<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YuanXu&#39;s Blog</title>
  
  <subtitle>天之道, 利而不害; 人之道, 为而不争.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yx1302317313.github.io/"/>
  <updated>2020-03-05T14:06:20.267Z</updated>
  <id>https://yx1302317313.github.io/</id>
  
  <author>
    <name>Yuan Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>书单</title>
    <link href="https://yx1302317313.github.io/2020/03/05/Reading-List/"/>
    <id>https://yx1302317313.github.io/2020/03/05/Reading-List/</id>
    <published>2020-03-05T06:23:57.000Z</published>
    <updated>2020-03-05T14:06:20.267Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在读">在读</h3><ul><li>经济学原理-微观经济学</li><li>北欧神话</li><li>浩荡两千年</li><li>人月神话</li></ul><h3 id="经济类">经济类</h3><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 经济学原理-微观经济学</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 经济学原理-宏观经济学</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 浩荡两千年</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 跌荡一百年</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 激荡三十年</li></ul><h3 id="计算机类">计算机类</h3><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 人月神话</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 摩托车维修艺术</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 设计模式之禅</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 浪潮之巅</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> AI未来</li></ul><h3 id="历史类">历史类</h3><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 明朝那些事儿</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 易中天中华史</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 血腥的盛唐</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 被封印的唐史</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 两宋风云</li></ul><h3 id="科幻类">科幻类</h3><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 三体</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 球状闪电</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 乡村教师</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 白垩纪往事</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 流浪地球</li></ul><h3 id="文学类">文学类</h3><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 百年孤独</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 白夜行</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 流星之绊</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 解忧杂货店</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 迷宫中的将军</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox"> 北欧神话</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 小李飞刀-多情剑客无情剑</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 追风筝的人</li></ul><h3 id="传记">传记</h3><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 特斯拉传</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 世界因我而不同</li></ul><h3 id="其他">其他</h3><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 白说</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled type="checkbox">  …</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在读&quot;&gt;在读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;经济学原理-微观经济学&lt;/li&gt;
&lt;li&gt;北欧神话&lt;/li&gt;
&lt;li&gt;浩荡两千年&lt;/li&gt;
&lt;li&gt;人月神话&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;经济类&quot;&gt;经济类&lt;/h3&gt;
&lt;ul class=&quot;contains-tas
      
    
    </summary>
    
      <category term="阅读" scheme="https://yx1302317313.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>MapReduce-翻译</title>
    <link href="https://yx1302317313.github.io/2020/03/01/Google-MapReduce/"/>
    <id>https://yx1302317313.github.io/2020/03/01/Google-MapReduce/</id>
    <published>2020-03-01T13:18:35.000Z</published>
    <updated>2020-03-10T12:46:46.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>MapReduce是一个编程模型，是一个与处理和生成大数据集相关的实现。用户指定一个处理<code>键值对</code>的  <em>Map</em> 函数生成一个中间<code>键值对</code>的集合，指定一个 <em>Reduce</em> 函数来合并有相同中间<code>键</code>的所有中间<code>值</code>。许多现实中的任务都可以用这种模型表达，像这篇论文中所展示的一样。</p><p>用这种函数风格写成的程序可以自动在大型商用机器集群上并行化执行。这个运行时系统负责分割输入数据的细节，调度程序在机器集群上执行，处理机器的错误和管理请求的内部机器通信。这样允许没有任何并行化和分布式系统经验的程序员可以轻松地利用大型分布式系统的资源。</p><p>我们实现的MapReduce运行在大型商业机器集群上并且是高度可拓展的：一个典型的MapReduce计算在数以千计的机器上处理许多兆兆字节（2^40字节）的数据。程序员发现这个系统使用起来是简单的：数以百计的MapReduce程序已经被实现，每天高达一千多个MapReduce工作正在Google的集群上执行。</p><h2 id="1-简介">1 简介</h2><p>在过去的五年里，作者和许多在Google工作的其他人实现了数百种有专用目的的计算，用来处理大量原始数据，例如爬取的文档，网络请求日志等等，计算多种多样的派生数据，例如反转的索引，网页文档图结构的各种表示方式，爬取主机的页数摘要，在给定一天的最频繁查询集合等等。大多数此类计算在概念上是简单明了的。但是输入数据通常是巨大的，为了在合理的时间内完成计算必须分布在成百上千个机器上。怎样并行化计算，分布数据和处理错误这些问题共同困扰了原先使用大量复杂代码处理这些问题的简单计算。</p><p>为了应对这种复杂性，我们设计了一个新的抽象概念允许我们表达试图执行的简单计算，但是我们在库中隐藏了并行化，容错，数据分布和负载平衡的复杂细节。我们的抽象概念的灵感来源于当前在 <em>Lisp</em> 和许多其他函数式语言中的 <em>Map</em> 和 <em>Reduce</em> 原函数。我们意识到大多数我们的计算涉及到对输入数据的每一个逻辑“记录”应用一个 <em>Map</em> 操作来计算一组中间<code>键值对</code>，然后对共享同一个键的所有值应用一个 <em>Reduce</em> 操作适当地合并派生的数据。我们使用具有用户指定的 <em>Map</em> 和 <em>Reduce</em> 操作的函数模型，使我们方便地并行化进行大型计算，我们使用重新计算作为容错的主要机制。</p><p>这项工作的主要贡献是一个简单而又强大的接口，该接口能够自动实现大规模计算的并行化和分布，并且该接口的是实现在大型商业计算机集群上达到高性能。</p><p>第2节描述了基本的编程模型并且给出了若干实例。第3节 描述了为我们基于集群计算环境定制的MapReduce接口的实现。第4节描述了我们发现有用的对编程模型的一些改进。第5节对大量任务的实现进行了性能度量。第6节探索了MapReduce在Google的应用，包括我们将其作为重写产品索引系统的基础的经历。第7节讨论了与其相关的和未来的工作。</p><h2 id="2-编程模型">2 编程模型</h2><p>计算会获取一个输入<code>键值对</code>集合，然后产生一个输出<code>键值对</code>集合。MapReduce库的用户通过两个函数：<em>Map</em> 和 <em>Reduce</em> 来表达计算。</p><p>由用户编写的 <em>Map</em> 函数获取一个输入对，产生一个中间键值对集合。MapReduce库将具有相同中间键 <em>I</em> 的中间值分成一组，然后把它们传递给 <em>Reduce</em> 函数。</p><p><em>Reduce</em> 函数同样由用户编写，接受一个中间键 <em>I</em> 和一个与该键对应的中间值集合。它将这些值合并起来形成一个可能更小的值的集合。通常每一次 <em>Reduce</em> 调用仅仅产生零或一个输出值。中间值通过一个迭代器被提供给用户的reduce函数。这样允许我们处理太大而不能放入内存的值列表。</p><h3 id="2-1-实例">2.1 实例</h3><p>考虑统计大量文档中每个单词出现次数的问题。用户需要编写类似于下面伪码的代码：</p><pre><code class="language-python">map(String key, String value):// key: document name// value: document contentsfor each word w in value:EmitIntermediate(w, &quot;1&quot;); reduce(String key, Iterator values):// key: a word// values: a list of countsint result = 0;for each v in values:result += ParseInt(v);Emit(AsString(result));</code></pre><p><em>map</em> 函数发出（emit）每个单词加上一个相关的出现次数（在这个简单的例子中仅仅是“1”）。<em>reduce</em> 函数将每一个特定单词的所有发出的（emited）次数加在一起。</p><p>另外，用户需要编写代码用输入，输出文件的文件名和额外的调整参数填充 <em>mapreduce</em> 规范对象。用户然后调用 <em>MapRedece</em> 函数，将这个规范的对象传递给它。用户代码会被MapReduce库（用C++实现的）链接到一起。附录A包含了这个例子的所有程序文本。</p><h3 id="2-2-类型">2.2 类型</h3><p>尽管之前的伪码是根据字符串输入输出编写的，但是概念上用户提供的map和reduce函数具有相关的类型：</p><pre><code>map (k1, v1) -&gt; list(k2, v2)reduce (k2, list(v2)) -&gt; list(v2)</code></pre><p>也就是说，输入键和值从不同于输出键和值的域中提取。另外，中间键和值与输出键和值来自同一个域。</p><p>我们的C++实现向用户定义的函数传递字符串，而从字符串转换为合适的类型留给用户定义的代码实现。</p><h3 id="2-3-更多实例">2.3 更多实例</h3><p>这里有一些有趣而又简单的例子，这些例子能够轻易的表达成MapReduce计算。</p><p><strong>Distributed Grep:</strong> 如果与提供的模式匹配，map函数会发出（emit）一行文本。reduce函数是一个identity函数，它仅仅将提供的中间数据复制到输出。</p><p><em>译者注：grep是Linux的一个命令，该命令会根据给定的模式查找文本中匹配的部分，如果匹配会输出所在行。</em></p><p><strong>Count of URL Access Frequency:</strong> map函数处理网页请求日志，输出 <em>&lt;URL, 1&gt;</em> 。reduce函数将来自相同URL的值加在一起并且发出（emit）一个 <em>&lt;URL, total count&gt;</em> 键值对。</p><p><strong>Reverse Web-Link Graph:</strong> map函数为在名为 <em>source</em> 的网页中找到的所以指向 <em>target</em> URL的每一个链接输出 <em>&lt;target, source&gt;</em> 键值对。reduce函数将与给定的目标URL有关的所有源URL列表连接起来，发出（emit）键值对： <em>&lt;target, list(source)&gt;</em></p><p><strong>Term-Vector per Host:</strong> 术语向量（term vector）将出现在一个文档或者一组文档中最重要的单词概括为 <em>&lt;words, frequence&gt;</em> 键值对。map函数为每一个输入文档发出（emit）一个 <em>&lt;hostname, term vector&gt;</em> 键值对（主机名从文档的URL中提取）。将给定主机所有文档的术语向量传递给reduce函数。它把这些术语向量加在一起，去掉不常出现的属于，然后发出（emit）一个最终的 <em>&lt;hostnamem, term vetor&gt;</em> 键值对。</p><p><strong>Inverted Index:</strong> map函数解析每一个文档，然后发出（emit）<em>&lt;word, document ID&gt;</em> 键值对序列。reduce函数接收给定单词的所有键值对，根据文档ID排序，之后发出（emit）一个 <em>&lt;word, list(document ID)&gt;</em> 键值对。所有输出键值对构成的集合形成了一个简单的反向索引。这样很容易拓展计算来跟踪每个单词的位置。</p><p><strong>Distributed Sort:</strong> map函数从每个记录中提取键，然后发出（emit）一个 <em>&lt;key, record&gt;</em> 键值对。reduce函数发出（emit）没有变化的全部键值对。这个计算依赖于在4.1节描述的隔离设施和在4.2节描述的可排序属性。</p><h2 id="3-实现">3 实现</h2><h3 id="A-单词频率">A 单词频率</h3><p>这一节包含了一个程序，该程序统计了通过命令行指定的文件集合中的每一个单词的出现次数。</p><pre><code class="language-cpp">#include &quot;mapreduce/mapreduce.h&quot;// User’s map functionclass WordCounter : public Mapper {public:virtual void Map(const MapInput&amp; input) {const string&amp; text = input.value();const int n = text.size();for (int i = 0; i &lt; n; ) {// Skip past leading whitespacewhile ((i &lt; n) &amp;&amp; isspace(text[i]))i++;// Find word endint start = i;while ((i &lt; n) &amp;&amp; !isspace(text[i]))i++;if (start &lt; i)Emit(text.substr(start,i-start),&quot;1&quot;);}}};REGISTER_MAPPER(WordCounter);// User’s reduce functionclass Adder : public Reducer {virtual void Reduce(ReduceInput* input) {// Iterate over all entries with the// same key and add the valuesint64 value = 0;while (!input-&gt;done()) {value += StringToInt(input-&gt;value());input-&gt;NextValue();}// Emit sum for input-&gt;key()Emit(IntToString(value));}};REGISTER_REDUCER(Adder);int main(int argc, char** argv) {ParseCommandLineFlags(argc, argv);MapReduceSpecification spec;// Store list of input files into &quot;spec&quot;for (int i = 1; i &lt; argc; i++) {MapReduceInput* input = spec.add_input();input-&gt;set_format(&quot;text&quot;);input-&gt;set_filepattern(argv[i]);input-&gt;set_mapper_class(&quot;WordCounter&quot;);}// Specify the output files:// /gfs/test/freq-00000-of-00100// /gfs/test/freq-00001-of-00100// ...MapReduceOutput* out = spec.output();out-&gt;set_filebase(&quot;/gfs/test/freq&quot;);out-&gt;set_num_tasks(100);out-&gt;set_format(&quot;text&quot;);out-&gt;set_reducer_class(&quot;Adder&quot;);// Optional: do partial sums within map// tasks to save network bandwidthout-&gt;set_combiner_class(&quot;Adder&quot;);// Tuning parameters: use at most 2000// machines and 100 MB of memory per taskspec.set_machines(2000);spec.set_map_megabytes(100);spec.set_reduce_megabytes(100);// Now run itMapReduceResult result;if (!MapReduce(spec, &amp;result)) abort();// Done: ’result’ structure contains info// about counters, time taken, number of// machines used, etc.return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;MapReduce是一个编程模型，是一个与处理和生成大数据集相关的实现。用户指定一个处理&lt;code&gt;键值对&lt;/code&gt;的  &lt;em&gt;Map&lt;/em&gt; 函数生成一个中间&lt;code&gt;键值对&lt;/code&gt;的集合，指定一个 &lt;em&gt;Redu
      
    
    </summary>
    
      <category term="翻译" scheme="https://yx1302317313.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>将QImage转换为numpy array</title>
    <link href="https://yx1302317313.github.io/2020/02/26/Convert-QImage-to-numpy-array/"/>
    <id>https://yx1302317313.github.io/2020/02/26/Convert-QImage-to-numpy-array/</id>
    <published>2020-02-26T14:26:16.000Z</published>
    <updated>2020-02-26T15:07:47.363Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做手写体识别，需要将QT中手写的数字转换成像训练集一样图片。因此需要将QImage转换为numpy array。</p><a id="more"></a><h2 id="前言">前言</h2><p>笔者使用的是PyQt，但是对QT和Python之间数据之间的转换不太熟悉。查了很长时间，也没有找到详细的说明，最后在stackoverflow中查到了转换方法，但是说的也不清楚。</p><p>终于，经过查阅QT的参考手册终于明白了转换过程。</p><h2 id="详细过程">详细过程</h2><pre><code class="language-python">from PIL import Imageimport numpy as npimport matplotlib.pyplot as pltimage = self.canvas_label.canvas.toImage()size = image.size()s = image.bits().asstring(size.width() * size.height() * image.depth() // 8)  # format 0xffRRGGBBarr = np.fromstring(s, dtype=np.uint8).reshape((size.height(), size.width(), image.depth() // 8))new_image = Image.fromarray(array)# convert to graynew_image.convert(&quot;L&quot;)new_image.thumbnail((28, 28))plt.imshow(new_image, cmap='gray')plt.show()</code></pre><h3 id="1-将QImage转换为字符串">1. 将QImage转换为字符串</h3><p>笔者的原图是通过QPixmap绘制的一幅RGB图。之后将其转换为QImage。</p><p>通过<code>s = image.bits().asstring(size.width() * size.height() * image.depth() // 8) </code>将图像数据转换成字符串。</p><p>参数是图像中字节数，字节数等于图像宽度 × 图像高度 × 通道数，即$bytes = width * height * channels$</p><p>需要注意的是通道数，查看QT的手册知道QT的RGB图像的格式是0xFFRRGGBB,其实就是将Alpha通道全部置为了0xFF。</p><p>之前以为只有3个通道，所以一直有问题。<code>QImage.depth()</code>可以返回图像深度的比特数，对于RGB图<code>QImage.depth()</code>返回值为32，所以整除8之后就是通道数。</p><h3 id="2-将字符串转换为Numpy-array">2. 将字符串转换为Numpy array</h3><p>之后使用<code>np.fromstring()</code>即可通过字符串构造numpy array。</p><p>到这里QImage转换为numpy array的任务就完成了。之后需要将原图进行灰度处理和压缩。</p><h3 id="3-灰度处理-压缩">3. 灰度处理 &amp; 压缩</h3><ul><li>使用<code>Image.convert()</code>可以进行格式转换，详细用法见https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.convert</li><li>使用<code>Image.thumbnail()</code>进行压缩，注意该方法只能进行压缩，不能放大，而且是等比例压缩。如果需要放大可以使用<code>Image.resize()</code>方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做手写体识别，需要将QT中手写的数字转换成像训练集一样图片。因此需要将QImage转换为numpy array。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Load Mnist database of handwritten digit via Python</title>
    <link href="https://yx1302317313.github.io/2020/02/20/Parser-Mnist/"/>
    <id>https://yx1302317313.github.io/2020/02/20/Parser-Mnist/</id>
    <published>2020-02-20T12:35:08.000Z</published>
    <updated>2020-02-20T14:55:05.752Z</updated>
    
    <content type="html"><![CDATA[<p>The handwritten digits recognition may be your first project when you get started with Tensorflow or Pytorch, and the dataset used in this project is the Mnist database of handwritten digit.</p><a id="more"></a><h2 id="What-is-Mnist">What is Mnist?</h2><h3 id="Introduction">Introduction</h3><p>The <strong>MNIST database</strong> (Modified National Institute of Standards and Technology database) is a large database of handwritten digits that is commonly used for training various image processing systems.The database is also widely used for training and testing in the field of machine <a href="http://learning.It" target="_blank" rel="noopener">learning.It</a> was created by “re-mixing” the samples from NIST’s original datasets. Source: Wikipedia.</p><h3 id="Get-Mnist">Get Mnist</h3><p>You can download the Mnist database from its website, <a href="http://yann.lecun.com/exdb/mnist/index.html" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/index.html</a>.</p><p>There are four compressed files incluing training set images, training set labels, test set images and test set labels.</p><h2 id="The-format-of-Mnist">The format of Mnist</h2><p>The data of Mnist  is stored in a very simple file format. However, you can’t open them with common application program, and you need write your own program to read these files.</p><p>The above website has given the format of both image files and label files.</p><p>Oh, there is a little problem about thd data.</p><blockquote><p>All the integers in the files are stored in the MSB first (high endian) format used by most non-Intel processors. Users of Intel processors and other low-endian machines must flip the bytes of the header.</p></blockquote><p>It points out that the integers in the files is differen from the integers in Intel processor which used by most people’s computers.</p><p>Let’s use 0x00000102 as an example. We start the memory address from 0x0000.</p><p>In Intel processor, the 0x00000102 was stored like this.</p><table><thead><tr><th>address</th><th>value</th></tr></thead><tbody><tr><td>0x0000</td><td>0x02</td></tr><tr><td>0x0001</td><td>0x01</td></tr><tr><td>0x0002</td><td>0x00</td></tr><tr><td>0x0003</td><td>0x00</td></tr></tbody></table><p>In most non-Intel processor, it likes this.</p><table><thead><tr><th>address</th><th>value</th></tr></thead><tbody><tr><td>0x0000</td><td>0x00</td></tr><tr><td>0x0001</td><td>0x00</td></tr><tr><td>0x0002</td><td>0x01</td></tr><tr><td>0x0003</td><td>0x02</td></tr></tbody></table><p>Now, you have known the difference.</p><h3 id="The-format-of-images">The format of images</h3><pre><code>[offset] [type]          [value]          [description]0000     32 bit integer  0x00000803(2051) magic number0004     32 bit integer  60000            number of images0008     32 bit integer  28               number of rows0012     32 bit integer  28               number of columns0016     unsigned byte   ??               pixel0017     unsigned byte   ??               pixel........xxxx     unsigned byte   ??               pixelPixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).</code></pre><p>The first integer is a magic number 0x803. I guess it was used to comfirm whether the file is parsed correctly. You can compare your first interget with 0x803 when you read the file using your own program.</p><p>The next three integers are number of images, the rows of image and the cols of image. Their meaning is obvious.</p><p>Other data is the pixel of images, ranging from 0 to 255.</p><h3 id="The-format-of-Labels">The format of Labels</h3><pre><code>[offset] [type]          [value]          [description]0000     32 bit integer  0x00000801(2049) magic number (MSB first)0004     32 bit integer  60000            number of items0008     unsigned byte   ??               label0009     unsigned byte   ??               label........xxxx     unsigned byte   ??               labelThe labels values are 0 to 9.</code></pre><p>The first integer is also a magic number, but it is different from the image files. The next integer is number of labels.</p><p>Other data is the label of images, ranging from 0 to 9.</p><h2 id="Load-Mnist-via-Python">Load Mnist via Python</h2><p>We will import a python package help us to produce the bytes data effectively.</p><p>It is <code>struct</code> which is a build-in class of python. The <code>struct</code> class is very easy, you can learn about it from Python API reference manual.</p><h3 id="Load-images">Load images</h3><pre><code class="language-python">import matplotlib.pyplot as pltimport numpy as npimport structimport mathdef load_image(filename, count=-1):size = struct.calcsize(&quot;&gt;IIII&quot;)try:with open(filename, 'rb') as file:buffer = file.read(size)magic, number, row, col = struct.unpack(&quot;&gt;IIII&quot;, buffer)if magic != 0x803:print(&quot;parse error!&quot;)returnif count == -1 or count &gt; number:count = number# read imagesize = count * row  * colsize = struct.calcsize('&gt;' + str(size) + 'B')buffer = file.read(size)images = struct.unpack('&gt;' + str(size) + 'B', buffer)images = np.reshape(images, [count, row * col])except FileNotFoundError:print(&quot;file \&quot;%s\&quot; not found!&quot; % filename)return images</code></pre><p>First, we need to read four integers in the head of images file. Then we verify the magic number, there are some bugs if they are not corressonding.</p><p>After that we read some images accoding to a variant <code>count</code>.</p><p>Now, you may understand the steps of <code>struct</code>.</p><ol><li>use function <code>calcsize</code> get the size of bytes.</li><li>read some bytes from file.</li><li>use function <code>unpack</code> get some variants according to designative format.</li></ol><p>Finally, the variant <code>images</code> is a long vector, it is necessary to reshape it use numpy before return it.</p><h3 id="Load-labels">Load labels</h3><pre><code class="language-python">def load_label(filename, count=-1):size = struct.calcsize(&quot;&gt;II&quot;)try:with open(filename, 'rb') as file:buffer = file.read(size)magic, number= struct.unpack(&quot;&gt;II&quot;, buffer)if magic != 0x801:print(&quot;parse error!&quot;)returnif count == -1 or count &gt; number:count = number# parser imagesize = struct.calcsize('&gt;' + str(count) + 'B')buffer = file.read(size)labels = struct.unpack('&gt;' + str(count) + 'B', buffer)except FileNotFoundError:print(&quot;file \&quot;%s\&quot; not found!&quot; % filename)return labels</code></pre><p>The code of <code>load_label</code> is same as <code>load_image</code>. You are so smart that you will understand it.</p><h3 id="Show-images">Show images</h3><pre><code class="language-python">def show_image(images, count):figure = plt.figure()plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, hspace=0.2, wspace=0.2)for i in range(count):image = np.reshape(images[i], [28, 28])ax = figure.add_subplot(math.ceil(count/5), 5, i+1)ax.imshow(image, cmap=plt.cm.binary)plt.show()</code></pre><p>We use <code>matplotlib</code> to show  loaded images.</p><p>The result:</p><center><img src="/img/blog/blog-25-1.png" width="600"></center><h2 id="END">END</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The handwritten digits recognition may be your first project when you get started with Tensorflow or Pytorch, and the dataset used in this project is the Mnist database of handwritten digit.&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="https://yx1302317313.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>Gitee导入Github仓库</title>
    <link href="https://yx1302317313.github.io/2020/02/20/Gitee-import-from-Github/"/>
    <id>https://yx1302317313.github.io/2020/02/20/Gitee-import-from-Github/</id>
    <published>2020-02-20T11:59:59.000Z</published>
    <updated>2020-02-23T11:16:41.511Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们可能需要将项目同时提交到Github和Gitee，通过使用Gitee导入Github仓库我们可以轻松完成这个任务。</p><a id="more"></a><h3 id="1-在Gitee中新建仓库">1. 在Gitee中新建仓库</h3><p>在最下方有一个导入已有仓库的选项，点击后可以输入github仓库的URL链接</p><center><img src="/img/blog/blog-24-1.png" width="600"></center><p>如果是私有仓库，需要提供Github的账号和密码，如下图：</p><center><img src="/img/blog/blog-24-2.png" width="600"></center><p>点击创建后，导入Github仓库就成功了。</p><h3 id="2-同步Github仓库">2. 同步Github仓库</h3><p>通过导入github仓库建立的gitee仓库可以同步在github中原仓库。</p><center><img src="/img/blog/blog-24-3.png" width="600"></center><p>点击上图中的强制同步选项，可以直接同步在github中的仓库。</p><p>这样在本地主机上的项目只需要提交到github的服务器之后再同步到gitee中，就可以轻松实现 <strong>将项目同时提交到github和gitee</strong> 。</p><hr><p><strong>更新：2020.02.23</strong></p><p>发现了一个问题：Gitee和Github的发布版不太一样。</p><ul><li>Github直接将tags作为发布版</li><li>Gitee的tags和发布版是独立的。</li></ul><p>所以在同步时，Github的发布版不会同步到Gitee，但是tags会进行同步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时我们可能需要将项目同时提交到Github和Gitee，通过使用Gitee导入Github仓库我们可以轻松完成这个任务。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://yx1302317313.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode-最长有效括号</title>
    <link href="https://yx1302317313.github.io/2020/01/22/LeetCode-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>https://yx1302317313.github.io/2020/01/22/LeetCode-最长有效括号/</id>
    <published>2020-01-22T08:28:59.000Z</published>
    <updated>2020-01-22T10:09:50.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目：最长有效括号">题目：最长有效括号</h2><p>给定一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><pre><code>输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot;</code></pre><p>示例 2:</p><pre><code>输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot;</code></pre><p>示例 3:</p><pre><code>输入: &quot;)(())())&quot;输出: 6解释: 最长有效括号子串为 &quot;(())()&quot;</code></pre><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">来源：力扣（LeetCode）</a></p><h2 id="算法：动态规划">算法：动态规划</h2><h3 id="解法：">解法：</h3><p>定义 $dp[i]$ 表示以第i个字符结尾的字符串中最长的有效括号长度。</p><p>example1:</p><pre><code>string: &quot;()()()&quot;index  : 0 1 2 3 4 5dp:      0 2 0 4 0 6</code></pre><p>example2:</p><pre><code>string: &quot;()((())&quot;index  : 0 1 2 3 4 5 6 dp:      0 2 0 0 0 2 4</code></pre><p>example3:</p><pre><code>string: &quot;()(())&quot;index: 0 1 2 3 4 5dp:    0 2 0 0 2 6</code></pre><ol><li>若$s[j] = ‘(’$, 由于’（'不可能是有效括号的结束字符，所以$dp[j] = 0$。</li><li>若$s[j] = ‘）’$，存在多种情况<ul><li>若$s[j-1]为’（’$， 若是则可以组成有效括号，有效括号长度+2。</li><li>若$s[j-1]为’）’$， 也不一定不是有效括号，还可能存在括号嵌套的情况，如&quot;example2&quot;, 这种情况则要判断 $s[dp[j-1] - 1]$是否等于’(’，是则+2。该情况可以和上一种情况合并，都可表示为判断 $s[dp[j-1] - 1] == ‘(’$ 是否成立。</li></ul></li><li>当 $dp[j]$是有效括号的结束字符时，要判断是否和之前的有效括号连续，如果连续要加上之前的长度。如&quot;example3&quot;， $s[5]= ‘)’$, 且 $s[5 - dp[4] - 1] = ‘(’$, 所以 $dp[5] = dp[4] + 2 = 4$。但是由于可以和之前的&quot;()&quot;连起来，所以 $dp[5] = dp[4] + 2 + dp[5 - dp[4] - 2] = 6$。</li></ol><h3 id="状态转移方程">状态转移方程</h3><p>$$dp[i]=\left{\begin{aligned}&amp;0, &amp;&amp;{s[i]=’(’}\&amp;0,&amp;&amp;{s[i]= ‘）’ \quad &amp;&amp; \quad s[i-dp[i-1]-1] \neq ‘(’}\&amp;dp[i-1] + 2 + dp[i-dp[i-1]-2], &amp;&amp;{s[i]= ‘）’ \quad &amp;&amp; \quad s[i-dp[i-1]-1] = ‘(’}\\end{aligned}\right.$$</p><h3 id="时间复杂度-空间复杂度">时间复杂度&amp;空间复杂度</h3><ol><li>时间复杂度: $O(n)$</li><li>空间复杂度: $O(n)$</li></ol><h2 id="LeetCode执行结果">LeetCode执行结果</h2><ul><li>执行用时 : <strong>4 ms</strong>, 在所有 C++ 提交中击败了 **95.63%**的用户。</li><li>内存消耗 : <strong>9.8 MB</strong>, 在所有 C++ 提交中击败了 **15.58%**的用户。</li></ul><h2 id="感受">感受</h2><p>其实动规比较简单，有套路可循。尤其是和字符串有关的题目，基本都与子串有关。但是难在子问题的划分，比如这道题中定义 $dp[i]$ 表示以第i个字符结尾的字符串中最长的有效括号长度，这样就比较简单。而我之前想的是定义为子串中最长有效括号的长度，到后面很难处理。</p><h2 id="代码">代码</h2><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Solution{public:int longestValidParentheses(string s){if(s.empty()){return 0;}vector&lt;int&gt; dp(s.length(),0);dp[0] = 0;for(int i=1; i&lt;s.length(); i++){if(s[i] == ')'){if(i - dp[i-1] -1 &gt;= 0 &amp;&amp;  s[i - dp[i-1] -1] == '('){if(i - dp[i-1] -2 &gt;=0){dp[i] = 2 + dp[i-1] + dp[i - dp[i-1] -2];}else{dp[i] = 2 + dp[i-1];}}}else{dp[i] = 0;}}return *max_element(dp.begin(), dp.end());}};int main(){string str;std::cout &lt;&lt; &quot;input:&quot;;std::cin &gt;&gt; str;Solution s;std::cout&lt;&lt;s.longestValidParentheses(str)&lt;&lt;std::endl;return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目：最长有效括号&quot;&gt;题目：最长有效括号&lt;/h2&gt;
&lt;p&gt;给定一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;(()&amp;quot;
输出: 2
解释: 最长有
      
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="https://yx1302317313.github.io/tags/C/"/>
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-扰乱字符串</title>
    <link href="https://yx1302317313.github.io/2020/01/19/LeeCode-%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://yx1302317313.github.io/2020/01/19/LeeCode-扰乱字符串/</id>
    <published>2020-01-19T14:07:49.000Z</published>
    <updated>2020-01-19T15:08:07.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：扰乱字符串">题目：扰乱字符串</h3><p>给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。</p><p>下图是字符串 s1 = “great” 的一种可能的表示形式。</p><pre><code>    great   /    \  gr    eat / \    /  \g   r  e   at           / \          a   t</code></pre><p>在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。</p><p>例如，如果我们挑选非叶节点 “gr” ，交换它的两个子节点，将会产生扰乱字符串 “rgeat” 。</p><pre><code>    rgeat   /    \  rg    eat / \    /  \r   g  e   at           / \          a   t</code></pre><p>我们将 &quot;rgeat” 称作 “great” 的一个扰乱字符串。</p><p>同样地，如果我们继续交换节点 “eat” 和 “at” 的子节点，将会产生另一个新的扰乱字符串 “rgtae” 。</p><pre><code>    rgtae   /    \  rg    tae / \    /  \r   g  ta  e       / \      t   a</code></pre><p>我们将 &quot;rgtae” 称作 “great” 的一个扰乱字符串。</p><p>给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。</p><p>示例 1:</p><pre><code>输入: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;输出: true</code></pre><p>示例 2:</p><pre><code>输入: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;输出: false</code></pre><p>来源：力扣（LeetCode）。链接：<a href="https://leetcode-cn.com/problems/scramble-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/scramble-string</a></p><h3 id="解题思路：递归">解题思路：递归</h3><p>由于无法得知原字符串分割的位置，所以通过蛮力遍历每一个位置对原字符串进行分割，然后比较原字符串和扰乱字符串分割之后的子串是否相等。子串同样进行了分割，则需要再对子串进行分割判断。这个时候就可以使用递归了。</p><p>由于分割之后还可能进行交换，所以需要判断两种情况：</p><ol><li>直接对原字符串进行分割，比较原字符串和扰乱字符串分割之后的子串是否相等。即s1[0, i] == s2[0, i] &amp;&amp; s1[i+1, len - 1] == s2[i+1, len -1]。</li><li>将分割后的两个子串交换，然后比较交换后的子串。s1[0, i] == s2[len-1 - i, len-1] &amp;&amp; s1[i+1, len - 1] == s2[0, len-i]。</li></ol><p>优化：由于分割交换并不会改变字符串中字符的个数，所以可以通过统计并比较两字符串中各字符的个数是否相等做一次筛选。如果不等，则一定不是扰乱字符串。这是一个 <strong>必要条件</strong>。</p><h3 id="LeetCode-运行结果">LeetCode 运行结果</h3><ul><li>执行用时 :8 ms, 在所有 C++ 提交中击败88.36的用户。</li><li>内存消耗 :10 MB, 在所有 C++ 提交中击败了78.16%的用户。</li></ul><h3 id="代码">代码</h3><pre><code class="language-cpp">class Solution{public:        bool isScramble(string s1, string s2)        {                if (s1.size() &lt;= 1)                {                        if (s1 == s2)                        {                                return true;                        }                }                else                {                        return _isScramble(s1, s2);                }                return false;        }        bool _isScramble(string s1, string s2)        {                                       int m = s1.length();                if(s1 == s2)                {                        return true;                }                //统计s1和s2的字符个数，判断相应的字符个数是否相等。（必要条件）                int char_num[26] = {0};                for(int i=0; i&lt;m;i++)                {                        char_num[s1[i] - 'a']++;                        char_num[s2[i] - 'a']--;                }                for(int i=0; i&lt;26; i++)                {                        if(char_num[i] != 0)                        {                                return false;                        }                }                for (int i = 0; i &lt; m-1; i++)                {                        //蛮力切割                        if ((_isScramble(s1.substr(0, i+1), s2.substr(0, i+1)) &amp;&amp;                        _isScramble(s1.substr(i + 1, m - (i + 1)), s2.substr(i + 1, m - (i + 1)))) == 1)                        {                                return true;                        }                        //切割并且交换                        if ((_isScramble(s1.substr(0, i+1), s2.substr(m-(i+1), i+1)) &amp;&amp;                        _isScramble(s1.substr(i + 1, m - (i + 1)), s2.substr(0, m - (i + 1)))) == 1)                        {                                return true;                        }                }                return false;        }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：扰乱字符串&quot;&gt;题目：扰乱字符串&lt;/h3&gt;
&lt;p&gt;给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。&lt;/p&gt;
&lt;p&gt;下图是字符串 s1 = “great” 的一种可能的表示形式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    gre
      
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="https://yx1302317313.github.io/tags/C/"/>
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>Linux 管道通信</title>
    <link href="https://yx1302317313.github.io/2019/11/14/Linux-Pipe/"/>
    <id>https://yx1302317313.github.io/2019/11/14/Linux-Pipe/</id>
    <published>2019-11-14T10:42:32.000Z</published>
    <updated>2020-01-22T10:11:15.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统调用-fork">系统调用 fork</h2><p>在linux系统中创建进程有两种方式</p><ul><li>一是由操作系统创建。</li><li>二是由父进程创建进程。系统调用函数fork()是创建一个新进程的唯一方式。</li></ul><p>fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程。</p><ol><li>系统先给新的进程分配资源，例如存储数据和代码的空间。</li><li>然后把原来的进程（父进程）的所有值都复制到新的新进程（子进程）中，只有少数值与原来的进程的值不同。</li><li>Linux的fork()采用写时拷贝实现，只有子进程发起写操作时才正真执行拷贝，在写时拷贝之前都是以只读的方式共享。这样可以避免发生拷贝大量数据而不被使用的情况。</li></ol><p>fork是Linux系统中一个比较特殊的函数，其一次调用会有两个返回值。在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。如果失败返回值是1。</p><ul><li>在子进程中，fork函数返回0。</li><li>在父进程中，fork返回新创建子进程的进程ID。</li></ul><p>因此我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p><h2 id="管道">管道</h2><p>Linux中，每个管道允许两个进程交互数据，一个进程向管道写入数据，一个进程从管道读出数据。Linux并没有给管道定义一个新的数据结构，而是借用了文件系统中文件的数据结构。即管道实际是一个文件（但是与文件并不完全形同）。</p><p>操作系统在内存中为每个管道开辟一页内存（4KB），给这一页赋予了文件的属性。这一页内存由两个进程共享，但不会分配给任何进程，只由内核掌控。</p><h3 id="示例">示例</h3><blockquote><p>Linux pipe手册中的例子</p></blockquote><pre><code class="language-c">#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]){        int pipefd[2];        pid_t cpid;        char buf;        if (argc != 2)        {                fprintf(stderr, &quot;Usage: %s &lt;string&gt;\n&quot;, argv[0]);                exit(EXIT_FAILURE);        }        if (pipe(pipefd) == -1)        {                perror(&quot;pipe&quot;);                exit(EXIT_FAILURE);        }        cpid = fork();        if (cpid == -1)        {                perror(&quot;fork&quot;);                exit(EXIT_FAILURE);        }        if (cpid == 0)        {                         /* Child reads from pipe */                close(pipefd[1]); /* Close unused write end */                while (read(pipefd[0], &amp;buf, 1) &gt; 0)                        write(STDOUT_FILENO, &amp;buf, 1);                write(STDOUT_FILENO, &quot;\n&quot;, 1);                close(pipefd[0]);                _exit(EXIT_SUCCESS);        }        else        {                         /* Parent writes argv[1] to pipe */                close(pipefd[0]); /* Close unused read end */                write(pipefd[1], argv[1], strlen(argv[1]));                close(pipefd[1]); /* Reader will see EOF */                wait(NULL);       /* Wait for child */                exit(EXIT_SUCCESS);        }}</code></pre><p><img src="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/inter-process-communication/pipe/%E6%A0%B7%E4%BE%8B%E7%A4%BA%E5%9B%BE.png" alt></p><h3 id="管道的读写">管道的读写</h3><ul><li>读管道进程执行时，如果管道中有未读数据，就读取数据，没有未读数据就挂起，这样就不会读取垃圾数据。</li><li>写管道进程执行时，如果管道中有剩余空间，就写入数据，没有剩余空间了，就挂起，这样就不会覆盖尚未读取的数据。</li></ul><h4 id="读管道">读管道</h4><p>对于读管道操作，数据是从管道尾读出，并使管道尾指针前移‘读取字节数’个位置。</p><p><img src="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/inter-process-communication/pipe/%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p><p>Linux 0.11 源码</p><pre><code class="language-c">//fs/pipe.cint read_pipe(struct m_inode * inode, char * buf, int count){int chars, size, read = 0;while (count&gt;0) {while (!(size=PIPE_SIZE(*inode))) {//管道空wake_up(&amp;inode-&gt;i_wait);//唤醒等待写管道进程if (inode-&gt;i_count != 2) /* are there any writers? */return read;//没有writer，返回sleep_on(&amp;inode-&gt;i_wait);//挂起读管道进程}chars = PAGE_SIZE-PIPE_TAIL(*inode);//PAGE_SIZE: 4KB if (chars &gt; count)chars = count;if (chars &gt; size)chars = size;count -= chars;read += chars;size = PIPE_TAIL(*inode);PIPE_TAIL(*inode) += chars;     // 读多少数据，指针就偏移多少PIPE_TAIL(*inode) &amp;= (PAGE_SIZE-1);     // 指针超过一个页面，（&amp;= ）操作可以实现自动回滚while (chars-- &gt;0)put_fs_byte(((char *)inode-&gt;i_size)[size++],buf++);     //将管道中的数据拷贝至buf}wake_up(&amp;inode-&gt;i_wait);    //唤醒等待写管道进程return read;}// include/linux/fs.h#define PIPE_HEAD(inode) ((inode).i_zone[0])#define PIPE_TAIL(inode) ((inode).i_zone[1])//PIPE_HEAD(inode)-PIPE_TAIL(inode) &lt; 0，和 (PAGE_SIZE-1) 相与能够计算出管道未读数据的长度#define PIPE_SIZE(inode) ((PIPE_HEAD(inode)-PIPE_TAIL(inode))&amp;(PAGE_SIZE-1))</code></pre><h4 id="写管道">写管道</h4><p>对于写管道操作，数据是向管道头部写入，并使管道头指针前移‘写入字节数’个位置。</p><p>Linux 0.11 源码</p><pre><code class="language-c">//fs/pipe.cint write_pipe(struct m_inode * inode, char * buf, int count){int chars, size, written = 0;while (count&gt;0) {while (!(size=(PAGE_SIZE-1)-PIPE_SIZE(*inode))) {   //管道已满wake_up(&amp;inode-&gt;i_wait);         //唤醒等待读管道进程if (inode-&gt;i_count != 2) { /* no readers */current-&gt;signal |= (1&lt;&lt;(SIGPIPE-1));return written?written:-1;      //没有reader，返回}sleep_on(&amp;inode-&gt;i_wait);       //挂起写管道进程}chars = PAGE_SIZE-PIPE_HEAD(*inode);if (chars &gt; count)chars = count;if (chars &gt; size)chars = size;count -= chars;written += chars;size = PIPE_HEAD(*inode);PIPE_HEAD(*inode) += chars;PIPE_HEAD(*inode) &amp;= (PAGE_SIZE-1);     // 指针超过一个页面，（&amp;= ）操作可以实现自动回滚while (chars-- &gt;0)((char *)inode-&gt;i_size)[size++]=get_fs_byte(buf++); //读取buf中的数据写入管道}wake_up(&amp;inode-&gt;i_wait);    //唤醒等待读管道进程return written;}// include/linux/fs.h#define PIPE_HEAD(inode) ((inode).i_zone[0])#define PIPE_TAIL(inode) ((inode).i_zone[1])//PIPE_HEAD(inode)-PIPE_TAIL(inode) &lt; 0，和 (PAGE_SIZE-1) 相与能够计算出管道未读数据的长度#define PIPE_SIZE(inode) ((PIPE_HEAD(inode)-PIPE_TAIL(inode))&amp;(PAGE_SIZE-1))</code></pre><h3 id="管道的特点">管道的特点</h3><ul><li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li><li>只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；</li><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。</li><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li></ul><h3 id="管道的局限性">管道的局限性</h3><ul><li>只支持单向数据流。</li><li>只能用于具有亲缘关系的进程之间。</li><li>没有名字（有名管道是 FIFO）。</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）。</li><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）。</li><li>…</li></ul><h2 id="双向管道通信">双向管道通信</h2><ol><li>父进程创建两个管道,pipe1和pipe2.</li><li>父进程创建子进程,调用fork()的过程中子进程会复制父进程创建的两个管道.</li><li>实现父进程向子进程通信:父进程关闭pipe1的读端,保留写端;而子进程关闭pipe1的写端,保留读端.</li><li>实现子进程向父进程通信:子进程关闭pipe2的读端,保留写端;而父进程关闭pipe2的写端,保留读端.</li></ol><pre><code class="language-c">#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]){        int pipe_command[2];    //管道1 父进程 -&gt; 子进程        int pipe_result[2];     //管道2 子进程 -&gt; 父进程         pid_t cpid;        char buf[4];        //父进程创建管道        if (pipe(pipe_command) == -1)        {                perror(&quot;pipe_command&quot;);                exit(EXIT_FAILURE);        }        if(pipe(pipe_result) == -1)        {                perror(&quot;pipe_result&quot;);                exit(EXIT_FAILURE);        }        //创建子进程        cpid = fork();        if (cpid == -1)        {                perror(&quot;fork error&quot;);                exit(EXIT_FAILURE);        }        if (cpid == 0)  /*子进程*/        {                                        printf(&quot;sub: pid %d\n&quot;, getpid());      //输出子进程ID                close(pipe_command[1]);         //关闭管道写端                close(pipe_result[0]);            //关闭管道读端                int read_status;                while (1)                {                        read_status =  read(pipe_command[0], buf, 4);   //读取父进程的命令                        if(read_status &gt; 0)                        {                                printf(&quot;sub: command %s\n&quot;, buf);                                if(strcmp(buf, &quot;hell&quot;) == 0)                                {                                                                                write(pipe_result[1], &quot;okok&quot;, 4);       //回应父进程                                }                                else if( strcmp(buf, &quot;exit&quot;) == 0)                                {                                        printf(&quot;sub: exit\n&quot;);                                        break;                                }                         }                                               else if(read_status &lt; 0)        //读取错误                        {                                perror(&quot;sub: read error!&quot;);                                break;                        }                                                       }                        close(pipe_command[0]); //关闭管道                close(pipe_result[1]);                exit(EXIT_SUCCESS);        }        else    /*父进程*/        {                printf(&quot;parent: pid %d\n&quot;, getpid());      //输出父进程ID                close(pipe_command[0]); //关闭管道读端                close(pipe_result[1]);  //关闭管道写端                write(pipe_command[1], &quot;hell&quot;, 4);      //向子进程发送命令                 int read_status;                while (1)                {                        read_status = read(pipe_result[0], buf, 4);                        if(read_status &gt; 0)                        {                                printf(&quot;parent: received %s\n&quot;, buf);           //接收子进程回应                                write(pipe_command[1], &quot;exit&quot;, 4);      //通知子进程退出                                break;                        }                                                      else if(read_status &lt; 0)         //读取错误                        {                                perror(&quot;parent: read error!&quot;);                                break;                        }                                                                          }                                close(pipe_command[1]);                 close(pipe_result[0]);                /* 等待子进程退出,并判断状态吗码*/                int status;                waitpid(-1, &amp;status , 0);                                             if(WIFEXITED(status))                {                        printf(&quot;exited: %d\n&quot;, WEXITSTATUS(status));                }                                                else if(WIFSIGNALED(status))                {                        printf(&quot;signaled: %d\n&quot;, WTERMSIG(status));                }                exit(EXIT_SUCCESS);        }}</code></pre><h2 id="参考">参考</h2><ol><li>《Linux内核设计的艺术》</li><li>《Linux内核设计与实现》</li><li>Linux v0.11内核源码(<a href="https://github.com/karottc/linux-0.11" target="_blank" rel="noopener">https://github.com/karottc/linux-0.11</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统调用-fork&quot;&gt;系统调用 fork&lt;/h2&gt;
&lt;p&gt;在linux系统中创建进程有两种方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是由操作系统创建。&lt;/li&gt;
&lt;li&gt;二是由父进程创建进程。系统调用函数fork()是创建一个新进程的唯一方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p
      
    
    </summary>
    
      <category term="Linux" scheme="https://yx1302317313.github.io/categories/Linux/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="kernel" scheme="https://yx1302317313.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Git 的子模块（submodule）</title>
    <link href="https://yx1302317313.github.io/2019/11/09/Git-%E7%9A%84%E5%AD%90%E6%A8%A1%E5%9D%97%EF%BC%88submodule%EF%BC%89/"/>
    <id>https://yx1302317313.github.io/2019/11/09/Git-的子模块（submodule）/</id>
    <published>2019-11-09T14:22:32.000Z</published>
    <updated>2019-11-16T13:45:51.951Z</updated>
    
    <content type="html"><![CDATA[<h3 id="submodule的作用">submodule的作用</h3><blockquote><p>Git使用submodule(子模块)解决git仓库的嵌套问题，允许一个 Git 仓库作为另一个 Git 仓库的子目录。 能在将另一个仓库克隆到自己的项目中的同时,保持项目提交的独立性。详细参见<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">《pro git》子模块</a></p></blockquote><h3 id="submodule的原理">submodule的原理</h3><blockquote><p>submodule的实现很巧妙也很简单。其实submodule对于原本的git仓库只是多添加了一条或者几条记录(在.gitmodule中),它记录了仓库中包含的子模块的名称和URL.</p></blockquote><blockquote><p>当需要使用子模块的文件时，通过指定的URL使用HTTP协议下载到本地，同样如果对子模块里的内容做出修改之后，通过该URL可以提交到子模块的远程仓库（而不是提交到你的仓库），而本地仓库只是修改了一条记录（其实只是修改了指向子模块仓库的分支）。</p></blockquote><h3 id="使用submodule">使用submodule</h3><h4 id="1、新建submodule">1、新建submodule</h4><p>使用<code>git submodule add</code>添加新的子模块</p><pre><code class="language-sh">$ git submodule add &quot;URL&quot;</code></pre><p>下图演示了添加名为Game的子模块</p><center><img src="/img/blog/blog-23-1.png" width="600"></center><p>之后会发现目录下多了一个Game目录和.gitmodules的文件。其中Game目录下是你所希望包含项目的分支代码，而gitmodules的内容如下。也就是之前提到的submodule使用子模块的名称和URL记录本仓库包含的子模块。</p><pre><code>[submodule &quot;Game&quot;]path = Gameurl = https://github.com/yx1302317313/Game.git</code></pre><p>提交之后查看远程仓库会发现添加的子模块的文件并没有传到远程仓库，子模块的文件夹实际是一个URL，指向了包含子模块本身的远程仓库。</p><center><img src="/img/blog/blog-23-2.png" width="600"></center><h4 id="2、克隆包含submodule的项目">2、克隆包含submodule的项目</h4><p>当使用<code>git clone </code>克隆一个包含子模块的项目时，子模块的文件并不会一同并拉取到本地，而只是一个空目录。</p><center><img src="/img/blog/blog-23-3.png" width="600"></center><p>这时需要使用<code>git submodule init</code>用来初始化本地配置文件,而 <code>git submodule update</code>则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p><center><img src="/img/blog/blog-23-4.png" width="600"></center><br><center><img src="/img/blog/blog-23-5.png" width="600"></center><p>一个更简单的方法是给<code>git clone</code>加上递归选项<code> --recursive</code></p><pre><code class="language-sh">$ git clone --recursive &quot;URL&quot; # 自动初始化并更新仓库中的每一个子模块</code></pre><p><strong>[注意]：</strong> 由于git的子模块跟踪的是提交记录(commit id)，所以拉取下来的是一个游离分支，其实是将一个提交记录作为了一个游离的分支。这时候还需要切换到master分支。</p><pre><code class="language-sh">$ cd Game$ git checkout master</code></pre><p>所以整个克隆的步骤如下：</p><ol><li>克隆远程仓库：git clone “URL”</li><li>初始化子模块：git submodule init</li><li>拉取子模块的内容：git submodule update</li><li>进入子模块切换至主分支: git checkout master</li></ol><h4 id="3、更新submodule">3、更新submodule</h4><ol><li>进入submodule的目录。</li><li>使用<code>git fetch</code>和<code>git merge</code>更新submodule,与远程仓库的最新代码合并（当然也可以直接使用<code>git pull</code>）。</li></ol><h5 id="关于-git-fetch-与-git-pull">关于 git fetch 与 git pull</h5><blockquote><p>git pull = git fetch + git merge, 可以参考<a href="https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch" target="_blank" rel="noopener">stack overflow</a></p></blockquote><p><strong>更简单的方式</strong>：运行<code>git submodule update --remote</code>, 使用该命令Git将会进入子模块然后进行抓取并更新。</p><p><strong>注意：该命令默认fetch和merge主分支（master），如果是其他分支，需要进行配置（见《pro git》）。</strong></p><h4 id="4、修改并提交submodule">4、修改并提交submodule</h4><h5 id="提交前的fetch">提交前的fetch</h5><p>当修改了submodule的文件时，这里有一个需要注意的地方。一般我们在提交之前都需要查看远程分支是否有更新，会不会有冲突。我们的方法是使用<code>git fetch</code>抓取远程分支查看是否更新然后进行<code>git merge</code>。（使用<code>git pull</code>也没什么太大的问题）。</p><p>需要注意的地方是<code>git submodule update</code>，之前提到这个命令也可以完成上面的功能，还更方便。</p><p>但是《pro git》中提到</p><blockquote><p>当我们运行 git submodule update 从子模块仓库中抓取修改时,Git 将会获得这些改动并更新子目录中的文件,但是会将子仓库留在一个称作“游离的 HEAD”的状态。 这意味着没有本地工作分支(例如“master” )跟踪改动。 所以你做的任何改动都不会被跟踪。</p></blockquote><p>这段话感觉很难理解，英文版说的更直接一点。</p><blockquote><p>So far, when we’ve run the git submodule update command to fetch changes from the submodule repositories, Git would get the changes and update the files in the subdirectory but will leave the sub-repository in what’s called a “detached HEAD” state. This means that there is no local working branch (like “master”, for example) tracking changes. With no working branch tracking changes, that means even if you commit changes to the submodule, those changes will quite possibly be lost the next time you run git submodule update. You have to do some extra steps if you want changes in a submodule to be tracked.</p></blockquote><p>关键是这句话</p><blockquote><p>With no working branch tracking changes, that means even if you commit changes to the submodule, those changes will quite possibly be lost the next time you run git submodule update.</p></blockquote><p>意思就是如果远程仓库发生了改动，并且你本地有未推送到远程仓库的提交（commit），执行<code>git submodule update</code>后你的提交并不会与远程仓库进行合并（merge）。而是成为了一个游离的分支。</p><p>像这样，在update之后，分支变成了a58a3ae,而不再是master（master变成了游离状态）。</p><center><img src="/img/blog/blog-23-11.png" width="600"></center><br><center><img src="/img/blog/blog-23-12.png" width="600"></center><p>如果发生了这种情况，处理很简单，使用<code>git checkout master</code></p><center><img src="/img/blog/blog-23-13.png" width="600"></center><p>正确的做法是使用<code>git submodule update --merge</code>，这个命令会告诉Git进行合并（前提是不发生冲突，如果发生了冲突请看下一节）。</p><center><img src="/img/blog/blog-23-14.png" width="600"></center><h5 id="提交">提交</h5><p><strong>注意：使用git push并不会提交子模块。</strong></p><p>为了防止这种错误发生，git推荐提交使用<code>git push --recurse-submodules=check</code>，如果没有提交子模块，会提示你使用两种方法完成子模块的提交。</p><ol><li>进入各个子模块目录使用<code>git push</code>提交各个子模块，然后提交你的项目。</li><li>使用<code>git push --recurse-submodules=on-demand</code>命令提交， 该命令会自动提交子模块，然后再提交你的项目。如果子模块提交失败，整个提交也会失败。</li></ol><center><img src="/img/blog/blog-23-15.png" width="600"></center><p>到这里，子模块的使用就快基本完成了。最后一部分是最令人麻烦的conflict。</p><h4 id="5、解决submodule冲突">5、解决submodule冲突</h4><p>解决冲突的步骤如下：</p><ol><li>进入子模块目录，解决冲突。（方法同解决正常的git冲突）</li><li>在子模块中提交解决冲突的记录。</li><li>切换到你的项目目录。</li><li>提交解决子模块冲突的记录。</li><li>推送到远程（如果需要）。</li></ol><center><img src="/img/blog/blog-23-16.png" width="600"><p>git pull 发生冲突</p></center><br><center><img src="/img/blog/blog-23-17.png" width="600"><p>找到冲突的文件</p></center><br><center><img src="/img/blog/blog-23-18.png" width="600"><p>解决冲突，并在子模块目录提交记录</p></center><br><center><img src="/img/blog/blog-23-19.png" width="600"><p>在父目录中提交子模块冲突的提交记录</p></center><br><center><img src="/img/blog/blog-23-20.png" width="600"><p>成功推送到远程仓库</p></center><h3 id="写在最后">写在最后</h3><p>当然子模块还有些技巧，比如子模块遍历，命令别名等，见《pro git》。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;submodule的作用&quot;&gt;submodule的作用&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Git使用submodule(子模块)解决git仓库的嵌套问题，允许一个 Git 仓库作为另一个 Git 仓库的子目录。 能在将另一个仓库克隆到自己的项目中的同时,保持
      
    
    </summary>
    
      <category term="Git" scheme="https://yx1302317313.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈Python编码</title>
    <link href="https://yx1302317313.github.io/2019/10/19/%E6%B5%85%E8%B0%88Python%E7%BC%96%E7%A0%81/"/>
    <id>https://yx1302317313.github.io/2019/10/19/浅谈Python编码/</id>
    <published>2019-10-19T04:28:19.000Z</published>
    <updated>2020-02-20T12:53:52.617Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python的编码问题可能是很多人都遇到过的问题（没遇到的终将会遇到的），笔者之前也对这个问题很模糊，今天看了《Effective Python》之后总结一下自己的理解。</p></blockquote><a id="more"></a><h3 id="Unicode">Unicode</h3><p>先看ASCII码，ASCII码我们比较熟悉，用一个字节表示了128个字符，其中包含标点符号，数字，英文字母等。</p><p>但是ASCII有一个问题，就是一个字节只有8位最多只能表示256个字符，不可能表示世界各个国家的字符。于是有了Unicode码。</p><p>Unicode码（统一码，万国码）：用多个字节表示全世界的所有字符，为每一个字符分配了一个唯一的标识（一个整数），在表示一个 Unicode 的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。</p><p><strong>来自Wiki百科</strong>：在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。</p><h3 id="UTF-8">UTF-8</h3><p>UTF-8：由于Unicode只是给每一个字符分配了一个整数值，但是没有规定如何存储这个整数值（比如：用几个字节存储），所以需要utf-8等编码。utf-8是一种将Unicode码转换成字节序列编码方式，是一种可变长编码。</p><p>可以这样理解：</p><ul><li>Unicode -&gt; utf-8编码 -&gt; bytes</li><li>bytes -&gt; utf-8解码 -&gt; Unicode</li></ul><p>UTF-8只是Unicode与字节流编码方式中的一种，还有UTF-16, GB-2312, GBK（windows系统的中文编码是GBK）编码等等。这些编码做的工作就是将Unicode规定字符对应的整数值用一个或多个字节表示出来。</p><p>因为IO，网络数据传输都是通过字节流的方式，所以在编程时需要将Unicode码转换成字节流再进行传输；同样需要将从IO，网络接收到的字节流转换成Unicode码。</p><h3 id="bytes、str与unicode">bytes、str与unicode</h3><p>Python2和Python3的不同点之一就是编码问题。其中str和unicode是Python2中的编码，而bytes和str是Python3中的编码。</p><p>Python2中的编码：</p><ul><li>str：bytes序列的字符串</li><li>unicode：unicode码点序列 的字符串</li></ul><p>Python3中的编码：</p><ul><li>bytes: bytes序列的字符串。</li><li>str: unicode码点序列 的字符串。</li></ul><p>让人疑惑的是str，str在Python2和Python3中表示不同的编码，Python2中表示字节序列，即bytes; Python3中表示Unicode码。<strong>个人理解是Python3想让在程序中定义的字符串使用Unicode码表示，而不是Python2中用字节流表示。</strong></p><h4 id="Python2">Python2</h4><pre><code class="language-python">&gt;&gt;&gt; string = &quot;python&quot;&gt;&gt;&gt; type(string)&lt;type 'str'&gt;&gt;&gt;&gt; u_str = u&quot;python&quot;&gt;&gt;&gt; type(u_str)&lt;type 'unicode'&gt;</code></pre><h4 id="Python3">Python3</h4><pre><code class="language-python">&gt;&gt;&gt; string = &quot;python&quot;&gt;&gt;&gt; bytes = b&quot;python&quot;&gt;&gt;&gt; type(string)&lt;class 'str'&gt;&gt;&gt;&gt; type(bytes)&lt;class 'bytes'&gt;</code></pre><h3 id="encode与decode">encode与decode</h3><blockquote><p>encode()和decode()是Python中用于bytes字节序列与Unicode序列转换的函数。</p></blockquote><ul><li>unicode.encode() -&gt; bytes:只有对于unicode对象我们才应该使用.encode()方法。这一方法用来将一系列unicode编码为bytes流。</li><li>bytes.decode() -&gt; unicode: 只有对于bytes，或说Python2中的str对象，我们才应该调用.decode()方法。这一方法将一系列bytes流解码为原本的unicode码点。</li></ul><h4 id="Python2-2">Python2</h4><pre><code class="language-python"># str 与 unicode&gt;&gt;&gt; string = &quot;python&quot;&gt;&gt;&gt; type(string)&lt;type 'str'&gt;&gt;&gt;&gt; u_str = u&quot;python&quot;&gt;&gt;&gt; type(u_str)&lt;type 'unicode'&gt;# str解码 -&gt; Unicode&gt;&gt;&gt; de_string = string.decode()&gt;&gt;&gt; type(de_string)&lt;type 'unicode'&gt;# unicode 编码 -&gt; str&gt;&gt;&gt; en_u_str = u_str.encode()&gt;&gt;&gt; type(en_u_str)&lt;type 'str'&gt;</code></pre><h4 id="Python3-2">Python3</h4><pre><code class="language-python"># str 与 bytes&gt;&gt;&gt; string = &quot;python&quot;&gt;&gt;&gt; bytes = b&quot;python&quot;&gt;&gt;&gt; type(string)&lt;class 'str'&gt;&gt;&gt;&gt; type(bytes)&lt;class 'bytes'&gt;# str编码 -&gt; butes&gt;&gt;&gt; en_string = string.encode()&gt;&gt;&gt; type(en_string)&lt;class 'bytes'&gt;# bytes 解码 -&gt; str&gt;&gt;&gt; de_bytes = bytes.decode()&gt;&gt;&gt; type(de_bytes)&lt;class 'str'&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Python的编码问题可能是很多人都遇到过的问题（没遇到的终将会遇到的），笔者之前也对这个问题很模糊，今天看了《Effective Python》之后总结一下自己的理解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://yx1302317313.github.io/categories/Python/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>球状闪电</title>
    <link href="https://yx1302317313.github.io/2019/10/07/%E7%90%83%E7%8A%B6%E9%97%AA%E7%94%B5/"/>
    <id>https://yx1302317313.github.io/2019/10/07/球状闪电/</id>
    <published>2019-10-07T07:56:04.000Z</published>
    <updated>2020-02-21T05:38:51.838Z</updated>
    
    <content type="html"><![CDATA[<!-- <center><img src="/img/blog/blog-22-1.jpg" width=800></center> --><blockquote><p>考试周的时候重新看了刘慈欣的《球状闪电》，个人一直很喜欢这本书，甚至超过了《三体》。但是一直没时间为这本书写一点东西，趁机抓住国庆假期的尾巴，写写我的体会。</p></blockquote><a id="more"></a><center><img src="/img/blog/blog-27-balllightning.jpg" width="600"></center><h3 id="前言">前言</h3><p>第一次看《球状闪电》是一场意外。本来在看三体，第一部看完之后，应该是第二部《黑暗森林》。但是越看越不对，为什么和前面一点关系都没有，陈博士是干吗的？球状闪电是什么？</p><p>看了一半了才发现原来这个不是《黑暗森林》，而是《球状闪电》。<s>(论盗版小说的危害)</s>。但是看都看了，而且感觉写的不错，索性就看完了。可能当时还太年轻，没有太多感触，哈哈~~。不过对其中的一段话影响很深。</p><center>一片树林里分出两条路，<br>而我选了人迹更少的一条，<br>从此决定了我一生的道路。</center><p>这段话来自弗罗斯特的《未选择的路》， 考试周期间的一些事又让我想起了这段话，于是决定重新看一遍《球状闪电》。</p><p><strong>以下内容可能会因为记忆错误或者理解错误有所偏差，当然也有剧透噢</strong></p><h3 id="没有名字的男主">没有名字的男主</h3><p>前一段时间一直在想男主的名字是什么，想了很长时间也没有想起来。<s>(疯狂怀疑自己的记忆力)</s>。之后查了才发现，原来刘慈欣根本就没有提及男主的名字，全书都是用“我”、“陈博士”叙述，卑微呀。</p><p>仔细想想男主确实挺惨的，少年时期父母因球状闪电双双去世；自己追寻球状闪电十几年，发现球状闪电原来是自然界最基本的物质，并不是自己所学能解决的；注定与自己喜欢的女孩无缘；没有林云的勇敢；没有丁仪对物理学的那份热爱与执着；甚至在林云的大尉男友面前都感到自惭形秽。</p><p>不过，他也是幸运的。和那些追寻球状闪电一生却连球状闪电都没有见过的人比起来，他简直是幸福的，他发现了球状闪电的秘密，甚至捕捉到了球状闪电。</p><blockquote><p>一个美妙的人生并不难，听爸爸教你：你选一个公认的世界难题，最好只用一张纸和一支铅笔的数学难题，比如哥德巴赫猜想或者费马大定理什么的，或连纸笔都不要的纯自然哲学难题，比如宇宙的本源之类，投入全部身心钻研，只问耕耘不问收获，不知不觉的专注中，一辈子也就过去了。</p></blockquote><p>上面的这段话是男主的父亲之前对他说的，男主的前半生可以说是做到了这一点，一直在追寻球状闪电的秘密。当然，这句话不仅在说男主，书中的很多人都在做着这样的事——用一生追寻一个问题或者一件事。像男主的老师那样终生寻找球状闪电之谜的人；对武器痴迷的林云少校；对物理学执着追求的丁仪教授…</p><h3 id="物理学家——六分仪">物理学家——六分仪</h3><p>在发现球状闪电是自然界的基本物质之后，另外一位主角上场了——丁仪教授（很多人叫他六分仪，因为他出现在刘慈欣多部小说中，包括三体。每部小说中都是一个物理学家的身份，只不过研究领域不同）。</p><p>他的出现是因为主角这些搞应用科学的人根本没有办法解开自然界基本物质之谜，只能请“神仙”了。</p><blockquote><p>我们只能在牛顿、爱因斯坦、麦克斯韦这些人设定的框架中进行推演，不可能越雷池半步，否则就行步入没有空气的虚空一样，但在这个框架中，我们什么也推演不出来。</p></blockquote><p>这是另一句触动我的话，我相信只要是工科或者应用科学的人都多少会被这句话触动。对于工科或者应用科学的人来说，我们确实在那些伟大的科学家制定的框架中活着，很难越过雷池，甚至是不敢越过雷池。有些羡慕那些搞理论科学的人了，至少他们有机会“天马行空”。</p><p>丁仪的出现，很快解开了球状闪电之谜，<code>球状闪电是宏电子</code>。佩服刘慈欣的想象力，不过球状闪电的一些表现出来的现象还真的可以用量子力学解释。</p><p>我觉得他的解释还是有一定道理的（我对量子力学的了解有限）。至于球状闪电究竟是什么，我也不知道呀，毕竟对于现在的物理学，球状闪电还是个迷。不过是宏电子的可能性微乎其微（如果是，刘慈欣可以再拿一个诺贝尔物理学奖啦）</p><p>看完小说之后，我都想在有生之年见一次球状闪电了。据说河北邯郸曾经出现过。</p><h3 id="危险与魅力并存的美女少校">危险与魅力并存的美女少校</h3><p>小说中另外一位主角就是林云少校了。她是国防科技大学的博士研究生，专业为防控武器系统。</p><p>这是陈博士第一次见到林云时的印象。</p><blockquote><p>雾散了一些，天上有稀疏的星星出现，这星光立刻映在她那清澈的双眸中，我出神地看着她眼中的星光，又赶紧将目光转向真正的星空。如果说我的人生是一部电影，那前面已经放映过的都是黑白色，今天，在泰山之巅，画面突然变成彩色的了。</p></blockquote><p><s>后半句是一句不错的情话。。。</s></p><p>你以为他们最后会在一起？你想多了。像林云这样的女孩，或者说想她这样的人感情不会成为他们最重要的东西，因为有一种东西已经占据了他们的方寸之地。</p><p>陈博士对丁仪的情人说过“有物理学在，谁在他（丁仪）心里都不可能是第一位的”。《球状闪电》中人物的性格还是很鲜明的。</p><p>对于林云来说，武器就是那样一种东西。</p><p>你很难想象一个女孩会痴迷于武器，会在本应该抱着洋娃娃的年纪抱着枪膛仍然发热的机枪，会把一个精致的小型地雷作为饰品挂在车前，会将一个由硅材料制成如剑般锋利的胸针戴在胸前，会偷偷研制液体地雷并出售给正在交战的两个国家。</p><p>她之所以痴迷于武器是因为她母亲。她父亲是一位将军，母亲同样是一位军人。但不幸的是她母亲在越战期间惨死于一种武器——杀人蜂。年幼的林云因此憎恨武器，不过慢慢地变成了痴迷。</p><p>林云最后为了强行进行宏聚变实验而坍缩成量子态。其实林云这个人物才像整本书的主角，因为她和球状闪电一样即危险又令人着迷。</p><h3 id="球状闪电">球状闪电</h3><p>最后说说球状闪电。</p><p>球状闪电，俗称滚地雷。通常在雷暴时发生，为圆球形状的闪电。这是一种真实的物理现象。它十分亮，近圆球形，直径约15至40厘米不等。通常仅维持数秒，但也有维持了1至2分钟的记录。颜色除常见的橙色和红色外，还有黄色、紫色、蓝色、亮白色、幽绿色的光环，呈多种多样的色彩。</p><p>球状闪电的危害较大，它可以随气流起伏在近地空中自在飘飞或逆风而行。它可以通过开着的门窗进入室内，常见的是穿过烟囱后进入建筑物。它甚至可以在导线上滑动，有时会悬停，有时会无声消失，有时又会因为碰到障碍物爆炸。</p><p>球状闪电是形成雷电的电动趋势，在半击穿空气时产生的空气离子球。它其中携带能量，包裹相对稳定。当有导体破坏它的平衡时，它会和周围的空气中和，并释放出能量。</p><p>来源：百度百科。</p><h3 id="后记">后记</h3><p>据说，刘慈欣写这本小说之前被查出疑似有癌症，于是他将《球状闪电》作为他的最后一本书来写，所以《球状闪电》的结局也比较凄美。不过，写完之后再查发现根本不是癌症。“重获新生”之后，刘慈欣开始构建三体世界。</p><h3 id="附：《未选择的路》">附：《未选择的路》</h3><center>黄色的树林里分出两条路，<br>可惜我不能同时去涉足，<br>我在那路口久久伫立，<br>我向着一条路极目望去，<br>直到它消失在丛林深处。<br>但我却选了另外一条路，<br>它荒草萋萋，十分幽寂，<br>显得更诱人、更美丽，<br>虽然在这两条小路上，<br>都很少留下旅人的足迹，<br>虽然那天清晨落叶满地，<br>两条路都未经脚印污染。<br>呵，留下一条路等改日再见！<br>但我知道路径延绵无尽头，<br>恐怕我难以再回返。<br>也许多少年后在某个地方，<br>我将轻声叹息把往事回顾，<br>一片树林里分出两条路，<br>而我选了人迹更少的一条，<br>从此决定了我一生的道路。<br></center>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;center&gt;
&lt;img src=&quot;/img/blog/blog-22-1.jpg&quot; width=800&gt;
&lt;/center&gt; --&gt;
&lt;blockquote&gt;
&lt;p&gt;考试周的时候重新看了刘慈欣的《球状闪电》，个人一直很喜欢这本书，甚至超过了《三体》。但是一直没时间为这本书写一点东西，趁机抓住国庆假期的尾巴，写写我的体会。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="阅读" scheme="https://yx1302317313.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>仙境蓬莱</title>
    <link href="https://yx1302317313.github.io/2019/10/07/%E4%BB%99%E5%A2%83%E8%93%AC%E8%8E%B1/"/>
    <id>https://yx1302317313.github.io/2019/10/07/仙境蓬莱/</id>
    <published>2019-10-07T06:42:11.000Z</published>
    <updated>2020-02-21T03:56:51.616Z</updated>
    
    <content type="html"><![CDATA[<p>蓬莱市为山东省烟台市的一个县级市，位于渤海和黄海的交界之处。“八仙过海”的神话传说，便发生在这里。中国四大名楼之一的蓬莱阁也坐落在这里。</p><a id="more"></a><p><strong>多图预警，小心流量</strong></p><center><img src="/img/blog/blog-26-penglai1.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai2.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai3.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai4.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai5.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai6.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai7.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai8.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai9.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai10.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai11.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai12.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai13.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai14.jpg" width="500"></center><br><center><img src="/img/blog/blog-26-penglai15.jpg" width="500"></center><br><p>有没有感觉不对劲？</p><p>对，为什么有知乎的水印。当然是因为照片不是我拍的啦。</p><p>好吧，其实我没有照片，<strong>但我真真真真真的去了蓬莱</strong>，不过因为某些原因拍的照片没了。</p><p>原因就是你——<strong>华为手机</strong>。</p><p><em>你为什么在删除云端相册的时候会把本地相册也删了？</em></p><p><em>你为什么不提醒我？</em></p><p><em>你为什么要做这么鸡肋的一个云相册？</em></p><p><em>我为什么没备份？</em></p><p><em>我为什么要删除云相册？</em></p><p><em>我为什么还要清空回收站？</em></p><p><strong>一定注意：华为手机在删除云相册的时候本地相册也会被删除</strong></p><p>其他感受等心情好了再说…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;蓬莱市为山东省烟台市的一个县级市，位于渤海和黄海的交界之处。“八仙过海”的神话传说，便发生在这里。中国四大名楼之一的蓬莱阁也坐落在这里。&lt;/p&gt;
    
    </summary>
    
      <category term="远方" scheme="https://yx1302317313.github.io/categories/%E8%BF%9C%E6%96%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>自控力</title>
    <link href="https://yx1302317313.github.io/2019/10/07/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    <id>https://yx1302317313.github.io/2019/10/07/自控力/</id>
    <published>2019-10-07T06:41:43.000Z</published>
    <updated>2019-10-07T06:42:56.523Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="自控力" scheme="https://yx1302317313.github.io/categories/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>Shadowsocks网络代理</title>
    <link href="https://yx1302317313.github.io/2019/09/17/Shadowsocks%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"/>
    <id>https://yx1302317313.github.io/2019/09/17/Shadowsocks网络代理/</id>
    <published>2019-09-17T04:41:18.000Z</published>
    <updated>2019-11-09T14:45:40.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>昨天,在2019年网络安全周的第一天,搭建不到一个月的国外VPS被封了…特来记录一下最近的搭建过程.</p></blockquote><a id="more"></a><h2 id="前言">前言</h2><p>昨天荷兰和西雅图的VPS都被封了.期间还用traceroute(之后会介绍)分析了半天节点也没找到问题. 之后才知道是网络安全周. 据说, 网络安全周是特殊情况,之后可能会被解封.  <strong>Waiting…</strong></p><p>再说使用国外VPS会不会被请去喝茶的问题. 只要是 <strong>正常访问</strong> Facebook,Google,YouTube之类的都没什么问题. 不过具体的我也不清楚,想知道请查阅国家法律或者咨询法律人士. 但是如果自己搭建网络代理然后出售VPN一类的东西好像是违法的,网上也有一些案例. 自己搭个服务器自己玩就行了,不要去碰这种生意. 还有也不要浏览什么政治敏感话题,更不要在这些方面发表不适合的言论.</p><h2 id="国外VPS购买">国外VPS购买</h2><p>提供国外VPS的公司有很多, 比如Vultr, DigitalOcean, hostwinds等等.我用的是<a href="https://clients.hostwinds.com" target="_blank" rel="noopener">hostwinds</a>, 因为hostwinds相对比较便宜, 最低配版一个月$4.49元. 不过大部分价格差不多,每个月5美元左右. 有的也提供一些更便宜的服务器, 比如3美元左右, 但是现在基本已经售空了, 一般很难抢到. 如果你发现了一定要快点下手, 并且通过邮箱通知我一下. 哈哈…</p><p>对于服务器配置, 如果只是自己搭建Shadowsocks, 搭建个人博客, 做FTP, 做图床等等, 最低配就够用了.</p><p>下图是某网站发布的2019国外VPS服务商排行, 可以参考一下, 然后根据自己的需求选择即可.</p><center><img src="/img/blog/blog-20-1.png"></center><h2 id="Shadowsocks服务端搭建">Shadowsocks服务端搭建</h2><p>买完服务器之后就可以开始Shadowsocks服务器的搭建了.</p><p>通过ssh远程登录服务器 <s>(既然都准备自己搭建服务器了, 这个应该都会吧)</s>. 可以先对服务器配置一下, 再开始.</p><ul><li>创建个普通用户, 尽量少用root用户.</li><li>换换终端, 强烈推荐zsh, 让终端操作更加丝滑.</li><li>…</li></ul><p>好了, 正式开始!</p><ol><li>服务器上安装Shadowsocks, 下面是一个一键安装脚本. 在终端运行下面的命令</li></ol><pre><code class="language-sh">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</code></pre><ol start="2"><li><p>运行之后需要选择一些选项</p><ul><li>选择ss服务端的版本, 有Python, R, 和Go等等, 我选择的是Go.</li><li>输入密码: 输入自己想要设定的密码.</li><li>输入端口: 回车默认.</li><li>输入加密方式: 同样选默认, 回车.</li></ul></li><li><p>按任意健开始, 或者按Ctrl + C 取消. 当然是开始了.</p></li><li><p>等待安装完成. 然后将ip, 端口等信息截图保存一下.</p></li><li><p>完成, Enjoy it!</p></li></ol><p><strong>[注意]</strong>: 密码,端口和加密方式需要记住, 因为配置客户端时要用. 安装完成后会显示这些信息, 到时候截个图就可以. 同时会生成一个二维码, 可以使用手机扫描, 或者使用电脑读取二维码配置客户端. 至于怎么把二维码从服务器下载下来… 可以利用vsftpd搭一个FTP服务器, 然后下载. 不过这里使用手动配置.</p><p>完成之后可以看一下ss服务是否启动</p><pre><code class="language-sh">$ systemctl list-units --type=service | grep Shadowsocks</code></pre><p>如果看到有Shadowsocks服务, 并且状态是active和running, 则服务已经启动. 服务端配置就完成了.</p><h2 id="Shadowsocks客户端">Shadowsocks客户端</h2><p>在Github上有各个平台的Shadowsocks客户端. <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">Shadowsocks</a></p><h3 id="Android">Android</h3><p>国内的应用商店肯定是没有shadowsocks应用的, 直接下github上的apk安装包安装即可.<s>(不过墙内好像下载速度极慢)</s>.</p><p>打开Android端Shadowsocks.</p><center><img src="/img/blog/blog-21-1.jpg" height="500"></center><p>点击右上角的添加图标, 选择手动设置.</p><center><img src="/img/blog/blog-21-2.jpg" height="500"></center><p>现在就用到之前保留的截图了, 按照服务器的配置信息依次设置服务器IP, 服务器端口, 密码, 以及加密方式.</p><p><strong>[注意]</strong>: 最下面的路由选择 <strong>绕过局域网及中国大陆地址</strong> , 这样访问局域网的网址和大陆网址时不使用代理. 你访问国内网站, 总不想绕大半个地球到欧洲或者北美再回来吧.</p><p>还有, 国内某些网站是不对国外的IP提供服务的, 比如网易云音乐, 如果使用国外的IP访问, 不能播放音乐, 更不能下载了.</p><center><img src="/img/blog/blog-21-3.jpg" height="500"></center><h3 id="Windows">Windows</h3><p>Windows安装之后, 打开应用之后会直接显示在底栏的右下角. 右键进行手动配置, 基本同Android端配置一样.</p><p>同样, 为了访问局域网的网址和大陆网址时不使用代理, 也需要进行相应的配置, 在右键菜单中找到系统代理这一项, 将默认的全局模式改为PAC模式.</p><p>由于电脑上没有Windows系统, 就不截图了. Windows具体配置见<a href="https://github.com/Shadowsocks-Wiki/shadowsocks/blob/master/2-windows-setup-guide-cn.md" target="_blank" rel="noopener">Windows Shadowsocks配置</a>.</p><h3 id="Linux">Linux</h3><blockquote><p>Linux当然是最&quot;麻烦&quot;的了.</p></blockquote><p>我的Linux发行版是Ubuntu18，不同发行版之间操作可能不同。</p><h4 id="全局代理">全局代理</h4><ol><li><p>打开设置-&gt;网络-&gt;网络代理</p></li><li><p>选择网络代理中的手动代理，再选择sockts主机为本地IP地址：172.0.0.1，端口为1080。具体设置见下图</p></li></ol><center><img src="/img/blog/blog-21-7.png"></center><h5 id="终端的全局代理">终端的全局代理</h5><p>在shell的配置文件(.bashrc、.zshrc等等)中添加下面内容</p><pre><code class="language-sh">export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot;</code></pre><p><strong>目前还没有找到终端使用PAC代理的方法，我在终端使用的还是全局代理。。。</strong></p><h4 id="PAC代理">PAC代理</h4><blockquote><p>PAC，一个自动代理配置脚本，包含了很多使用 JavaScript 编写的规则，它能够决定网络流量走默认通道还是代理服务器通道，控制的流量类型包括：HTTP、HTTPS 和 FTP。</p></blockquote><h5 id="系统的PAC代理">系统的PAC代理</h5><ul><li>安装pip（很多人可能已经装了）</li></ul><pre><code class="language-sh">sudo apt-get install python-pip python-dev build-essential sudo pip install --upgrade pip sudo pip install --upgrade virtualenv</code></pre><ul><li>安装genpac</li></ul><pre><code class="language-sh">sudo pip install genpac</code></pre><ul><li>建立一个存放pac文件的目录，进入该目录。（注意，在执行时需挂系统代理 sock5，否则会出现获取 gfwlist 失败的情况）</li></ul><pre><code class="language-sh">genpac --proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; -o autoproxy.pac --gfwlist-url=&quot;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; </code></pre><ul><li>选择网络代理中的自动代理，url 填写刚生成的 pac 文件的路径file:///path/autoproxy.pac (# 这个文件是一个JS脚本文件，里面存放着目前大部分被gfw屏蔽的域名)，<strong>如果有需要添加的域名，可以自己手动添加进去。</strong></li></ul><h5 id="Chrome的PAC代理">Chrome的PAC代理</h5><ol><li>安装chrome插件SwitchyOmega</li><li>打开SwitchyOmega配置</li><li>新建情景模式，选择PAC情景模式</li><li>在PAC脚本内复制下载的PAC文件的内容，也可以通过填写PAC网址从网站下载PAC文件。</li><li>选择SwitchyOmega的模式是刚刚新建的情景模式。</li></ol><h5 id="Firefox的PAC代理">Firefox的PAC代理</h5><ol><li>打开：设置 -&gt;首选项 -&gt;常规 -&gt;最下方的网络设置。</li><li>点击设置-&gt; 选择自动代理配置URL（PAC）</li><li>填写下载的PAC文件的路径，例如： file:///path/autoproxy.pac</li><li>确认</li></ol><h2 id="traceroute分析">traceroute分析</h2><blockquote><p>说说traceroute, 这是一个Linux命令(在Windows下相应命令为tracert). 它的作用就是跟踪消息在网络核心之间的传输, 也就是在各个路由器之间的传输. 通过这个命令我们可以看到网络传输中的时延和丢包现象.</p></blockquote><h3 id="原理">原理</h3><p>traceroute主要使用了IP头部生存时间(time to live, TTL), TTL值在每经过一个路由之后会减去1, 当TTL值为0时, 路由器认为发送超时, 将报文丢弃并向源主机发送ICMP超时差错报文. 报文中包含了路由器的IP.</p><p>利用TTL的这种工作原理, traceroute可以依次得到每一个路由器的IP地址.</p><ul><li>源主机将TTL值设置为1发送报文, 在报文到达第一个路由器时, $TTL - 1 = 0$, 于是路由器认为超时, 发送一份ICMP超时差错报文给源主机, 得到第一个路由器的IP.</li><li>源主机再将TTL值设置为2发送报文, 同理得到第二个路由器的IP地址.</li><li>…</li><li>当报文到达目的主机时, 由于traceroute通过UDP数据包向不常见端口发送数据包，因此会收到目的主机ICMP port unreachable消息，故可判断到达目的地。</li><li>停止发送报文.</li></ul><p>通过上述方法可以得到从源主机到目的主机过程中各个路由器的IP地址, 由于源主机收到路由器或者目的主机的消息所用的时间是从源主机到路由器或者目的主机的2倍, 可以简单的将这个时间除以2得到从源主机到路由器或者目的主机的时间. 通过这个时间我们可以分析传输时延和丢包现象.</p><h3 id="分析">分析</h3><p>这是traceroute访问百度的过程, 其中*表示丢包.</p><center><img src="/img/blog/blog-21-4.png" width="800"></center><p>访问cnn, 其中202.97.50.54是电信主干网, 之后的一个IP 38.104.138.105就已经到了美国了.</p><center><img src="/img/blog/blog-21-5.png" width="800"></center><p>再看youtube, 在电信主干网就挂掉了, 连走出国门的机会都没有(-_-).</p><center><img src="/img/blog/blog-21-6.png" width="800"></center>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;昨天,在2019年网络安全周的第一天,搭建不到一个月的国外VPS被封了…特来记录一下最近的搭建过程.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://yx1302317313.github.io/categories/Linux/"/>
    
    
      <category term="网络代理" scheme="https://yx1302317313.github.io/tags/%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"/>
    
      <category term="shadowsocks" scheme="https://yx1302317313.github.io/tags/shadowsocks/"/>
    
      <category term="Network" scheme="https://yx1302317313.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>天津之行</title>
    <link href="https://yx1302317313.github.io/2019/08/31/%E5%A4%A9%E6%B4%A5%E4%B9%8B%E8%A1%8C/"/>
    <id>https://yx1302317313.github.io/2019/08/31/天津之行/</id>
    <published>2019-08-31T02:54:25.000Z</published>
    <updated>2019-09-07T04:13:47.625Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实很多人都希望一场旅行,去追寻自己心中的诗与远方.可能由于时间问题,经济问题等,只能一次次的打消念头.如果你真的下定决心去尝试一次,你会发现之前的那些问题并不会阻碍你.很幸运,我迈出了这一步.</p></blockquote><center><img src="/img/blog/blog-19-1.jpg" width="500"></center><a id="more"></a><h3 id="Why">Why</h3><h4 id="为什么想要一次旅行">为什么想要一次旅行</h4><blockquote><p>当然,很久之前就想要来一次旅行,只不过由于开篇提到的问题很多次打消了念头.</p></blockquote><blockquote><p>让我下定决心的是想要放空自己.最近几场比赛都已结束了,感觉自己的大学也快要结束了 <s>(其实真的快结束啦)</s>, 而自己对于之后的&quot;何去何从&quot;还没有想清楚,说到底是没有想清楚自己想要的究竟是什么,是浪潮之巅,是诗与远方,亦或是其他的什么.</p></blockquote><blockquote><p>而当时又不愿去想,于是决定来一次旅行,放空自己,然后想一想这个哲学问题 – <strong>我要到哪里去?</strong></p></blockquote><div align="center"><audio controls><source src="/music/贝加尔湖畔.mp3"></audio><p>贝加尔湖畔-李健</p></div><h4 id="为什么是天津">为什么是天津</h4><blockquote><p>这个问题好像很好回答,因为贫穷,哈哈!</p></blockquote><blockquote><p>某一天,忽然发现了一个问题. 从家到学校(或者学校到家),如果换不同的换乘方案,我可以经过很多城市,北京,天津,济南,青岛… 途中在这些城市玩几天可以节省旅行的路费 <s>(真的是因为贫穷)</s>.</p></blockquote><blockquote><p>北京消费有点高 <s>(再一次的贫穷)</s>,而且个人感觉北京的人太多了,所以就放弃了北京.至于天津,自己一直对这个城市有一种希冀,可能之前想过以后在天津定居吧.不过这次旅行真的让我喜欢上了这个城市.</p></blockquote><h3 id="准备">准备</h3><blockquote><p>原本准备从学校回家的途中在天津停留几天,并且制定了一份比较详细的计划.但是由于某些原因,改到了从家到学校的途中.</p></blockquote><blockquote><p>第一次自己如此详细的准备一份出行计划,以前如果有其他人一起,自己就懒得计划了.其实最主要的问题就是规划各个景点的游览顺序和交通方式,想要在一定的时间内游览更多的地方. (不知不觉抽象成了一道优化问题 <sup>-</sup>). 早知道在数据结构实验的时候就做景点之间的路径规划了.</p></blockquote><h4 id="我的计划">我的计划</h4><table><thead><tr><th>日期</th><th>起点</th><th>终点</th><th>方式</th><th>时长</th></tr></thead><tbody><tr><td>8.29</td><td>天津西</td><td>古文化街</td><td>公交</td><td>0：7</td></tr><tr><td>8.29</td><td>古文化街</td><td>意风区</td><td>步行， 骑行</td><td>0：21， 0：10</td></tr><tr><td>8.29</td><td>意风区</td><td>天津之眼</td><td>公交， 骑行</td><td>0：34， 0：14</td></tr><tr><td>8.30</td><td>天津之眼</td><td>天大</td><td>公交</td><td>0：38</td></tr><tr><td>8.30</td><td>天大， 南开</td><td>河北工业大学</td><td></td><td></td></tr><tr><td>8.30</td><td>天大</td><td>滨海图书馆</td><td>公交</td><td>1：45</td></tr></tbody></table><br><blockquote><p>最终并没有完全按照计划进行,毕竟计划是赶不上变化的.但计划中的地方都去了,所以计划也没有白做.</p></blockquote><!--more### 青年旅社>  第一次尝试青年旅社，之前也想过住青年旅社，不过总觉得这样的地方不正规，不安全。经过这次的体验，改变了我的看法。--><h3 id="天津之眼">天津之眼</h3><blockquote><p>第一天到天津已经是傍晚了,所以直接去了天津之眼（晚上是去天津之眼的绝佳时间）。</p></blockquote><blockquote><p>建在桥上的摩天轮还是很壮观的，也难怪会成为天津的名片，我个人比较喜欢建筑，每次见到这些建筑都有一种敬畏之感。（高考报志愿也曾考虑过建筑学，至于为什么没报…）</p></blockquote><blockquote><p>本来想上摩天轮上的，直径110米的摩天轮在最高点，确实能将两岸的景色尽收眼底。不过时间问题，过去已经停止售票了，有一点遗憾，但是之后听到曾经发生过一次没关舱门的事件(&gt;_&lt;)，这一点遗憾就荡然无存了。</p></blockquote><blockquote><p>如果只有一个摩天轮，这个地方也没有那么大的吸引力。我感觉相比天津之眼，它所在的海河两岸的风景才是天津一张特殊的名片，天津之眼只是海河的锦上添花。</p></blockquote><blockquote><p>到了天津之后才知道天津居然从海河这条“母亲河”发源的，乘船在海河游览一遍才能真正感觉到天津之美。</p></blockquote><blockquote><p>现在很多城市随着城市的现代化都已经失去了自己的特点。车水马龙中，见到的只是灯红酒绿，高楼大厦。漫步于城市中，某一瞬间可能真的不知自己身在何处。</p></blockquote><blockquote><p>不过天津让我看到了她的独特之处，乘船穿过一座座桥梁，每一座桥都有自己独特的风韵，有着自己的“故事”。而两岸是各种近代和现代建筑，你可以见到袁世凯的总统府，周总理与邓颖超的纪念馆，纪念弘一法师（李叔同）的大悲禅院…</p></blockquote><blockquote><p>天津有很多名人故居，少帅张学良的府邸，张伯苓先生的故居等等，所以天津确实是一个适合定居的地方。</p></blockquote><blockquote><p>同样，你也可以经过天津的很多租界，意租界，英租界，法租界，奥租界等等，天津是中国保留租界最多的城市，其中的意租界最有名，是意大利在国外保留最大的租界。</p></blockquote><blockquote><p>所以天津是一个古今，中外文化融合的城市，有着自己风格。</p></blockquote><blockquote><p>感受天津独特之美的最好方式一定是沿着海河游览，或步行，或骑车，亦或乘船。</p></blockquote><center><img src="/img/blog/blog-19-2.jpg" width="500"></center><br><center><img src="/img/blog/blog-19-3.jpg" width="500"></center><br><center><img src="/img/blog/blog-19-4.jpg" width="500"></center><br><center><img src="/img/blog/blog-19-5.jpg" width="500"></center><br><h3 id="古文化街">古文化街</h3><blockquote><p>按照计划，来到了古文化街。古文化街这个名字对于我来说就够有吸引力了，从小印象中的天津就是一个极具中国传统文化的地方，有着很多奇人异事，泥人张，刷子李等等。</p></blockquote><center><img src="/img/blog/blog-19-6.jpg" width="500"><p>传说中的泥人张</p></center><br><center><img src="/img/blog/blog-19-7.jpg" width="500"><p>达摩祖师</p></center><p>当然还有天津有名的狗不理，据说太贵，卑微的我只能在门外逗留一会儿。</p><center><img src="/img/blog/blog-19-8.jpg" width="500"></center><blockquote><p>之后就遇到了相声大会正好开始，本来没打算进去，但是转念一想，来天津总要体验一下天津相声。不过听相声最好多带个人一起去，或者一个人不要点茶，否则你喝不完那壶茶 <s>(一个半小时一直喝，也就喝了不到半壶)</s></p></blockquote><center><img src="/img/blog/blog-19-9.jpg" width="500"></center><br><center><img src="/img/blog/blog-19-10.jpg" width="500"><p>那壶万恶的茶...</p></center><h3 id="意风区">意风区</h3><blockquote><p>下午和某个人来到了意风区，不是自己想象中的那样，这里主要是当时的意大利租界，保留了租界的建筑，然后最多的就是酒吧和咖啡馆了。</p></blockquote><center><img src="/img/blog/blog-19-11.jpg" width="500"><p>马可波罗像</p></center><br><center><img src="/img/blog/blog-19-21.jpg" width="500"><p>酒吧中唱歌的小姐姐</p></center><blockquote><p>之后喝了人生中的第一杯鸡尾酒，感觉还算不错，除了贵…不过积累了一个经验——鸡尾酒不要点看起来比较绿的，哈哈！</p></blockquote><center><img src="/img/blog/blog-19-12.jpg" width="500"></center><h3 id="南天门">南天门</h3><blockquote><p>依然是按计划，第二天上午去了天大和南开，见到了传说中的“南天门”，真的天大和南开之间只是一门之隔，出了天大还没感觉就进了南开。</p></blockquote><h4 id="天大">天大</h4><p>羡慕一下天大的食堂</p><center><img src="/img/blog/blog-19-13.jpg" width="500"></center><p>天大应该是中国最早的大学了。</p><center><img src="/img/blog/blog-19-14.jpg" width="500"></center><h4 id="南开">南开</h4><blockquote><p>对于南开的印象应该主要是两个人，张伯苓先生——中国近代一位伟大的教育家，也是南开的创始人（好像还是西南联大的校长）；还有一位是被张伯苓先生称为南开最优秀的学生——周恩来总理。</p></blockquote><center><img src="/img/blog/blog-19-15.jpg" width="500"><p>南开主楼（感觉还是哈工大主楼好看）</p></center><p>今年是南开的百年校庆，下图是校庆的吉祥物，有点可爱(<sup>_</sup>)。</p><center><img src="/img/blog/blog-19-16.jpg" width="500"><p>南开百年校庆吉祥物</p></center><h3 id="传说中的网红图书馆">传说中的网红图书馆</h3><blockquote><p>在南开的时候已经有点玩不动了，于是决定休息一下，坐地铁去滨海新区。。。</p></blockquote><blockquote><p>之前是打算去滨海传说中的网红图书馆的，但是由于离市区太远了，一直犹豫去还是不去，不过现在有理由了。</p></blockquote><blockquote><p>出门一直用百度地图，不过百度地图你能不能好好搞一下立体空间导航，找了半天滨海图书馆在哪，结果是它在我上面。。。</p></blockquote><blockquote><p>想去滨海图书馆，主要是因为它的建筑风格很独特，真的很像梯田（怀疑这位欧洲的设计师去过云南）。</p></blockquote><center><img src="/img/blog/blog-19-17.jpg" width="500"></center><br><center><img src="/img/blog/blog-19-18.jpg" width="500"></center><blockquote><p>确实像网上说的那样，高处的书是假的，只是画在了书架上。可能是因为书不够，这个好处理。不过我想知道天花板上的书要怎么取？</p></blockquote><center><img src="/img/blog/blog-19-19.jpg" width="500"></center><blockquote><p>成功通过图书馆的管理系统找到了最近正在看的书——《白说》，在图书馆里面看了一章，体验很好。</p></blockquote><center><img src="/img/blog/blog-19-20.jpg" width="500"></center><h3 id="体会">体会</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实很多人都希望一场旅行,去追寻自己心中的诗与远方.可能由于时间问题,经济问题等,只能一次次的打消念头.如果你真的下定决心去尝试一次,你会发现之前的那些问题并不会阻碍你.很幸运,我迈出了这一步.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;
&lt;img src=&quot;/img/blog/blog-19-1.jpg&quot; width=&quot;500&quot;&gt;
&lt;/center&gt;
    
    </summary>
    
      <category term="远方" scheme="https://yx1302317313.github.io/categories/%E8%BF%9C%E6%96%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>何去何从</title>
    <link href="https://yx1302317313.github.io/2019/07/29/%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E/"/>
    <id>https://yx1302317313.github.io/2019/07/29/何去何从/</id>
    <published>2019-07-29T15:48:42.000Z</published>
    <updated>2019-07-29T16:04:32.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>迷宫生成算法</title>
    <link href="https://yx1302317313.github.io/2019/06/24/%E8%BF%B7%E5%AE%AB%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
    <id>https://yx1302317313.github.io/2019/06/24/迷宫生成算法/</id>
    <published>2019-06-24T11:28:38.000Z</published>
    <updated>2020-03-05T13:12:56.389Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近做课设时,有一个部分需要用到迷宫的生成算法. 在这里介绍一种使用深度优先搜索生成迷宫的算法.</p></blockquote><a id="more"></a><center><audio controls><source src="/music/年少有为-李荣浩.mp3"></audio><p>年少有为-李荣浩</p></center><h3 id="最终的效果">最终的效果</h3><p>先上几张效果图，图中绿色的表示障碍，灰色表示道路(<s>我的世界既视感</s>).</p><br><center><img src="/img/blog/blog-18-1.png" width="500"></center><br><center><img src="/img/blog/blog-18-2.png" width="500"></center><br><center><img src="/img/blog/blog-18-3.png" width="500"></center><h3 id="如何描述迷宫">如何描述迷宫</h3><p>迷宫其实就是一个复杂的地形图,在这个地形中有基本的障碍和通道,当然也可以有其他元素。</p><p>我们这里用最简单的方式描述迷宫——矩阵。迷宫中的地形也只有障碍和通道两种元素。可以用0和1表示这两种元素。</p><p>因此我们用一个存储着0和1,M*N大小的矩阵就可以描述迷宫啦!</p><h3 id="迷宫的特点">迷宫的特点</h3><ol><li>从设定的起点到终点必须是连通的(<s>否则,还能不能好好玩耍了</s>)</li><li>从起点到终点只有一条通路.(其实也可以有多条,根据实际需要设定)</li></ol><h3 id="思路">思路</h3><p>从迷宫特点的描述有没有想到什么?</p><p>迷宫就是一个图,要求任意设定的起点和终点之间是连通的,就是一个 <strong>全连通图</strong>.但是如果这个图的连通度太高,迷宫就没有难度了,所以我们要求图中任意顶点之间只有一条路.</p><p>什么样的图只有一条路, <strong>无环图</strong>.</p><p>所以我们需要的是无环的连通图,这是什么? <strong>树</strong></p><p>我们的迷宫就是一个树,因此迷宫的生成算法就是树的生成算法,树的生成算法有深度优先遍历和广度优先遍历, 在这里使用深度优先.</p><h3 id="迷宫的生成过程">迷宫的生成过程</h3><h4 id="1-初始状态">1 初始状态</h4><blockquote><p>图中绿色的表示障碍，灰色表示道路(空白)</p></blockquote><center><img src="/img/blog/blog-18-4.png" width="500"></center><p>由于迷宫四周都是障碍, 图的宽和高都必须是奇数.</p><h4 id="2-迷宫的生成">2 迷宫的生成</h4><p>1 任意选择一个空白块, 将该空白块作为树的根结点.</p><p>2 从根节点出发隔一个元素块查找四周(上,下,左,右,四个方向,不包括对角线方向)其他的空白块.</p><center><img src="/img/blog/blog-18-5.png" width="500"><p>从该结点出发,四周只有两个空白块</p></center><center><img src="/img/blog/blog-18-6.png" width="500"><p>从该结点出发,四周有四个空白块</p></center><p>3 随机选取其中一个空白块, 将道路沿该方向拓展, 即把夹在这两个空白块之间的障碍块去掉, 改成空白块.</p><center><img src="/img/blog/blog-18-7.png" width="500"><p>把夹在这两个空白块之间的障碍块去掉</p></center><p>4 更新当前结点, 然后从当前结点出发,重复步骤2,3.</p><p>5 当遇到一个结点周围没有空白块时, 即没有可拓展道路的方向时, 回退并更新当前结点, 直至当前结点四周有空白块, 重复步骤2,3.</p><center><img src="/img/blog/blog-18-8.png" width="500"><p>该结点周围没有空白块</p></center><p>6 当回退到根节点没有任何可以拓展的道路时, 算法结束, 迷宫也就生成了.</p><center><img src="/img/blog/blog-18-1.png" width="500"></center><h4 id="3-设定起点和终点">3 设定起点和终点</h4><p>选取迷宫中的两个空白块作为迷宫的起点和终点,一个完整的迷宫就诞生了.</p><h3 id="核心算法–深度优先">核心算法–深度优先</h3><blockquote><p>由于这部分算法是程序的一部分,不能完整运行,仅供参考.</p></blockquote><blockquote><p>在程序中用到了Qt中的容器QVector,可以用STL中的std::vector代替; 用到的qsrand()和qrand()生成随机数,可以使用C标准库中的srand()和rand()函数代替.</p></blockquote><pre><code class="language-cpp">/*@ 生成迷宫*/void GenerateMaze::Maze(int width, int height){    //初始化矩阵, 申请内存    maze_matrix_ = new int*[height];    for(int i=0; i&lt;height; i++)    {        maze_matrix_[i] = new int[width];    }    for(int i=0; i&lt;height; i++)    {        for(int j=0; j&lt;width;j++)        {            if(i % 2 == 0 || j % 2==0)            {                maze_matrix_[i][j] = 1;  //障碍            }            else            {                maze_matrix_[i][j] = 0;  //道路(空白)            }        }    }    qsrand(QTime(0,0,0).secsTo(QTime::currentTime())); //设置随机数种子    maze_matrix_[1][1] = 2; //选取(1,1)作为根节点, 并将根节点的状态设置成2    this-&gt;generateMaze(1, 1);   //深度优先遍历    for(int i=0; i&lt;height; i++)    {        for(int j=0; j&lt;width;j++)        {            if(maze_matrix_[i][j] == 2)            {                maze_matrix_[i][j] = 0; //将状态为2的结点重新设置为0, 表示可通行道路            }        }    }}/*@ brief:深度优先生成迷宫(递归实现)*/void Maze::generateMaze(int pos_i, int pos_j){    //到达边界, 返回    if(pos_j &lt; 0 || pos_j &gt;= width || pos_i &lt; 0 || pos_i &gt;= height)    {        return;    }    QVector&lt;int&gt; vec = existedRoad((const int**)maze_matrix_, pos_i, pos_j); //查找当前结点四周空白块    //四周没有空白块, 返回    if(vec.size() == 0)    {        return;    }    for(int i=0; i &lt; vec.size();)    {        int index = qrand()%vec.size(); //随机选择其中一个空白块        switch(vec[index])        {        case D_LEFT:    //左            if(maze_matrix_[pos_i][pos_j-2] != 2)            {                maze_matrix_[pos_i][pos_j-1] = 2;    //将走过的路径设为2, 防止重复经过                maze_matrix_[pos_i][pos_j-2] = 2;                this-&gt;generateMaze(pos_i, pos_j-2); //更新结点, 递归            }            break;        case D_RIGHT:   //右            if(maze_matrix_[pos_i][pos_j+2] != 2)            {                maze_matrix_[pos_i][pos_j+1] = 2;                maze_matrix_[pos_i][pos_j+2] = 2;                this-&gt;generateMaze(pos_i, pos_j+2); //更新结点, 递归            }            break;          case D_UP:  //上            if(maze_matrix_[pos_i-2][pos_j] != 2)            {                maze_matrix_[pos_i-1][pos_j] = 2;                maze_matrix_[pos_i-2][pos_j] = 2;                this-&gt;generateMaze(pos_i-2, pos_j); //更新结点, 递归            }            break;        case D_DOWN:    //下            if(maze_matrix_[pos_i+2][pos_j] != 2)            {                maze_matrix_[pos_i+1][pos_j] = 2;                maze_matrix_[pos_i+2][pos_j] = 2;                this-&gt;generateMaze(pos_i+2, pos_j); //更新结点, 递归            }            break;        }        vec.remove(index);  //清空vec    }}/*@brief: 查找结点周围的空白块*/const QVector&lt;int&gt; Maze::existedRoad(const int **mat, int i, int j){    QVector&lt;int&gt; vec;    if(j-2 &gt;= 0 &amp;&amp; mat[i][j-2] == 0)    {        vec.push_back(D_LEFT);  //左边有空白块    }    if(j+2 &lt; width &amp;&amp; mat[i][j+2] == 0)    {        vec.push_back(D_RIGHT); //右边有空白块    }    if(i-2 &gt;= 0 &amp;&amp; mat[i-2][j] == 0)    {        vec.push_back(D_UP);    //上边有空白块    }    if(i+2 &lt; height &amp;&amp; mat[i+2][j] == 0)    {        vec.push_back(D_DOWN);  //下边有空白块    }    return vec;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近做课设时,有一个部分需要用到迷宫的生成算法. 在这里介绍一种使用深度优先搜索生成迷宫的算法.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="游戏" scheme="https://yx1302317313.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Qt" scheme="https://yx1302317313.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>回溯法的多米诺性质</title>
    <link href="https://yx1302317313.github.io/2019/05/05/%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%80%A7%E8%B4%A8/"/>
    <id>https://yx1302317313.github.io/2019/05/05/回溯法中的多米诺性质/</id>
    <published>2019-05-05T03:32:37.000Z</published>
    <updated>2020-03-05T14:53:23.860Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在复习算法, <s>没办法,要考试啦</s>. 在复习回溯法的时候终于理解了之前不是很清楚的多米诺性质.</p></blockquote><a id="more"></a><div align="center"><audio controls><source src="/music/情深深雨蒙蒙-张杰.mp3"></audio><p>情深深雨蒙蒙-张杰</p></div><h3 id="1-回溯法">1 回溯法</h3><p>由于这篇博客主要讲解多米诺性质, 默认大家已经了解回溯法啦,这里对回溯法的具体内容就不进行讲解了,<s>其实是太懒不想写</s>.</p><p>回溯法是一个很实用的算法,适合求解搜索问题和优化问题.你也可以将它看做是蛮力法(枚举法)的改进.</p><p>但不是什么情况下都可以使用回溯法, 那么就要问了,回溯法的适用条件是什么? 这就是今天的主角: <strong>多米诺性质</strong></p><h3 id="2-多米诺性质">2 多米诺性质</h3><p>先不看多米诺性质是什么,在了解了回溯法的基本思想后,我们可以总结一下什么情况下可以使用回溯法.</p><h4 id="2-1-回溯法的基本思想">2.1 回溯法的基本思想</h4><blockquote><p>将待求解问题看做一个解空间树, 问题的解可以表示为$X= (x_1, x_2, …, x_n )$.然后利用深度优先搜索逐步确定每一个解$x_i$, 当搜索到树的叶子结点时, 就得到问题的一个解$X_i$.当然这个解不一定是最优解,在将整个解空间树搜索完之后,通比较得到的每个$X_i$,便可以得到最优解.</p></blockquote><p>其实上面的思想是枚举搜索的思想,并不是回溯法.但是加上下面这一部分就成了回溯法了. <strong>下面这一部分是回溯法的核心</strong></p><blockquote><p>在搜索的过程中, 问题的解$X$需要满足约束条件$P(X)$.在搜索到一个结点的时候发现当前结点不满足约束条件,则放弃向下搜索,即不再搜索该结点的子结点, 而是回溯到上一个结点继续搜索.</p></blockquote><p>由于在搜索过程中,放弃了一些没有必要搜索的结点,整个算法的效率就提高了.</p><p><strong>为什么能够放弃? that is the question.</strong></p><p>如果当前结点不满足约束条件,能够推导出它的子结点也不满足约束条件,那么就可以放弃搜索它的子结点.其实这就是多米诺性质.</p><h4 id="2-2-多米诺性质的定义">2.2 多米诺性质的定义</h4><blockquote><p>设$X = (x_1, x_2, …, x_n )$是问题的解,$X_i= (x_1, x_2, …, x_i), X_{i+1} = (x_1, x_2, …, x_i, x_{i+1}), X_i, X_{i+1} \subseteq X$.$X_{i}和X_{i+1}$ 分别是搜索到第i层和第i+1层的解.如果 $P(X_{i+1}) \rightarrow P(X_i)$ , 即 $P(X_{i+1})$ 蕴含 $P(X_i)$, 则称该问题满足多米诺性质.</p></blockquote><p>是不是很难理解?<s>数学是个好东西,表达简洁优雅,没有二义性,但是太难理解.</s></p><p>其实上面定义的意思是: 如果子结点满足约束条件能够推导出其父结点满足约束条件,那么就满足多米诺性质.</p><p>为什么感觉和之前说的不太一样? 对比一下</p><ul><li>如果当前结点不满足约束条件,能够推导出它的子结点也不满足约束条件.</li><li>如果子结点满足约束条件能够推导出其父结点满足约束条件.</li></ul><p>你会发现其实这两个命题互为逆否命题,也就是这两个命题说的是同一件事.下面给出证明.(涉及一点数理逻辑的知识,但是逻辑很简单)</p><p><strong>[证明]</strong>:$$\begin{aligned}&amp; 如果问题满足多米诺性质, 则有P(X_{i+1}) \rightarrow P(X_i)\\&amp; 有逆否命题 \neg P(X_{i}) \rightarrow \neg P(X_{i+1}) 成立\\&amp; 在当前结点不满足约束条件时, 即\neg P(X_{i}).\\&amp; 可得到\neg P(X_{i+1})成立\\&amp; 即当前结点不满足约束条件时, 它的子结点也不满足约束条件.\end{aligned}$$</p><p><strong>因此只要求解的问题满足多米诺性质,我们在使用回溯法时, 当发现当前结点不满足约束条件,就可以放弃对其子节点的搜索.</strong></p><p><strong>[理解]</strong>:</p><blockquote><p>考察多米诺性质的目的是为了确认, 在对解空间搜索的过程中, 在当前结点不满足约束条件时, 能不能放弃对当前结点的子结点的搜索.如果问题满足多米诺性质,则可以;否则, 不可以, 在这种情况下回溯法可能会丢解.</p></blockquote><h3 id="3-Example">3 Example</h3><h4 id="3-1-背包问题">3.1 背包问题</h4><blockquote><p>背包问题的描述在这里不进行赘诉.</p></blockquote><p>背包问题的约束条件</p><ol><li>$n$: 物品的数量</li><li>$x_i$: 表示是否选择该物品</li><li>$w_i$: 物品的重量</li><li>$C$:背包容量</li></ol><p>$$\left \{\begin{aligned}&amp;\Sigma_{i=1}^{n} x_i * w_i \le C, 0 &lt; i \le n\\&amp;x_i \in {0,1}, 0 &lt; i \le n\\&amp;w_i &gt; 0,0 &lt; i \le n\\\end{aligned}\right.$$</p><h5 id="背包问题的多米诺性质">背包问题的多米诺性质</h5><p><strong>[证明]</strong>:</p><p>$$\begin{aligned}&amp; 设X_{i}= \Sigma_{k=1}^{i} x_k * w_k, X_{i+1}= \Sigma_{k=1}^{i+1} x_k * w_k\\&amp; \because X_{i+1} \le C, w_k &gt; 0, x_k \in {0,1}\\&amp; \therefore X_{i} &lt; X_{i+1} \le C\end{aligned}$$</p><p>因此背包问题满足多米诺条件,可以使用回溯法解决.</p><h4 id="3-2-不等式的整数解">3.2 不等式的整数解</h4><blockquote><p>求解不等式$5x_1 + 4x_2 - x_3 \le 10, 1 \le x_i \le 3, i=1,2,3$ 的整数解.</p></blockquote><p>这个问题不满足多米诺性质<s>否则为什么要举这个例子</s></p><p><strong>[证明]</strong>:</p><p>$$\begin{aligned}&amp; 当 5x_1 + 4x_2 - x_3 \le 10 成立时 \\&amp; 显然 5x_1 + 4x_2 \le 10 不一定成立\\\end{aligned}$$因此如果只是这样的话,没办法用回溯法解决.</p><p>但也是可以用回溯法解决的.</p><p>将不等式 $5x_1 + 4x_2 - x_3 \le 10, 1 \le x_i \le 3, i=1,2,3$ 修改为 $- x_1 + 5x_2 + 4x_3 \le 10, 1 \le x_i \le 3, i=1,2,3$ , 就可以使用回溯法了.</p><p><strong>[证明]</strong>:</p><p>$$\begin{aligned}&amp; 当 - x_1 + 5x_2 + 4x_3 \le 10 成立时 \\&amp; 显然 - x_1 + 5x_2 \le - x_1 + 5x_2 + 4x_3 \le 10 成立\\&amp; 当 - x_1 + 5x_2 \le 10 成立时\\&amp; 显然 - x_1 \le - x_1 + 5x_2 \le 10成立\\\end{aligned}$$</p><p>因此不等式$-x_1 + 5x_2 + 4x_3 \le 10, 1 \le x_i \le 3, i=1,2,3$满足多米诺性质.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在复习算法, &lt;s&gt;没办法,要考试啦&lt;/s&gt;. 在复习回溯法的时候终于理解了之前不是很清楚的多米诺性质.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="https://yx1302317313.github.io/2019/04/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>https://yx1302317313.github.io/2019/04/13/优先队列/</id>
    <published>2019-04-13T13:53:40.000Z</published>
    <updated>2019-10-19T08:20:57.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优先队列">优先队列</h2><p>优先队列是一个特殊的队列.</p><ul><li>相同点: 元素从队尾插入, 从队首删除.</li><li>不同点:<ul><li>队列: 队列是先进先出(FIFO)</li><li>优先队列: 优先队列是根据元素的大小决定元素的出队顺序. 所以称之为优先队列.</li></ul></li></ul><a id="more"></a><h2 id="C-STL的优先队列">C++ STL的优先队列</h2><pre><code class="language-cpp">#include &lt;queue&gt;#include &lt;iostream&gt;int main(){std::priority_queue&lt;int&gt; pq;pq.push(1);pq.push(10);pq.push(20);pq.push(18);pq.push(3);pq.push(12);int size = pq.size();for (int i=0; i &lt; size; i++){std::cout&lt;&lt;pq.top()&lt;&lt;' ';pq.pop();}std::cout&lt;&lt;std::endl;return 0;}</code></pre><pre><code># 运行结果:20 18 12 10 3 1</code></pre><h3 id="自定义优先队列比较函数">自定义优先队列比较函数</h3><p>优先队列实际上是的一个堆, 在STL中,优先队列默认是一个大顶堆, 从排序角度看, 就是降序排序(从大到小).</p><p>让我们看一下优先队列在STL中的说明</p><pre><code class="language-cpp">/**   *  @brief  A standard container automatically sorting its contents.   *   *  @ingroup sequences   *   *  @tparam _Tp  Type of element.   *  @tparam _Sequence  Type of underlying sequence, defaults to vector&lt;_Tp&gt;.   *  @tparam _Compare  Comparison function object type, defaults to   *                    less&lt;_Sequence::value_type&gt;.   */    template&lt;typename _Tp, typename _Sequence = vector&lt;_Tp&gt;,   typename _Compare  = less&lt;typename _Sequence::value_type&gt; &gt;    class priority_queue    {}</code></pre><p>可以看到priority_queue类模板实际有三个参数.</p><ol><li>_Tp: 元素类型,就是我们存放在优先队列中的元素类型.</li><li>_Sequence: 元素序列, 默认是vector&lt;_Tp&gt;.</li><li>_Compare: 比较函数, 默认是less&lt;_Sequence::value_type&gt;. 从这里可以知道默认是大顶堆.</li></ol><p>如果我们需要一个从小到大的优先队列, 则要多增加一个比较函数的参数，但是这时第二个参数也需要传入，否则默认参数匹配会出错。</p><pre><code class="language-cpp">std::priority_queue&lt;int, std::vector&lt;int&gt;, greater&lt;int&gt; pq;//从小到大的优先队列</code></pre><h3 id="重载比较运算符">重载比较运算符</h3><pre><code class="language-cpp">struct Test{int num;char c;//注意：必须要用const修饰重载函数bool operator &gt; (const Test&amp; obj) const{return this-&gt;num &gt; obj.num;}bool operator &lt; (const Test&amp; obj) const{return this-&gt;num &lt; obj.num;}}Test;int main(){priority_queue&lt;Test, vector&lt;Test&gt;, less&lt;Test&gt;&gt; pq1;priority_queue&lt;Test, vector&lt;Test&gt;, greater&lt;Test&gt;&gt; pq2;return 0;}</code></pre><h3 id="自定义比较类">自定义比较类</h3><h2 id="优先队列代码实现">优先队列代码实现</h2><p>上面已经提到优先队列实际是一个堆,因此可以通过堆的相关算法实现优先队列.</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;template&lt;class T&gt;class PriorityQueue{private:std::vector&lt;T&gt; data;public:PriorityQueue(){}bool empty() const {return data.size()? false:true;}int size() const {return data.size();}T top() const {if (!this-&gt;empty()){return this-&gt;data[0];}return 0;}void push(T data){this-&gt;pushHeap(data);}void pop(){this-&gt;popHeap();}private: void popHeap(){this-&gt;data.erase(this-&gt;data.begin());//delete the top this-&gt;adjustHeap(0, this-&gt;data.size());//adjust heap }void adjustHeap(int i, int length){for(int child = 2*i+1; child &lt; length; child = 2*i+1){if(child + 1 &lt; length &amp;&amp; this-&gt;data[child+1] &gt; this-&gt;data[child]){child += 1;}if(this-&gt;data[child] &gt; this-&gt;data[i]){this-&gt;swap(this-&gt;data[child], this-&gt;data[i]);i = child;}else {break; // adjust over }}}void pushHeap(T data){this-&gt;data.push_back(data);int end = this-&gt;data.size()-1;  for(int i=floor(end*0.5 - 0.5); i&gt;=0; i=floor(i*0.5 - 0.5)){this-&gt;adjustHeap(i, end+1);}}void swap(T &amp;a, T &amp;b){T temp = a;a = b;b = temp;}};int main(){PriorityQueue&lt;int&gt; pq;pq.push(1);pq.push(10);pq.push(20);pq.push(18);pq.push(3);pq.push(12);int size = pq.size();for (int i=0; i &lt; size; i++){std::cout&lt;&lt;pq.top()&lt;&lt;' ';pq.pop();}std::cout&lt;&lt;std::endl;return 0;}</code></pre><h3 id="END">END</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优先队列&quot;&gt;优先队列&lt;/h2&gt;
&lt;p&gt;优先队列是一个特殊的队列.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相同点: 元素从队尾插入, 从队首删除.&lt;/li&gt;
&lt;li&gt;不同点:
&lt;ul&gt;
&lt;li&gt;队列: 队列是先进先出(FIFO)&lt;/li&gt;
&lt;li&gt;优先队列: 优先队列是根据元素的大小决定元素的出队顺序. 所以称之为优先队列.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>IEEE浮点数</title>
    <link href="https://yx1302317313.github.io/2019/04/11/IEEE%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    <id>https://yx1302317313.github.io/2019/04/11/IEEE浮点数/</id>
    <published>2019-04-11T11:33:46.000Z</published>
    <updated>2019-10-19T08:21:33.053Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前在看卡马克快速开方的程序时, 看到了一些神奇的操作.其中有两条语句与浮点数在计算机中的表示方式有关.最近计算机组成原理刚讲完浮点数的表示, 于是写篇博客记录一下.</p></blockquote><a id="more"></a><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=402073807&auto=1&height=66"></iframe></center><h3 id="计算机中定点数的表示">计算机中定点数的表示</h3><p><strong>定点数</strong>: 顾名思义, 定点数就是小数点的位置固定. 但是我们一般不会在计算机中用专门的一个位表示小数点,那样太浪费了. 因为小数点的位置的固定,只要我们知道它的位置就可以确定这个定点数, 没有必要把它表示出来.</p><p>下图是纯小数和纯整数的表示, 这个比较简单, 不进行赘诉.</p><center><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1eysn2zlj5sg20cg03h3yc.gif"></center><h3 id="计算机中浮点数的表示">计算机中浮点数的表示</h3><p><strong>浮点数</strong>: 与定点数相对, 浮点数就是这个数的小数点是不固定的(浮动的).</p><h3 id="IEEE浮点数">IEEE浮点数</h3><h3 id="转换demo">转换demo</h3><h3 id="卡马克快速开方">卡马克快速开方</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前在看卡马克快速开方的程序时, 看到了一些神奇的操作.其中有两条语句与浮点数在计算机中的表示方式有关.最近计算机组成原理刚讲完浮点数的表示, 于是写篇博客记录一下.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MCU" scheme="https://yx1302317313.github.io/categories/MCU/"/>
    
    
      <category term="计算机组成" scheme="https://yx1302317313.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
</feed>
