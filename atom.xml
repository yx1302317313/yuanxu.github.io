<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梅雪殇</title>
  
  <subtitle>晚来天欲雪，能饮一杯无</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yx1302317313.github.io/"/>
  <updated>2020-10-03T11:14:46.347Z</updated>
  <id>https://yx1302317313.github.io/</id>
  
  <author>
    <name>XuYuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大学之坎坷的保研</title>
    <link href="https://yx1302317313.github.io/2020/10/02/da-xue-zhi-kan-ke-de-bao-yan/"/>
    <id>https://yx1302317313.github.io/2020/10/02/da-xue-zhi-kan-ke-de-bao-yan/</id>
    <published>2020-10-02T03:28:40.000Z</published>
    <updated>2020-10-03T11:14:46.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间如白驹过隙，大学三年的时光已悄然离去。我仓促而又坎坷的保研之路也将走到尽头，借此国庆假期，百无聊赖之际，抒发一下心中的感慨。</p></blockquote><a id="more"></a><h2 id="个人基本情况"><a href="#个人基本情况" class="headerlink" title="个人基本情况"></a>个人基本情况</h2><p>简单说说我的基本情况</p><ul><li>学校：目前算是末流985吧</li><li>专业：计算机（最卷的一个）</li><li>排名：纯成绩，rank 18（我们学校前一年保17个。。。）；综合成绩，rank 8（在9月初才确定有竞赛加分之后）</li><li>竞赛经历：较多，但是和我的专业不算很契合（不是ACM、CTF那一类的）</li><li>论文：无</li><li>最终去向：哈工大深圳校区（不要被封面骗了，哈哈哈，谁还没有个清北梦呢）</li></ul><p>因为在9月份之前我算是保研边缘，所以夏令营没怎么参加，随便投了几个，基本初审就gg了（也过了3个吧），我的经验就主要在预推免阶段了（今年线上，其实也差不多）。</p><h2 id="写给保研边缘人"><a href="#写给保研边缘人" class="headerlink" title="写给保研边缘人"></a>写给保研边缘人</h2><p>对于保研边缘的人来说，第六学期确实是很焦虑的一段时间。确定能保研的人，都在积极准备夏令营，而且基本都能在夏令营上岸。不能保研的，自然也好说，认真准备考研即可。</p><p>而保研边缘的人就很尴尬，不知道自己该准备考研还是保研。</p><ul><li>准备考研吧，如果最后能保研了，不参加夏令营会错过很多机会，可能选不到自己想要找的导师。</li><li>准备保研吧，如果不能保研，白白参加夏令营（可能之后考研复试也有一点点优势，提前熟悉一下面试。有个别学校好像对参加过夏令营的考研学生有一定倾向吧），浪费了复习的时间。而且保研边缘的人参加夏令营也挺难的，尤其是没有竞赛、项目和论文的人。自己也没太多自信，不敢自动联系导师或者联系不到好的导师。</li></ul><p>对于保研边缘的人，我的建议是：</p><ul><li>首先要有保研和考研的双重准备（尤其是心理准备）。当然也可以选择出国或者工作，我当时并没有想过这两个方面。</li><li>准确评估自己的成绩。此时你应该可以得到全专业前五学期的成绩，这个成绩和前六学期的差不多（因为一般该学期学分较少，对平均成影响不大）。</li><li>同时还要想办法了解你排名周围的人是否有保研加分，例如竞赛加分，论文加分等等。</li><li>根据以上两个过程，你应该能够评估自己获得保研资格的概率了。如果你有很大概率保研，那么就应该大胆的尝试夏令营，同时要保证自己的成绩，不要因为忙于夏令营而使得成绩不理想失去保研资格。</li><li>如果概率不大，那么就要考虑是不是能够通过全力准备这学期的考试，提高自己的成绩。根据自己平时的学习情况和该学期的课程学分计算一下自己如果想要得到保研资格，这学期需要考到一个怎样的成绩，考到这样的概率有多大。这个其实挺难的，想要靠一个学期的成绩提高整个平均成绩0.5分都很难。我当时其实属于这个情况，我计算的是如果我第六学期的平均成绩能够达到90分，我就可以保研。但是我失败了，有一科没考好，而且这一科还是我学的比较好的一科，真没想到会挂在它上面。其实很显然，这样风险挺大的，只要有一科失误，你想提高成绩就没戏了。</li><li>还有一条路就是保研加分（有的学校好像没有），仔细看看学校的保研加分细则，是不是有机会通过参加竞赛获得加分。慎重考虑，因为这个很浪费时间，而且获得加分的可能性也不大（除非你对这个竞赛的项目很擅长或者有靠谱的队友）。这个当时我也准备了，最后也算是靠它上岸了吧（我之前参加类似的竞赛挺多的，所以对于我来说成功的几率也很高，但是也可能会翻车）。</li><li>对于感觉保研概率不大的人，也可以参加夏令营，但是不要报太多浪费时间，重点还是要尽最大努力让自己拿到保研资格。首先可以参加一个差一点但是比较容易拿到优营的学校，毕竟手里有了offer心里就没那么慌了。可惜我当时并没有，不知道是傻还是迷之自信，竟然只报了华五、计算所和校本部。<del>（可能有人大致能猜到我是哪个学校的了）</del></li><li>之后可以再参加几个比较好的学校的夏令营，能拿到优营最好，拿不到也可以为之后的预推免积累经验。但是不要乱报，有坑（太惨了，这个之后再说）。</li></ul><p><strong>以上仅我个人见解，可能有不对的地方或者对于一些人并不适合。</strong></p><p>不过要记住一点，<strong>不要因为在保研边缘焦虑而荒废时间</strong>。我有一段时间就是在焦虑中虚度终日，浪费了不少时间。</p><p><strong>相信自己，只要你努力，总会有好结果的</strong>。即使最后不能保研，你好好考研也可以去自己想去的学校（甚至比保研去的学校更好）。</p><p>我也想过是不是要直接放弃保研，考研冲一个更好的学校（我想去的是清华或者上交）。最后打消了这个想法，一是计算机考清华和上交真的很难，二是不甘心放弃保研（毕竟是大学三年的努力）。</p><h2 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h2><p>我夏令营没怎么准备，之前并不打算参加的。因为我不确定自己能保研，认为浪费时间，不如好好学习本学期的课程提提成绩。但是之后看很多人都在报，而且学长学姐们也说了不会浪费太多时间，就随便投了几个。</p><p>下面就是我夏令营的<strong>悲惨</strong>经历了。</p><p>我申请了下面几个学校的夏令营</p><ul><li>中科院计算所</li><li>南大人工智能学院</li><li>南大软件</li><li>复旦（NLP方向）</li><li>上交直博</li><li>中科大先研院（深圳先进技术研究院）</li><li>哈工大本部</li><li>哈工大深圳（想报但是错过了，不过即使报了也进不了，深圳夏令营太难进了。。。）</li><li>浙大（浙大夏令营只能报直博，没找到自己感兴趣的导师就没报）</li></ul><p>通过初审的</p><ul><li>南大软件</li><li>上交直博</li><li>哈工大本部</li></ul><p>通过复试的</p><ul><li>上交直博</li></ul><p>拿到offer的</p><ul><li>None</li></ul><h3 id="南大软件"><a href="#南大软件" class="headerlink" title="南大软件"></a>南大软件</h3><p>南京大学每年都有开放日，对于计算机专业可以选人工智能学院和计算机学院。我当时竟然直接选了人工智能，结果凉了，如果报计算机还有机会过初审。</p><p>南京大学软件学院是和上面独立的，所以可以同时报。因为南软今年也是个海王，直接初审过了近700人吧，所以很容易就进了。</p><p>初审通过后南软安排了机试刷人，但是机试当天就出事故了（懂的都懂，不懂知乎走起）。之后又重新安排了机试，我神奇的进错了网站然后就没有然后了（南软的那个OJ网站真的很迷）。由于我不太想去南大软件，所以也没在意，直接翻篇。</p><p>据说最后夏令营不是优秀就是良好（继续养鱼）。</p><h3 id="哈工大本部"><a href="#哈工大本部" class="headerlink" title="哈工大本部"></a>哈工大本部</h3><p>本来以为这个是可以拿到优营的，但是夏令营的时间正好和我期末考试冲突了，所以就没准备。</p><p>面试的时候一道专业课的题和一道智力题没答出来就直接凉了。后面有面试的题目，对该部分不感兴趣的可以跳过(^_^)。</p><p>哈工大最后优营只给了60多个吧，不算很多，差不多1/3。</p><p>下面就要说我前面提到的坑了，真的<em>太惨了</em>。有的学校<strong>如果夏令营入了但是没有拿到优营是不能再参加九月份的预推免的</strong>，今年哈工大就是。所以在报夏令营之前，一定要了解学校是不是有这种限制。如果有，一定要<strong>慎重</strong>，<strong>慎重</strong>，<strong>再慎重</strong>。在你没有把握拿到优营的时候，建议不要报，留到预推免再报（预推免竞争相对小一点）。</p><p>我当时并不知道，在预推免的时候我和导师已经联系好了，最后发现初审通过不了。我打电话到学校研招办，对方的回答是今年人太多了，不想再面试第二次，初审不会给我通过的。</p><p>真是时运不齐，命运多舛啊！！！本来以为比较稳的offer，夏令营和预推免都凉了，也导致我之后几天一直很焦虑。最后真的感谢哈工深收留我。</p><h4 id="复试题目"><a href="#复试题目" class="headerlink" title="复试题目"></a>复试题目</h4><p>哈工大本部复试共20分钟，分四个部分（每个5分钟），由不同的老师提问。</p><ol><li>介绍一个你印象最深刻的项目或者做的最好的一个项目？</li><li>你在项目中对团队合作的感受？</li><li>计算机网络中TCP的拥塞控制机制</li><li>分金条问题</li></ol><h3 id="上交直博"><a href="#上交直博" class="headerlink" title="上交直博"></a>上交直博</h3><p>通过上交直博的初审倒是我始料未及的。上交直硕的难度可以说是整个华五最难的，当然个别学校的强组除外。所以我申请了直博，我未来的规划是读博的，但是不想直博。</p><p>是否直博这个问题也是保研中常见的问题，这个要综合考虑个人的规划、学校、方向和导师。在直博方面我的原则是</p><ul><li>导师 &gt; 研究方向 &gt; 学校title</li><li>导师：学术牛导、人品nice</li><li>方向：自己感兴趣的方向、有前景和相对容易发论文的方向。</li><li>学校：清北、上交、浙大、南大、计算所、自动化所（复旦和中科大的计算机相对弱一点）</li></ul><p>其实综合我的情况，我是不适合直博的，根本没有条件申请到上面的这些学校和导师。</p><p>总而言之，<strong>直博要慎重</strong>，尤其是上交这种博士很难毕业的学校。</p><p>上交直博的复试其实也挺简单的。首先一定会有的是英文问题，南方学校都喜欢问英语问题，尤其是华五。所以想保研到南方学校的，一定要准备一些英语问题（尤其准备一些和专业课相关的）。</p><p>我当时时间紧张，基本只准备了自我介绍，幸运的是我的问题正好就是自我介绍。之后都是项目相关的问题，可能是直博吧，老师对项目挺感兴趣的。面试完我的自我感觉也很好，之后确实通过了面试。至于之后为什么没有offer</p><ul><li>一是上交直博要在8月中旬和导师双选，而我当时还不能确定有保研资格</li><li>二是以我当时的条件，找不到太好的导师</li></ul><p>所以我最后放弃了。也挺遗憾的，如果我能提前一个月确定自己有保研资格，我或许能找到一个不错的导师，直接直博上岸。</p><h4 id="复试题目-1"><a href="#复试题目-1" class="headerlink" title="复试题目"></a>复试题目</h4><ol><li>Please introduce yourself by English</li><li>项目问题</li><li>项目问题</li></ol><p>我的夏令营就这样无疾而终了（0 offer）。</p><h2 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a>预推免</h2><p>在9月初，我终于确定了自己的保研资格，综合排名rank 8，于是开始了我的预推免冲刺。其实当时已经很晚了，很多学校预推免很早就开始报名了（清华已经截止了，本来想试一下清华深圳的）。</p><p>之后的一个星期，每天都是在查学校、查导师和联系导师。那一个星期是真的累，每天晚上到9点多头就开始晕了，什么都不想干。</p><p>下面是我预推免时投的学校：</p><ul><li>计算所（VIPL）</li><li>自动化所（非模式识别组）</li><li>浙大CS（浙大软件在宁波，不想去）</li><li>上交自动化（上交CS预推免时不招硕士，夏令营的时候已经招够了，于是报了自动化）</li><li>复旦CS</li><li>南京大学CS（不敢报AI了）</li><li>哈工大本部（因为之前提到的原因，初审肯定过不了）</li><li>哈工大深圳</li><li>西交人机所</li><li>天津大学（这个算保底了）</li><li>同济</li><li>北航</li><li>武大</li><li>北大软微（没报）</li></ul><p>通过初审的：</p><ul><li>南京大学CS</li><li>哈工大深圳</li><li>西交人机所</li><li>天津大学</li><li>同济</li></ul><p>计算所、自动化所、上交和浙大都没过，看来我的排名和竞赛人家还是看不上啊。复旦今年就离谱，拒了我两次（复旦计算机实力不是很强，学科评估才<code>B+</code>，下一次评估可能能到<code>A-</code>吧），据说复旦和人大基本只要rank 1（人家综合实力强啊，招的人还少）。</p><p>北大软微需要邮寄材料和线下面试，我那几天正在准备深圳的机试，于是就没报。另一方面我也不是很想去软微，但是今年软微的门槛挺高的，比前一年高了很多，很多清北本科的都在报。一是因为今年的形势、国内保研内卷严重，二是因为软微这几年的知名度也高了吧（毕竟是北大的title）。现在想想也挺可惜的，时间还是太仓促，错失了一些机会。</p><p>北航和武大的结果还没出，如果过了，可能会试试北航。</p><p>拿到offer的：</p><ul><li>南京大学CS（替补名单中）</li><li>哈工大深圳</li><li>西交人机所</li><li>天津大学</li></ul><p>同济初审过了，但是我放弃了，因为当时已经有哈工深的offer了。今年哈工深也很卷，不知道是不是有人在博弈，故意把哈工深抬高（我感觉哈工深的实力还没有那么强，虽然近几年高考分一路逼近华五）。</p><p>综上，基本参加了复试的都过了（南大算半个，嘻嘻～～）。</p><h3 id="哈工大深圳"><a href="#哈工大深圳" class="headerlink" title="哈工大深圳"></a>哈工大深圳</h3><p>哈工深复试有机试和面试两个部分，机试如果不能通过就没有面试机会了。</p><h4 id="机试"><a href="#机试" class="headerlink" title="机试"></a>机试</h4><p>机试考了6门专业课（离散数学、C语言、数据结构、计算机网络、数据库和操作系统），题不算很难，但有些地方考的还是比较细的。其中离散数学、C语言和数据结构考的较多，C语言主要是考指针，离散数学中集合论和图论、数理逻辑和近世代数部分都有涉及。</p><p>考6门课确实很烦（对于我也可以是8门，因为我们离散数学分成了3门课），我当时只有一天时间，于是只看了计算机网络、数据库和操作系统。C语言一直在用，不用复习，数据结构之前复习过。唯一裸考的算是离散数学，机试的时候离散还考了很多。。。</p><p>我的机试成绩还算可以，算是正常发挥，考完我其实就感觉有很大可能可以进入下一步的面试了。</p><h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><p>可能是因为机试考了专业课吧，面试相对简单。共20分钟，10分钟PPT自我介绍和10分钟问答。</p><ol><li>双目测距原理（根据你的项目提问）</li><li>质疑项目的实用性</li><li>介绍一下你的家庭情况（很迷）</li><li>是否有其他学校offer或者面试了其他学校？</li></ol><h3 id="南京大学"><a href="#南京大学" class="headerlink" title="南京大学"></a>南京大学</h3><p>南京大学也是机试和面试两个部分，只不过最后是算一个综合的分。</p><h4 id="机试-1"><a href="#机试-1" class="headerlink" title="机试"></a>机试</h4><p>机试同样是选择题，有一个题库，共有20多套题吧。机试的时候让你自己随机选，这个就有点运气在里面了。好像每套题有5个选择题，都是专业课的问题。题不算难，但是感觉怪怪的，可能选项错误不明显，不太好选。</p><h4 id="面试-1"><a href="#面试-1" class="headerlink" title="面试"></a>面试</h4><p>面试还是专业课问题，南大每年对专业课都挺看重的，对你的竞赛和项目经历倒是没什么兴趣。所以对于成绩较好但是项目经历不多的人，南大是一个很好的选择。</p><ol><li>Please introduce operating systems course to a junior or a senior student？</li><li>你对编程语言中类型的理解？</li><li>判断一个无向图是否有环路？</li><li>介绍一下面向对象中的多态？</li><li>如果导师交给你的任务你没有按时完成，怎么和导师解释？</li></ol><h3 id="西安交通大学"><a href="#西安交通大学" class="headerlink" title="西安交通大学"></a>西安交通大学</h3><p>之所以报名西交人机所，是因为人机所自动驾驶做的很好（国内自动驾驶做的比较好的高校好像就是清华和西交了。清华，永远的神呀！），而且人机所的老师都挺强的，郑南宁院士，孙剑大佬和薛建儒教授等等。</p><p>西交CS虽然不强，但是人机所还不错，不抵触专业是控制科学与工程的或者对机器人和自动驾驶感兴趣的可以考虑一下西交。</p><h4 id="复试"><a href="#复试" class="headerlink" title="复试"></a>复试</h4><p>西交人工智能学院复试挺简单的（按理说不应该），没什么参考价值。</p><h3 id="天津大学"><a href="#天津大学" class="headerlink" title="天津大学"></a>天津大学</h3><p>天津大学复试也很简单，因为天大计算机学科不是很强，竞争不激烈。</p><p>复试分为三部分：</p><ul><li>1分钟英文自我介绍</li><li>4分钟PPT介绍自己的科研经历（中英文皆可）</li><li>5分钟问答（科研经历不多的，会问专业课；有科研的，会问科研相关的）</li></ul><ol><li>你在项目中有没有对图像处理算法做过什么改进？</li><li>你对深度学习的了解怎么样？</li></ol><h3 id="北航"><a href="#北航" class="headerlink" title="北航"></a>北航</h3><h2 id="路漫漫其修远兮"><a href="#路漫漫其修远兮" class="headerlink" title="路漫漫其修远兮"></a>路漫漫其修远兮</h2><p>保研是一场持久战，可以说是你大学三年的努力换来的一次机会。尤其是第六学期，这个学期是保研人最累的一段时间（大佬除外），对于边缘的人更是如此。但是要记住，不论收到了多少拒信，不论有多少失意与挫折，一定要坚持下去，不要放弃，终会柳暗花明的。</p><p>说一下我最近最失意的一段时间。</p><p>大概三周前，我得知哈工大本部参加夏令营没有优营的不能再报名预推免，当时我就很难受了。因为我已经和老师联系好了，本以为可以拿到第一个offer的时候，而它却因为我之前随便参加的夏令营就不翼而飞了。</p><p>之后的打击接踵而至，计算所初审未通过（发了拒信），南大初审未通过（没给我发拒信，但是有人收到了通过的邮件）。再然后哈工深的初审也没有通过，这个我觉得是最可惜的。因为我报名时我们学校的推免排名还没出，所以我在系统上填的是我前五学期的排名（很低）。推免排名公布了之后，在我刚刚提交了新的排名证明的那一天它出了初审结果（也就是哈工深负责审核的老师看到的是那个很低的排名）。我认为如果是新的排名我一定能过初审的，于是我给哈工深研招办打了电话说明了情况，希望他们能够重新帮我审核一下，结果可想而知，不可能的。（不过哈工深研招办的老师态度很多，关键是小姐姐声音好听(^_^)，和我聊了有10分钟左右）</p><p>上面三所学校是我认为机会最大的三所，结果因为各种原因连初审都没过，其他的就更难通过了。之后的一天我一直很消沉也很焦虑，感觉自己辛辛苦苦获得了保研资格最后却只能留在本校，真的不甘心啊！当时已经有了放弃保研去考研的想法了。</p><p>那天晚上，和某人偶然说起我很焦虑之后，她和我说了一些算是安慰的话吧。之后心情好了一点，自己也看开了，保研比考研还是好很多的，大不了留本校呗（本校有一个还不错的老师）。然后临睡前我收到了哈工深的复试通知（哈工深特别喜欢晚上发邮件，难道深圳连老师都要996吗），应该是有人放弃，我被替补了。当时有一种重获新生的感觉。又过了几天，我收到了西交和南大的复试通知，之后一切都好了起来。</p><p><strong>总之，不管是保研还是考研，在遇到失意与挫折时，一定要坚持下去！有一个好的心态，一切都会好的！</strong></p><p>最后借尼采的一句话收尾，<strong>What doesn’t kill you makes you stronger！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间如白驹过隙，大学三年的时光已悄然离去。我仓促而又坎坷的保研之路也将走到尽头，借此国庆假期，百无聊赖之际，抒发一下心中的感慨。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="远方" scheme="https://yx1302317313.github.io/categories/%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="HIT" scheme="https://yx1302317313.github.io/tags/HIT/"/>
    
  </entry>
  
  <entry>
    <title>强化学习</title>
    <link href="https://yx1302317313.github.io/2020/07/13/qiang-hua-xue-xi/"/>
    <id>https://yx1302317313.github.io/2020/07/13/qiang-hua-xue-xi/</id>
    <published>2020-07-13T03:41:18.000Z</published>
    <updated>2020-07-13T03:51:26.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识强化学习"><a href="#初识强化学习" class="headerlink" title="初识强化学习"></a>初识强化学习</h2><h3 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h3><img src=https://image.jiqizhixin.com/uploads/editor/f6afd9c9-a981-4c6c-853e-7cb959e96f77/640.png width=500><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><blockquote><p>强化学习(Reinforcement Learning)这一名词来源于行为心理学,表示生物为了趋利避害而更频繁实施对自己有利的策略。</p></blockquote><p>例如,在工作中会根据策略决定做出各种动作。如果我的某些决定使我升职加薪,而另外一些决策使我受到了处罚,那么我在以后的工作中会更多采用使我升职加薪的决策。</p><p>正强化 VS 负强化</p><ul><li>正强化使得生物趋向于获得更多利益。(升职加薪)</li><li>负强化使得生物趋向于避免损害。(遭受处罚)</li></ul><p>人工智能领域中有许多类似的趋利避害的问题。例如,著名的围棋AI程序<strong>AlphaGo</strong>可以根据不同的围棋局势下不同的棋。如果它下得好,它就会赢;如果下得不好,它就会输。它根据下棋的经验不断改进自己的棋艺。</p><p>人工智能借用了行为心理学的这一概念,把<strong>与环境交互中趋利避害的学习过程</strong>称为<strong>强化学习</strong>。</p><h3 id="强化学习的分类"><a href="#强化学习的分类" class="headerlink" title="强化学习的分类"></a>强化学习的分类</h3><img src=http://photo.jiayuanxu.com:8000/media/albums/Screenshot_from_2020-07-12_20-35-47.jpg width=500><h3 id="强化学习的关键元素"><a href="#强化学习的关键元素" class="headerlink" title="强化学习的关键元素"></a>强化学习的关键元素</h3><p>在一个强化学习系统中,<strong>决策者</strong>可以观察环境,并根据观测做出行动。在行动之后,能够获得奖励。强化学习通过与环境的交互来学习如何最大化奖励。</p><p>例如,一个走迷宫的机器人在迷宫里游荡(见图1-1)。机器人观察周围的环境,并且根据观测来决定如何移动。错误的移动会让机器人浪费宝贵的时间和能量,正确的移动会让机器人成功走出迷宫。在这个例子中,机器人的移动就是它根据观测而采取的行动,浪费的时间能量和走出迷宫的成功就是给机器人的奖励(时间能量的浪费可以看作负奖励)。</p><img src=https://puui.qpic.cn/qqvideo_ori/0/p0899mupo20_496_280/0 width=500><p>强化学习的最大特点是在学习过程中<strong>没有正确答案</strong>,而是<strong>通过奖励信号来学习</strong>。</p><ul><li>奖励(Reward):奖励是强化学习系统的学习目标。学习者在行动后会接收到环境发来的奖励,而强化学习的目标就是要最大化在长时间里的总奖励。</li><li>策略(Policy):决策者会根据不同的观测决定采用不同的动作,这种从观测到动作的关系称为策略。<strong>强化学习的学习对象就是策略</strong>。强化学习通过改进策略以期望获取最大化的总奖励。</li></ul><h3 id="强化学习的应用"><a href="#强化学习的应用" class="headerlink" title="强化学习的应用"></a>强化学习的应用</h3><img src=https://n.sinaimg.cn/sports/transform/11/w496h315/20200308/8e23-iqrhckm2022398.png width=500><ol><li>电动游戏:主要指玩家需要根据屏幕画面的内容进行操作的游戏，如主机游戏吃豆人(PacMan)、PC游戏星际争霸(StarCraft)。</li><li>棋盘游戏:通过强化学习可以实现各种棋盘运动的AI。棋盘AI有着明确的目标——提高胜率，但是每一步往往没有绝对正确的答案,这正是强化学习所针对的场景。AlphaGo就是强化学习和深度学习结合的产物。</li></ol><h2 id="智能体-环境接口"><a href="#智能体-环境接口" class="headerlink" title="智能体/环境接口"></a>智能体/环境接口</h2><p>强化学习问题常用<strong>智能体/环境接口(Agent-Environment Interface)</strong> 来研究。智能体/环境接口将系统划分为智能体和环境两个部分。</p><ul><li>智能体(Agent):是强化学习系统中的决策者和学习者,它可以做出决策和接受奖励信号。一个强化学习系统里可以有一个或多个智能体。</li><li>环境(Environment)是强化系统中除智能体以外的所有事物,它是智能体交互的对象。</li></ul><img src=http://photo.jiayuanxu.com:8000/media/albums/Screenshot_from_2020-07-12_20-24-54.jpg width=500><p><strong>智能体/环境接口的核心思想</strong>:分隔主观可以控制的部分和客观不能改变的部分。</p><p>在智能体/环境接口中,智能体和环境的交互主要有以下三个环节:</p><ol><li>智能体观测环境,可以获得环境的观测(observation),记为$O$;</li><li>智能体根据观测做出决策,决定要对环境施加的动作(action),记为$A$;</li><li>环境受智能体动作的影响,改变自己的状态(state),记为$S$,并给出奖励(reward),记为$R$。</li></ol><p>在很多任务中,智能体和环境是在离散的时间步骤上交互的,这样的问题可以将时间指标离散化,建模为离散时间智能体/环境接口。具体而言,假设交互的时间为$t=0,1,2,3,…$。在时刻t,依次发生以下事情:</p><ul><li>智能体观察环境得到观测$O_t$ ;</li><li>智能体根据观测决定做出动作$A_t$;</li><li>环境根据智能体的动作,给予智能体奖励$R_{t+1}$ 并进入下一步的状态$S_{t+1}$。</li></ul><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><blockquote><p>Markov决策过程(Markov Decision Process,MDP)是强化学习最经典、最重要的数学模型.</p></blockquote><h3 id="Markov决策过程模型"><a href="#Markov决策过程模型" class="headerlink" title="Markov决策过程模型"></a>Markov决策过程模型</h3><p>离散时间Markov决策过程模型可以在离散时间的智能体/环境接口的基础上进一步引入具有Markov性的概率模型得到。</p><p><a href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B4%A8" target="_blank" rel="noopener">Markov性</a>:当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是条件独立的，那么此随机过程即具有马尔可夫性质。</p><p>在离散时间智能体/环境接口中,智能体和环境交互的时刻为$\{0,1,2,3,…\}$。在时刻$t$,依次发生以下事情:</p><ul><li>智能体观察状态$S_t \in S$的环境,得到观测$O_t \in O$,其中$S$是状态空间(state space),表示状态取值的综合;$O$是观测空间(observationspace),表示观测取值的集合。</li><li>智能体根据观测决定做出动作$A_t \in A$,其中$A$是动作集合。</li><li>环境根据智能体的动作,给予智能体奖励$R_{t+1} \in R$,并进入下一步的状态$S_{t+1} \in S$。其中$R$是奖励空间(reward space),表示奖励取值的集合。</li></ul><p>一个时间离散化的智能体/环境接口可以用这样的轨道表示:$S_0,O_0,A_0,R_1,S_1,O_1,A_1,R_2,S_2,O_2,A_2,R_3….$。对于回合制的任务,可能会有一个终止状态$S_T$,则可以表示为$S_0,O_0,A_0,R_1,S_1,O_1,A_1,R_2,S_2,O_2,A_2,R_3….,S_T$。</p><p>引入<strong>概率</strong>和<strong>Markov性</strong>,就可以得到Markov决策过程模型。</p><p>定义在时间$t$,从状态$S_t=s$和动作$A_t=a$跳转到下一状态$S_{t+1}=s’$和奖励$R_{t+1}=r$的概率为:</p><p>$$<br>Pr[S_{t+1}=s’,R_{t+1} =r|S_t =s,A_t =a]<br>$$</p><p>模型中的Markov性:认为奖励$R_{t+1}$和下一状态$S_{t+1}$仅仅依赖于当前的状态$S_t$和动作$A_t$,而不依赖于更早的状态和动作。</p><p><strong>[注意]</strong>: 智能体/环境接口没有假设状态满足Markov性。Markov性是Markov决策过程的特点。</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><blockquote><p>策略:智能体在当前状态根据其观测决定其行为的依据。</p></blockquote><p>在Markov决策过程中,定义策略(policy)为从状态到动作的转移<strong>概率</strong>。对于有限Markov决策过程,其策略$\pi: S*A \to [0,1]$可以定义为$\pi(a|s)=Pr[A_t=a | S_t=s],s∈S,a∈A$。</p><table><thead><tr><th>状态</th><th>动作</th><th>概率</th></tr></thead><tbody><tr><td>hungry</td><td>eat</td><td>&nbsp;1-x</td></tr><tr><td>hungry</td><td>not eat</td><td>x</td></tr><tr><td>full</td><td>eat</td><td>1-y</td></tr><tr><td>full</td><td>not eat</td><td>y</td></tr></tbody></table><h3 id="奖励、回报与价值函数"><a href="#奖励、回报与价值函数" class="headerlink" title="奖励、回报与价值函数"></a>奖励、回报与价值函数</h3><blockquote><p>强化学习的核心概念是奖励,强化学习的目标是最大化长期的奖励</p></blockquote><p>对于回合制任务,假设某一回合在第T步达到终止状态,则从步骤$t(t&lt;T)$以后的回报(return)$G_t$可以定义为未来奖励的和<br>$$<br>G_t =R_{t+1}+R_{t+2} +…+R_{T}<br>$$</p><p>对于连续性任务,由于任务没有终止时间,所以$G_t$会包括$t$时刻以后所有的奖励信息。但是,如果对未来的奖励信息简单求和,那么未来奖励信息的总和往往是无穷大。所以引入了折扣(discount)这一概念,进而定义回报</p><p>$$<br>G_t =R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + … = \Sigma_{\tau = 0}^{+ \infty} R_{t+ \tau + 1}<br>$$</p><ul><li>其中折扣因子$\gamma \in [0,1]$</li><li>折扣因子决定了如何在最近的奖励和未来的奖励间进行折中</li><li>若指定$\gamma=0$,智能体会只考虑眼前利益,完全无视远期利益,就相当于贪心算法的效果</li><li>若指定$\gamma=1$,智能体会认为当前的1单位奖励和未来的1单位奖励是一样重要的。</li></ul><p>基于回报的定义,可以进一步定义价值函数(value function)</p><ul><li><p>状态价值函数(state value function):状态价值函数$v_\pi(s)$表示从状态$s$开始采用策略$\pi$的预期回报。如下式所示:<br>$$<br>v_\pi(s)=E_\pi[G_t | S_t=s]<br>$$</p></li><li><p>动作价值函数(action value function):动作价值函数$q_\pi(s,a)$表示在状态$s$采取动作$a$后,采用策略$\pi$的预期回报。如下式所示:</p></li></ul><p>$$<br>q_\pi(s,a)=E_\pi [G_t |S_t=s,A_t =a]<br>$$</p><h2 id="Q学习-Q-Learning"><a href="#Q学习-Q-Learning" class="headerlink" title="Q学习(Q-Learning)"></a>Q学习(Q-Learning)</h2><p><strong>强化学习的任务</strong>:学习一个<strong>最优策略</strong>使得智能体能够<strong>最大化长期的奖励</strong>。</p><p>方法:</p><ul><li>对环境建模,计算最优策略</li><li>依靠经验学习出给定策略的价值函数和最优策略</li></ul><p>Q学习(Q-Learning):一种异策(off policy)时序差分更新的无模型的机器学习算法</p><ul><li>无模型的机器学习算法:在没有环境的数学描述的情况下,只依靠经验(例如轨迹的样本)学习出给定策略的价值函数和最优策略。在现实生活中,为环境建立精确的数学模型往往非常困难。因此,无模型的强化学习是强化学习的主要形式。</li><li>异策:<strong>同策(on policy)学习</strong>是边决策边学习,学习者同时也是决策者。<strong>异策学习</strong>则是通过之前的历史(可以是自己的历史也可以是别人的历史)进行学习,学习者和决策者不需要相同。</li><li>时序差分更新:<strong>回合制更新</strong>是在回合结束后利用整个回合的信息进行更新学习;而<strong>时序差分更新</strong>不需要等回合结束,可以综合利用现有的信息和现有的估计进行更新学习(每做一个Action就可以进行更新)。</li></ul><p>如何根据经验学习:</p><ul><li>在不同的状态下尝试不同的动作,然后可以得到一个对应的奖励,记录下不同状态下不同动作的奖励,然后在下一次决策的时候根据之前的记录选择一个可以得到较高奖励的决策(贪心)。</li><li>但是贪心算法可能陷入局部最优解,不能完全采用贪心算法,于是引入随机算法,在某些情况下随机选取策略。</li></ul><h3 id="Q学习算法"><a href="#Q学习算法" class="headerlink" title="Q学习算法"></a>Q学习算法</h3><p>单步时序差分更新将依据$q_{\pi}(s,a)=E_{\pi}[R_{t+1} + \gamma q_{\pi}(S_{t+1}, A_{t+1})|S_t=s,A_t=a]$</p><p>在当前状态$s$,采取动作$a$后,进入了状态$S_{t+1}$。更新其对应的动作价值函数$q_π(s,a)$,一部分为当前获得的奖励$R_{t+1}$,另一部分为预测的之后可以获得的奖励$ \gamma q_{\pi}(S_{t+1}, A_{t+1})$。</p><p>定义Q学习时序差分目标:$U_{t:t+1}^{(q)} = R_{t+1} + \gamma max_{a \in A(S_{t+1})}q((S_{t+1}, a))$</p><ul><li>上标$(q)$表示是对动作价值定义的</li><li>下标$t:t+1$表示用$(S_{t+1} ,\cdot)$估计值中的最大值来估计$(S_t,A_t)$。如果$S_{t+1}$是终止状态,默认有$q(S_{t+1}, \cdot)=0$。</li></ul><p>动作价值函数的增量更新:$q(S_t,A_t) = q(S_t, A_t) + \alpha [U_t - q(S_t, A_t)]$</p><ul><li>$\alpha$ 为学习率</li><li>增量$U_t - q(S_t, A_t)$试图不断减小$[G_t - q(S_t,A_t)]^2$,使得$q(S_t, A_t)$不断接近实际的回报值.</li></ul><h3 id="Q学习算法求解最优策略"><a href="#Q学习算法求解最优策略" class="headerlink" title="Q学习算法求解最优策略"></a>Q学习算法求解最优策略</h3><ol><li>(初始化)$q(s,a) \gets any \ value$,$s \in S, a \in A$。如果有终止状态,令$q(s_T,a) \gets 0$</li><li>(初始化状态-动作对)选择状态S。</li><li>如果回合未结束(例如未达到最大步数、S不是终止状态),执行以下操作:<ol><li>用动作价值估计$q(S,\cdot)$确定的策略决定动作A(如$\epsilon$贪心策略);</li><li>(采样)执行动作$A$,观测得到奖励$R$和新状态$S’$;</li><li>(用改进后的策略计算回报的估计值);</li><li>(更新价值和策略)更新$q(S,A)$(如$q(S,A) \gets q(S,A) + \alpha [U - q(S,A)]$);</li><li>$S \gets S’$。</li></ol></li></ol><p><strong>$\epsilon$贪心策略</strong>:假设$\epsilon=0.1$，以10%的概率随机选择，90%的概率采用贪婪选择。</p><h2 id="A-Game-Demo"><a href="#A-Game-Demo" class="headerlink" title="A Game Demo"></a>A Game Demo</h2><p>在一个4*4的地图中,智能体(红色块)需要找到最短的路径到达目标位置(黄色块),但是需要避开陷阱(黑色块)。</p><img src=http://photo.jiayuanxu.com:8000/media/albums/Screenshot_from_2020-07-12_23-40-05.jpg width=300><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><p>智能体：红色块</p></li><li><p>环境:4*4的网格地图</p></li><li><p>状态:智能体当前所处的位置</p></li><li><p>动作:上、下、左、右移动</p></li><li><p>奖励：</p><ul><li>如果智能体到达黄色块得到正奖励。</li><li>如果智能体到达黑色块则得到负奖励。</li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>学习率($\alpha$)</li><li>$\epsilon$贪心策略的概率($\epsilon$)</li><li>折扣因子($\gamma$)</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Q-Table"><a href="#Q-Table" class="headerlink" title="Q-Table"></a>Q-Table</h4><blockquote><p>存储不同状态下不同动作的动作价值函数值。</p></blockquote></li></ul><table><thead><tr><th>state</th><th>up</th><th>down</th><th>left</th><th>right</th></tr></thead><tbody><tr><td>(0,0)</td><td>0.2</td><td>0.4</td><td>0.2</td><td>0.4</td></tr><tr><td>(0,1)</td><td>0.3</td><td>0.2</td><td>0.3</td><td>0.2</td></tr><tr><td>(0,2)</td><td>0.05</td><td>0.05</td><td>0.4</td><td>0.5</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>(3,3)</td><td>0.1</td><td>0.1</td><td>0.7</td><td>0.1</td></tr></tbody></table><ul><li>不同状态下根据Q表中的值和选择的策略选择相应的动作</li><li>转移到新的状态并得到奖励后，更新Q表中的值</li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 学习策略</span><span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> episode <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># initial observation</span>        observation <span class="token operator">=</span> env<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># fresh env</span>            env<span class="token punctuation">.</span>render<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># RL choose action based on observation</span>            action <span class="token operator">=</span> RL<span class="token punctuation">.</span>choose_action<span class="token punctuation">(</span>str<span class="token punctuation">(</span>observation<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># RL take action and get next observation and reward</span>            observation_<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> done <span class="token operator">=</span> env<span class="token punctuation">.</span>step<span class="token punctuation">(</span>action<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># RL learn from this transition</span>            RL<span class="token punctuation">.</span>learn<span class="token punctuation">(</span>str<span class="token punctuation">(</span>observation<span class="token punctuation">)</span><span class="token punctuation">,</span> action<span class="token punctuation">,</span> reward<span class="token punctuation">,</span> str<span class="token punctuation">(</span>observation_<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># swap observation</span>            observation <span class="token operator">=</span> observation_            <span class="token comment" spellcheck="true"># break while loop when end of this episode</span>            <span class="token keyword">if</span> done<span class="token punctuation">:</span>                <span class="token keyword">break</span>    <span class="token comment" spellcheck="true"># end of game</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'game over'</span><span class="token punctuation">)</span>    env<span class="token punctuation">.</span>destroy<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 贪婪策略选择动作</span><span class="token keyword">def</span> <span class="token function">choose_action</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> observation<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>check_state_exist<span class="token punctuation">(</span>observation<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># action selection</span>    <span class="token keyword">if</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>epsilon<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># choose best action</span>        state_action <span class="token operator">=</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>observation<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># some actions may have the same value, randomly choose on in these actions</span>        action <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>state_action<span class="token punctuation">[</span>state_action <span class="token operator">==</span> np<span class="token punctuation">.</span>max<span class="token punctuation">(</span>state_action<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># choose random action</span>        action <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>self<span class="token punctuation">.</span>actions<span class="token punctuation">)</span>    <span class="token keyword">return</span> action</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 更新Q表</span><span class="token keyword">def</span> <span class="token function">learn</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> a<span class="token punctuation">,</span> r<span class="token punctuation">,</span> s_<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>check_state_exist<span class="token punctuation">(</span>s_<span class="token punctuation">)</span>    q_predict <span class="token operator">=</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>s<span class="token punctuation">,</span> a<span class="token punctuation">]</span>    <span class="token keyword">if</span> s_ <span class="token operator">!=</span> <span class="token string">'terminal'</span><span class="token punctuation">:</span>        q_target <span class="token operator">=</span> r <span class="token operator">+</span> self<span class="token punctuation">.</span>gamma <span class="token operator">*</span> self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>s_<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>max<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># next state is not terminal</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        q_target <span class="token operator">=</span> r  <span class="token comment" spellcheck="true"># next state is terminal</span>    self<span class="token punctuation">.</span>q_table<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>s<span class="token punctuation">,</span> a<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>lr <span class="token operator">*</span> <span class="token punctuation">(</span>q_target <span class="token operator">-</span> q_predict<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># update</span></code></pre><h3 id="result"><a href="#result" class="headerlink" title="result"></a>result</h3><center><video class="index-video" controls>                        <source src="/video/rl-demo.mp4" type="video/mp4">                    </video></center><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] [Reinforcement Learning.Sutton]</li><li>[2] [强化学习：原理与Python实现]</li><li>[3] [莫烦Python]（<a href="https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/）" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;初识强化学习&quot;&gt;&lt;a href=&quot;#初识强化学习&quot; class=&quot;headerlink&quot; title=&quot;初识强化学习&quot;&gt;&lt;/a&gt;初识强化学习&lt;/h2&gt;&lt;h3 id=&quot;机器学习分类&quot;&gt;&lt;a href=&quot;#机器学习分类&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Reinforcement Learning" scheme="https://yx1302317313.github.io/categories/Reinforcement-Learning/"/>
    
    
      <category term="AI" scheme="https://yx1302317313.github.io/tags/AI/"/>
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="Python" scheme="https://yx1302317313.github.io/tags/Python/"/>
    
      <category term="Math" scheme="https://yx1302317313.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>傅里叶变换</title>
    <link href="https://yx1302317313.github.io/2020/04/30/fu-li-xie-bian-huan/"/>
    <id>https://yx1302317313.github.io/2020/04/30/fu-li-xie-bian-huan/</id>
    <published>2020-04-30T09:42:45.000Z</published>
    <updated>2020-07-13T04:00:03.009Z</updated>
    
    <content type="html"><![CDATA[<p>傅里叶变换是一种线性积分变换，用于信号在时域和频域之间的变换。由法国学者约瑟夫·傅里叶系统地提出，所以以其名字来命名以示纪念。本文主要讲解傅里叶变换的公式推导和快速傅里叶变换算法的原理及实现。</p><a id="more"></a><p>笔者并没有在课程中学习过傅里叶变换，最初的基础仅仅是高数中讲到的傅里叶级数。由于项目需要，查阅了大量资料自学了傅里叶变换，学习过程中有一些较难理解的地方，而且感觉其中的一些东西容易忘记，于是决定记录下来，以备后患。</p><p><strong>Let’s Go!!!</strong></p><h2 id="傅里叶变换的公式推导"><a href="#傅里叶变换的公式推导" class="headerlink" title="傅里叶变换的公式推导"></a>傅里叶变换的公式推导</h2><h3 id="三角函数的正交性"><a href="#三角函数的正交性" class="headerlink" title="三角函数的正交性"></a>三角函数的正交性</h3><p>傅里叶变换的公式推导需要一些基础性的知识，三角函数的正交性便是其中的关键。</p><p>何为三角函数的正交性？</p><blockquote><p>在线性代数中，向量正交指两个向量内积为0。而三角函数的正交指在三角函数系中，任意两个不同的函数乘积在区间的积分为0。当然这个区间是有限制的，区间大小必须是三角函数周期的整数倍。</p></blockquote><p>例如：</p><ul><li>$\int_{-\pi}^{\pi} sin(nx)cos(mx) = 0$</li><li>$\int_{-\pi}^{\pi} sin(nx)sin(mx) = 0, n \ne m$</li><li>$\int_{-\pi}^{\pi} cos(nx)cos(mx) = 0, n \ne m$</li></ul><p>_上面提到的$m,n$均为整数。_</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>这里需要用到三角函数的积化和差公式：</p><ul><li>$sin(\alpha)cos(\beta) = \frac{1}{2}(sin(\alpha + \beta) + sin(\alpha - \beta))$</li><li>$cos(\alpha)cos(\beta) = \frac{1}{2}(cos(\alpha + \beta) + cos(\alpha - \beta))$</li><li>$sin(\alpha)sin(\beta) = -\frac{1}{2}(cos(\alpha + \beta) - cos(\alpha - \beta))$</li></ul><p>当$m \ne n$时:<br>$$<br>\begin{align}<br>&amp;\int_{-\pi}^{\pi} sin(nx)sin(mx)\\<br>&amp;= \int_{-\pi}^{\pi} (\frac{1}{2}[cos(nx - mx) - cos(nx + mx)]) \\<br>&amp;= \int_{-\pi}^{\pi} \frac{1}{2}cos(n-m)x + \int_{-\pi}^{\pi} \frac{1}{2}cos(m+n)x \\<br>&amp;= 0 \\<br>\end{align}<br>$$</p><p>而当$m = n$时，不满足正交性。</p><p>积分的结果为：</p><ul><li>$\int_{-\pi}^{\pi} sin(nx)sin(nx) = \pi$</li><li>$\int_{-\pi}^{\pi} cos(nx)cos(nx) = \pi$</li></ul><p>这个可以用半角公式证明：<br>$$<br>\begin{align}<br>&amp;\int_{-\pi}^{\pi} sin(nx)sin(nx) dx \\<br>&amp;= \int_{-\pi}^{\pi} \frac{1 - cos(2nx)}{2} dx\\<br>&amp;= \int_{-\pi}^{\pi} \frac{1}{2} + \int_{-\pi}^{\pi} \frac{-cos(2nx)}{2} dx \\<br>&amp;= \pi<br>\end{align}<br>$$</p><h3 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h3><p>OK, 到这里我们既可以说一说傅里叶级数了。What is Fourier series？</p><blockquote><p>傅里叶级数可以用来表示任意一个周期函数。</p></blockquote><p>对于一个周期函数 $f(x) = f(x + T),\ T = \frac{2\pi}{\omega}$，<br>其傅里叶级数为<br>$$f(x) = \frac{a_0}{2} + \Sigma_{n=1}^{\infty}(a_n cos(n\omega x) + b_n sin(n\omega x))$$</p><p>其中</p><ul><li>$a_0 = \frac{2}{T} \int_{0}^{T} f(x) dx$</li><li>$a_n = \frac{2}{T} \int_{0}^{T} f(x) cos(n\omega x) dx$</li><li>$b_n = \frac{2}{T} \int_{0}^{T} f(x) sin(n\omega x) dx$</li></ul><p>至于是怎么推导出来的这里就不说明了（<del>其实我也不知道</del>)。不过可以说一下$a_0, a_n, b_n$三个系数是怎么求出来的。</p><h4 id="系数的求解"><a href="#系数的求解" class="headerlink" title="系数的求解"></a>系数的求解</h4><p>这就用到我们上面提到的三角函数正交性了。</p><p>我们选取周期为$[-\pi, \pi]$<br>$$<br>\begin{align}<br>&amp; f(x) = \frac{a_0}{2} + \Sigma_{n=1}^{\infty}(a_n cos(n\omega x) + b_n sin(n\omega x)) \\<br>&amp; \int_{-\pi}^{\pi} f(x)dx = \int_{-\pi}^{\pi} \frac{a_0}{2} dx + \int_{-\pi}^{\pi} (\Sigma_{n=1}^{\infty}(a_n cos(n\omega x) + b_n sin(n\omega x))) dx \\<br>&amp; \int_{-\pi}^{\pi} f(x)dx = \int_{-\pi}^{\pi} \frac{a_0}{2} dx + \Sigma_{n=1}^{\infty} \int_{-\pi}^{\pi} (a_n cos(n\omega x))dx +  \Sigma_{n=1}^{\infty} \int_{-\pi}^{\pi} (b_n sin(n\omega x)) dx \\<br>&amp; \int_{-\pi}^{\pi} f(x)dx = a_0 \cdot \pi + 0 + 0<br>\end{align}<br>$$</p><p>所以，$a_0 = \frac{1}{\pi} \int_{-\pi}^{\pi} f(x) dx$</p><p>$a_n$的证明稍微麻烦一点,需要一个小小的技巧。</p><p>$$<br>\begin{align}<br>&amp; f(x) = \frac{a_0}{2} + \Sigma_{n=1}^{\infty}(a_n cos(n\omega x) + b_n sin(n\omega x)) \\<br>&amp; f(x)cos(m\omega x) = \frac{a_0}{2}cos(m\omega x) + \Sigma_{n=1}^{\infty}(a_n cos(n\omega x) + b_n sin(n\omega x))cos(m\omega x) \\<br>&amp; \int_{-\pi}^{\pi} f(x)cos(m\omega x)dx = \int_{-\pi}^{\pi} \frac{a_0}{2} cos(m\omega x)dx \\<br>&amp;  + \int_{-\pi}^{\pi} (\Sigma_{n=1}^{\infty}(a_n cos(n\omega x)cos(m\omega x) + b_n sin(n\omega x))) cos(m\omega x)dx \\<br>\end{align}<br>$$</p><p>机智如你，一定想到了为什么要多乘一个$cos(m\omega x)$。对，这样就可以让$a_0, b_n$消失，只剩下我们需要的$a_n$。</p><p>我们继续<br>$$<br>\begin{align}<br>&amp; \int_{-\pi}^{\pi} f(x)cos(m\omega x)dx = 0 + \Sigma_{n=1}^{\infty} \int_{-\pi}^{\pi} (a_n cos(n\omega x) cos(m\omega x))dx + 0\\<br>&amp; \int_{-\pi}^{\pi} f(x)cos(m\omega x)dx = \Sigma_{n=1}^{\infty} \int_{-\pi}^{\pi} (a_n cos(n\omega x) cos(m\omega x))dx\\<br>\end{align}<br>$$</p><p>其实这里的系数$a_n$也只有一个能保留下来，那就是当$m = n$时。</p><p>$$<br>\begin{align}<br>&amp; \int_{-\pi}^{\pi} f(x)cos(m\omega x)dx = \Sigma_{n=1}^{\infty} \int_{-\pi}^{\pi} (a_n cos(n\omega x) cos(m\omega x))dx\\<br>&amp; \int_{-\pi}^{\pi} f(x)cos(n\omega x)dx = a_n \int_{-\pi}^{\pi} (cos(n\omega x) cos(n\omega x))dx\\<br>&amp; \int_{-\pi}^{\pi} f(x)cos(n\omega x)dx = a_n \pi\\<br>\end{align}<br>$$</p><p>可以解得：$a_n = \frac{1}{\pi} \int_{0}^{T} f(x) cos(n\omega x) dx$。$b_n$的求解这里就不进行赘述了，与$a_n$同理。</p><p>将$a_0, a_n, b_n$推广到任意周期，即可得到上面的结果：</p><ul><li>$a_0 = \frac{2}{T} \int_{0}^{T} f(x) dx$</li><li>$a_n = \frac{2}{T} \int_{0}^{T} f(x) cos(n\omega x) dx$</li><li>$b_n = \frac{2}{T} \int_{0}^{T} f(x) sin(n\omega x) dx$</li></ul><h4 id="傅里叶级数的意义"><a href="#傅里叶级数的意义" class="headerlink" title="傅里叶级数的意义"></a>傅里叶级数的意义</h4><p>$$f(x) = \frac{a_0}{2} + \Sigma_{n=1}^{\infty}(a_n cos(n\omega x) + b_n sin(n\omega x))$$</p><p>从这个公式中我们可以看到，一个周期函数可以由一个常函数和无穷多个正弦函数和余弦函数叠加而成。</p><p>其中$n\omega$表示这些正弦函数和余弦函数的角频率是周期函数角频率的整数倍。</p><h3 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h3><blockquote><p>傅里叶变换只能表示周期性函数，但是现实世界中周期性函数很少。那么问题来了，能不能表示非周期函数。答案是可以的，其实非周期性的函数就是一个周期无穷大的函数。</p></blockquote><p>开始之前，仍然需要一个预备知识——欧拉公式(Euler formula)。让我们见识一下这个号称<strong>数学界最美的公式</strong>。</p><p><strong>初见惊为天人，其形也，翩若惊鸿，婉若游龙。荣曜秋菊，华茂春松。</strong></p><p>$$e^{i\theta} = cos\theta + isin\theta$$</p><p><strong>再见则细思恐极。</strong></p><p>当$\theta = \pi$时，$e^{i\pi}  + 1 = 0$，这便是欧拉恒等式。<br>是不是感觉数学中最基本的符号和数字都被包含在这个等式中，一切浑然天成！</p><p>其实吧，我们只想要从中得到下面的两个公式：</p><ul><li>$cos\theta = \frac{1}{2}(e^{i\theta} + e^{-i\theta})$</li><li>$sin\theta = -\frac{1}{2}i(e^{i\theta} - e^{-i\theta})$</li></ul><br><h3 id="傅里叶级数的复指数形式"><a href="#傅里叶级数的复指数形式" class="headerlink" title="傅里叶级数的复指数形式"></a>傅里叶级数的复指数形式</h3><p>将$cos\theta,sin\theta$替换之后，我们便得到了傅里叶级数的复指数形式：<br>$$<br>\begin{align}<br>&amp; f(x) = \frac{a_0}{2} + \Sigma_{n=1}^{\infty}(a_n<br> cos(n\omega x) + b_n sin(n\omega x)) \\<br>&amp;= \frac{a_0}{2} + \Sigma_{n=1}^{\infty}(a_n \frac{1}{2}(e^{in\omega x} + e^{-in\omega x}) - b_n \frac{1}{2}i(e^{in\omega x} - e^{-in\omega x})) \\<br>&amp;= \frac{a_0}{2} + \Sigma_{n=1}^{\infty}a_n \frac{1}{2}(e^{in\omega x} + e^{-in\omega x}) -  \Sigma_{n=1}^{\infty}b_n \frac{1}{2}i(e^{in\omega x} - e^{-in\omega x})) \\<br>&amp;= \frac{a_0}{2} + \Sigma_{n=1}^{\infty} \frac{1}{2}(a_n - b_n i)e^{in\omega x} +  \Sigma_{n=1}^{\infty} \frac{1}{2}(a_n + b_n i)e^{-in\omega x} \\<br>&amp; = \Sigma_{0}^{0} \frac{a_0}{2} e^{i0\omega x} + \Sigma_{n=1}^{\infty} \frac{1}{2}(a_n - b_n i)e^{in\omega x} +  \Sigma_{n=- \infty}^{-1} \frac{1}{2}(a_{-n} + b_{-n} i)e^{in\omega x} \\<br>&amp;= \Sigma_{n=-\infty}^{\infty} C_n e^{in\omega x}<br>\end{align}<br>$$</p><p>其中<br>$$<br>C_n =\left\{<br>\begin{align}<br>&amp; \frac{a_0}{2}, n = 0\\<br>&amp; \frac{1}{2}(a_n - b_n i), n &gt; 0\\<br>&amp; \frac{1}{2}(a_{-n} + b_{-n} i), n&lt;0\\<br>\end{align}<br>\right.<br>$$</p><p>接下来我们求$C_n$.</p><p>我们已知<br>$$<br>\left\{<br>\begin{align}<br>&amp; a_0 = \frac{2}{T} \int_{0}^{T} f(x) dx\\<br>&amp; a_n = \frac{2}{T} \int_{0}^{T} f(x) cos(n\omega x) dx\\<br>&amp; b_n = \frac{2}{T} \int_{0}^{T} f(x) sin(n\omega x) dx\\<br>\end{align}<br>\right.<br>$$</p><ol><li><p>当$n = 0$时<br>$$<br>\begin{align}<br>&amp; C_0 = \frac{a_0}{2} = \frac{1}{T} \int_{0}^{T} f(x) dx\\<br>\end{align}<br>$$</p></li><li><p>当$n &gt; 0$时<br>$$<br>\begin{align}<br>C_n &amp;= \frac{1}{2}(a_n - b_n i)\\<br>&amp;  = \frac{1}{2} \frac{2}{T} \int_{0}^{T} f(x) cos(n\omega x)dx - \frac{1}{2}i\frac{2}{T} \int_{0}^{T} f(x) sin(n\omega x) dx\\<br>&amp;  = \frac{1}{T} \int_{0}^{T} f(x) cos(n\omega x) - i \cdot sin(n\omega x) dx\\<br>&amp;  = \frac{1}{T} \int_{0}^{T} f(x) e^{-in\omega x} dx\\<br>\end{align}<br>$$</p></li><li><p>当$n &lt; 0$时<br>$$<br>\begin{align}<br>C_n &amp;= \frac{1}{2}(a_{-n} + b_{-n} i)\\<br>&amp;  = \frac{1}{2} \frac{2}{T} \int_{0}^{T} f(x) cos(-n\omega x)dx + \frac{1}{2}i\frac{2}{T} \int_{0}^{T} f(x) sin(-n\omega x) dx\\<br>&amp;  = \frac{1}{T} \int_{0}^{T} f(x) cos(-n\omega x) + i \cdot sin(-n\omega x) dx\\<br>&amp;  = \frac{1}{T} \int_{0}^{T} f(x) e^{-in\omega x} dx\\<br>\end{align}<br>$$</p></li></ol><p>咦！$n&gt;0$和$n&lt;0$时，$C_n$居然是一样的，如果$n=0$时也一样那就Prefect了！</p><p>下面是见证奇迹的时刻！<br>$$<br>\begin{align}<br>C_0 &amp;= \frac{1}{T} \int_{0}^{T} f(x) dx\\<br>&amp;  = \frac{1}{T} \int_{0}^{T} f(x) e^{-i0\omega x} dx\\<br>\end{align}<br>$$</p><p>$C_n$的形式居然统一了，$C_n = \frac{1}{T} \int_{0}^{T} f(x) e^{-in\omega x} dx$。</p><br>到此，转换到复指数形式之后，傅里叶级数就看起来简单多了。$$f(x)= \Sigma_{n=-\infty}^{\infty} \frac{1}{T} \int_{0}^{T} f(x) e^{-in\omega x} dx \ e^{in\omega x}$$<h3 id="连续傅里叶变换"><a href="#连续傅里叶变换" class="headerlink" title="连续傅里叶变换"></a>连续傅里叶变换</h3><p>对于非周期函数（可视为周期为无穷的函数）$f(x) = f(x + T), T \to \infty$</p><p>在周期函数中，$\omega  = \frac{2\pi}{T}$ 表示角频率。$n\omega$表示正弦函数和余弦函数的角频率是该周期函数角频率的整数倍。<br><br><br>但是当$T \to \infty$时， $\omega  \to 0$。$n\omega$表示的含义则是$n\omega$变成了一个连续的量（之前是离散的）。</p><p>也就是说非周期函数仍然可以由一个常函数和无穷多个正弦函数和余弦函数叠加而成。但是这些正弦函数和余弦函数的角频率变得特别密集，充斥在整个实数轴上。</p><p>为了表示方便，我们用$\omega$代替$n\omega$。则$T$可以表示为$\frac{\Delta \omega}{2\pi}$</p><p>于是，傅里叶变换的公式就诞生了。真是千呼万唤始出来呀！<br>$$\begin{align}<br>f(x)<br>&amp;= \Sigma_{n=-\infty}^{\infty} \frac{\Delta \omega}{2\pi} \int_{-\infty}^{\infty} f(x) e^{-i\omega x} dx \ e^{i\omega x}\\<br>&amp;= \int_{-\infty}^{\infty} \frac{1}{2\pi}  \int_{-\infty}^{\infty} f(x) e^{-i\omega x} dx \ e^{i\omega x} d\omega\\<br>&amp;= \frac{1}{2\pi} \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(x) e^{-i\omega x} dx \ e^{i\omega x} d\omega\\<br>\end{align}<br>$$</p><p>令$F(\omega) = \int_{-\infty}^{\infty} f(x) e^{-i\omega x} dx$，该式即为傅里叶变换。</p><p>则$f(x) = \frac{1}{2\pi} \int_{-\infty}^{\infty} F(\omega) \ e^{i\omega x} d\omega$，称为傅里叶变换的逆变换 。</p><h4 id="傅里叶变换公式的含义"><a href="#傅里叶变换公式的含义" class="headerlink" title="傅里叶变换公式的含义"></a>傅里叶变换公式的含义</h4><p>一个时域内的函数$f(x)$经过傅里叶变换之后，得到了一个频域内的函数$F(\omega)$。给定一个$\omega$，就可以得到一个$F(\omega)$，$F(\omega)$表示函数$f(x)$在对应频率的振幅。由于$\omega \in (-\infty, \infty)$，所以可以得到无穷多个$F(\omega)$。</p><h4 id="傅里叶变换的逆变换公式的含义"><a href="#傅里叶变换的逆变换公式的含义" class="headerlink" title="傅里叶变换的逆变换公式的含义"></a>傅里叶变换的逆变换公式的含义</h4><p>对得到的无穷多个$F(\omega)$积分由重新得到了原函数$f(x)$。说明了$f(x)$可以由这无穷多个函数叠加而成。这与之前的傅里叶级数表示的意义是相同的。</p><h3 id="离散傅里叶变换（DFT）"><a href="#离散傅里叶变换（DFT）" class="headerlink" title="离散傅里叶变换（DFT）"></a>离散傅里叶变换（DFT）</h3><blockquote><p>由于傅里叶变换经常用于信号的处理，将一个信号拆分成多个正弦信号的叠加。但是由于信号需要使用计算机处理，计算机只能处理离散的数据，所以需要将傅里叶变换离散化。</p></blockquote><p>傅里叶变换中$\omega$是一个连续的量，而实际的信号处理中 $\omega$的值是根据输入信号的采集频率确定的。</p><p>令T表示采样周期，N表示采样次数。对于一个输入为N个点的离散序列$\{x[n]\}, 0 \le n \lt N$</p><p>其离散傅里叶变换为：<br>$$\bar {x}[k] = \Sigma_{n=0}^{N-1} (x[n] \cdot e^{-i\frac{2 \pi n}{N} k})<br>$$</p><p>逆变换为：<br>$$x[n] = \frac{1}{N} \Sigma_{k=0}^{N-1} \bar {x}[k] \cdot e^{i\frac{2\pi k}{N} n}<br>$$</p><p>其中$\frac{2\pi n}{N}$为角频率</p><p>_具体证明比较复杂，此处不进行叙述。_</p><h2 id="快速傅里叶变换原理"><a href="#快速傅里叶变换原理" class="headerlink" title="快速傅里叶变换原理"></a>快速傅里叶变换原理</h2><h2 id="快速傅里叶变换算法实现"><a href="#快速傅里叶变换算法实现" class="headerlink" title="快速傅里叶变换算法实现"></a>快速傅里叶变换算法实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><strong>OK！ Time for bed！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;傅里叶变换是一种线性积分变换，用于信号在时域和频域之间的变换。由法国学者约瑟夫·傅里叶系统地提出，所以以其名字来命名以示纪念。本文主要讲解傅里叶变换的公式推导和快速傅里叶变换算法的原理及实现。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="Math" scheme="https://yx1302317313.github.io/tags/Math/"/>
    
      <category term="信号" scheme="https://yx1302317313.github.io/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>AI 未来[阅读]</title>
    <link href="https://yx1302317313.github.io/2020/04/07/ai-superpowers/"/>
    <id>https://yx1302317313.github.io/2020/04/07/ai-superpowers/</id>
    <published>2020-04-07T06:59:09.000Z</published>
    <updated>2020-06-15T10:39:51.979Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="阅读" scheme="https://yx1302317313.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="AI" scheme="https://yx1302317313.github.io/tags/AI/"/>
    
      <category term="书籍" scheme="https://yx1302317313.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Hough（霍夫）直线检测</title>
    <link href="https://yx1302317313.github.io/2020/03/27/hough-line-detection/"/>
    <id>https://yx1302317313.github.io/2020/03/27/hough-line-detection/</id>
    <published>2020-03-27T01:42:25.000Z</published>
    <updated>2020-06-15T10:53:07.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hough（霍夫）直线检测"><a href="#Hough（霍夫）直线检测" class="headerlink" title="Hough（霍夫）直线检测"></a>Hough（霍夫）直线检测</h2><p><strong>直线检测</strong>：对于边界上有 n 个点的点集,找出共线的点集和直线方程。</p><h2 id="Hough-变换的原理"><a href="#Hough-变换的原理" class="headerlink" title="Hough 变换的原理"></a>Hough 变换的原理</h2><img src="/img/blog/blog-29-3.png" width=500><p>对于直线$y = a*x + b$，从原点做其垂线，如图中的$CD$。如果将其看做极坐标系，则$CD$可以用$(\rho, \theta)$表示。</p><p>怎么表达AB与CD的关系呢？<br><img src="/img/blog/blog-29-4.png" width=500></p><p>任取AB上一点E(x,y),做CD的垂线GH，AB的垂线GI。从而我们可以得到角度关系$\angle{IGE} = \angle {GHC} = \angle{DCB} = \theta$。<br>所以，$CH = y sin\theta, HD = GI = x cos\theta$，从而$CD = CH+HD = xcos\theta + ysin\theta$，即$\rho = xcos\theta + ysin\theta$。可以证明对于直线AB上的任意一点，都满足上式，即$\rho = xcos\theta + ysin\theta$是直线AB的表达式。</p><p>再看$\rho = xcos\theta + ysin\theta$，如果我们固定$x,y$，将$\theta$作为自变量，可以得到一个$\rho - \theta$的一个函数关系式。当$\theta$变化时（CD绕原点旋转时），AB也会随之变化（转动）。由于固定了$x,y$，所以直线AB一定会经过点$（x,y）$，所以它表达了经过点$(x,y)$的<strong>所有直线。</strong></p><p>例如：$\rho = 3cos\theta + 2sin\theta$，曲线上每一个点$(\rho, \theta)$都可以表示一条经过点$(3,2)$的直线。<br><img src="/img/blog/blog-29-5.png" width=500></p><p>下图分别是$\rho = 3cos\theta + 2sin\theta$，$\rho = 2cos\theta + sin\theta$，$\rho = cos\theta$的图像，则分别表示所有经过点$(3,2)$，$(2,1)$，$(1,0)$的所有直线。那么图中的<strong>交点A</strong>表示什么？<br>经过点$(3,2)$，$(2,1)$，$(1,0)$的直线是<strong>同一条线</strong>。Amazing！这不就是说明$(3,2)$，$(2,1)$，$(1,0)$<strong>三点共线</strong>吗，感觉忽然发现了新大陆。<br><img src="/img/blog/blog-29-6.png" width=500></p><p>现在，我们已经找到了证明多个点共线的方法了。让我们重新梳理一下：</p><ol><li>设有一个点集$R$，可得到$R$中任意点$(x_i,y_i)$对应的曲线$\rho_i = x_icos\theta + y_isin\theta$，$\theta \in [0, 2\pi)$。它表示了经过该点的所有直线。</li><li>设$(x_i, y_i),(x_j,y_j) \in R,i \ne j$ ，如果$\rho_i = x_icos\theta + y_isin\theta$与$\rho_j = x_jcos\theta + y_jsin\theta$有交点$A_{ij}(p_{ij}, \theta_{ij}$)，就说明$(x_i, y_i),(x_j,y_j) $两点共线。</li><li>由$A_{ij}(p_{ij}, \theta_{ij})$可得到$(x_i, y_i),(x_j,y_j) $所在的直线$\rho_{ij} = xcos\theta_{ij} + ysin\theta_{ij}$。</li></ol><p>刚才分析的都是基于连续的函数，如果要用算法实现，则需要将其<strong>离散化</strong>。<br>因为$\theta \in [0, 2\pi)$，但是如果用程序实现只能将$\theta$离散化，如令<code>theta = range(0, 360)</code> 取360个离散的值（具体的精度根据实际情况决定）。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ol><li>输入一幅RGB图</li><li>检测图中的边缘，可以使用Canny边缘检测得到一幅<strong>二值图像</strong></li><li>开辟一个二维数组 <code>array</code> ，初始值全部为0，用于存储共线点的个数；确定$\theta$的精度。</li><li>对于每一个边缘点$(x_i,y_i)$，使用公式$\rho_i = x_icos\theta + y_isin\theta$计算每一个$\theta$对应的,将作为数组 <code>array</code> 的索引，将对应的数组元素值加 <code>1</code> 。</li><li>设定一个阈值，过滤出共线点较多的直线（也可以选取共线点最多的几条直线）。</li><li>将检测出的直线绘制到原图上。</li></ol><h2 id="Code-Python"><a href="#Code-Python" class="headerlink" title="Code[Python]"></a>Code[Python]</h2><ul><li>hough_without_canny 中直接使用的是经过Canny检测后的二值图像。</li><li>hough_with_canny 中调用了之前写过的Canny算法。（有时间会把Canny检测的代码也贴出来）</li></ul><p>效果如下：</p><center><img src="/img/blog/blog-29-1.jpg" width=500><p>原图</p></center><br><center><img src="/img/blog/blog-29-2.jpg" width=500><p>直线检测</p></center><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> canny<span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">to_gray</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span>    height<span class="token punctuation">,</span> width<span class="token punctuation">,</span> _ <span class="token operator">=</span> img<span class="token punctuation">.</span>shape    gray <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>height<span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    k <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.299</span><span class="token punctuation">,</span> <span class="token number">0.587</span><span class="token punctuation">,</span> <span class="token number">0.114</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>width<span class="token punctuation">)</span><span class="token punctuation">:</span>            gray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> img<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> gray<span class="token keyword">def</span> <span class="token function">to_rgb</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span>    height<span class="token punctuation">,</span> width <span class="token operator">=</span> img<span class="token punctuation">.</span>shape    rgb <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>height<span class="token punctuation">,</span> width<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>width<span class="token punctuation">)</span><span class="token punctuation">:</span>            rgb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>img<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>    <span class="token keyword">return</span> rgb<span class="token keyword">def</span> <span class="token function">plot_line</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> expression<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">or</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The image shape must be (height, width, 3)'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> img    height <span class="token operator">=</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    width <span class="token operator">=</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> int<span class="token punctuation">(</span>a <span class="token operator">*</span> x <span class="token operator">+</span> b<span class="token punctuation">)</span>    <span class="token keyword">for</span> exp <span class="token keyword">in</span> expression<span class="token punctuation">:</span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> exp        point <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> func<span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>width<span class="token punctuation">)</span>                 <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> func<span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;</span> height<span class="token punctuation">]</span>        <span class="token keyword">for</span> x<span class="token punctuation">,</span> y <span class="token keyword">in</span> point<span class="token punctuation">:</span>            img<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> img<span class="token keyword">def</span> <span class="token function">hough_check</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> precision<span class="token operator">=</span><span class="token number">360</span><span class="token punctuation">,</span> threshold<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span> number<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    height<span class="token punctuation">,</span> width <span class="token operator">=</span> img<span class="token punctuation">.</span>shape    theta <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> precision<span class="token punctuation">)</span>    factor <span class="token operator">=</span> <span class="token number">360</span> <span class="token operator">/</span> precision    tab_height <span class="token operator">=</span> len<span class="token punctuation">(</span>theta<span class="token punctuation">)</span>    tab_width <span class="token operator">=</span> <span class="token punctuation">(</span>height <span class="token operator">+</span> width<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span>    tab <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> tab_width <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>tab_height<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>width<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> img<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">255</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> theta<span class="token punctuation">:</span>                    arc <span class="token operator">=</span> k <span class="token operator">*</span> factor <span class="token operator">*</span> math<span class="token punctuation">.</span>pi <span class="token operator">/</span> <span class="token number">180</span>                    rho <span class="token operator">=</span> int<span class="token punctuation">(</span>j <span class="token operator">*</span> math<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>arc<span class="token punctuation">)</span> <span class="token operator">+</span> i <span class="token operator">*</span> math<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>arc<span class="token punctuation">)</span><span class="token punctuation">)</span>                    tab<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>rho <span class="token operator">+</span> height <span class="token operator">+</span> width<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    line <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>tab_height<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>tab_width<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> threshold<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># append theta (0-360) and rho to line</span>                line<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">*</span> factor<span class="token punctuation">,</span> j <span class="token operator">-</span> height <span class="token operator">-</span> width<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> number <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> number<span class="token punctuation">:</span>        <span class="token keyword">return</span> line    <span class="token keyword">else</span><span class="token punctuation">:</span>        line<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> tab<span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> factor<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> height <span class="token operator">+</span> width<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>number<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">get_expression</span><span class="token punctuation">(</span>pair<span class="token punctuation">)</span><span class="token punctuation">:</span>    theta<span class="token punctuation">,</span> rho <span class="token operator">=</span> pair    theta <span class="token operator">=</span> theta <span class="token operator">*</span> math<span class="token punctuation">.</span>pi <span class="token operator">/</span> <span class="token number">180</span>    k <span class="token operator">=</span> <span class="token operator">-</span>math<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>theta<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>math<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>theta<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span>    b <span class="token operator">=</span> rho <span class="token operator">/</span> <span class="token punctuation">(</span>math<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>theta<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> k<span class="token punctuation">,</span> b<span class="token keyword">def</span> <span class="token function">hough_with_canny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    filename <span class="token operator">=</span> <span class="token string">'hf.jpg'</span>    rgb_img <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>    gray_img <span class="token operator">=</span> rgb_img<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">'L'</span><span class="token punctuation">)</span>    gray_array <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>gray_img<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># img = to_gray(img_array)</span>    gray_array <span class="token operator">=</span> canny<span class="token punctuation">.</span>canny<span class="token punctuation">(</span>gray_array<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    line <span class="token operator">=</span> hough_check<span class="token punctuation">(</span>gray_array<span class="token punctuation">,</span> number<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The number of lines is {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>len<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    expression <span class="token operator">=</span> <span class="token punctuation">[</span>get_expression<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> line<span class="token punctuation">]</span>    rgb_array <span class="token operator">=</span> to_rgb<span class="token punctuation">(</span>gray_array<span class="token punctuation">)</span>    rgb_array <span class="token operator">=</span> plot_line<span class="token punctuation">(</span>rgb_array<span class="token punctuation">,</span> expression<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>rgb_array<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">hough_without_canny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    filename <span class="token operator">=</span> <span class="token string">'gray.jpg'</span>    rgb_img <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>    gray_img <span class="token operator">=</span> rgb_img<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">'L'</span><span class="token punctuation">)</span>    gray_array <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>gray_img<span class="token punctuation">)</span>    rgb_array <span class="token operator">=</span> to_rgb<span class="token punctuation">(</span>gray_array<span class="token punctuation">)</span>    line <span class="token operator">=</span> hough_check<span class="token punctuation">(</span>gray_array<span class="token punctuation">,</span> number<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The number of lines is {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>len<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    expression <span class="token operator">=</span> <span class="token punctuation">[</span>get_expression<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> line<span class="token punctuation">]</span>    rgb_array <span class="token operator">=</span> plot_line<span class="token punctuation">(</span>rgb_array<span class="token punctuation">,</span> expression<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>rgb_array<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># main()</span>    hough_without_canny<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hough（霍夫）直线检测&quot;&gt;&lt;a href=&quot;#Hough（霍夫）直线检测&quot; class=&quot;headerlink&quot; title=&quot;Hough（霍夫）直线检测&quot;&gt;&lt;/a&gt;Hough（霍夫）直线检测&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;直线检测&lt;/strong&gt;：对于边界
      
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="数字图像处理" scheme="https://yx1302317313.github.io/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Math" scheme="https://yx1302317313.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>HSV和HSL色彩模型</title>
    <link href="https://yx1302317313.github.io/2020/03/23/hsv-he-hsl-se-cai-mo-xing/"/>
    <id>https://yx1302317313.github.io/2020/03/23/hsv-he-hsl-se-cai-mo-xing/</id>
    <published>2020-03-23T09:21:21.000Z</published>
    <updated>2020-06-23T10:48:48.142Z</updated>
    
    <content type="html"><![CDATA[<p>在数字图像处理中，有很多颜色模型，比如最常见的RGB，还有HSV和HSL等。这篇博客主要讲述一下HSV和HSL色彩模型。</p><a id="more"></a><h2 id="为什么使用HSV和HSL"><a href="#为什么使用HSV和HSL" class="headerlink" title="为什么使用HSV和HSL"></a>为什么使用HSV和HSL</h2><p>HSV和HSL都是一种将RGB色彩模型中的点表示在圆柱坐标系中。这两种表示法试图做到比基于笛卡尔坐标系的几何结构RGB更加直观。</p><p>先看一下我们最熟悉的RGB色彩模型。</p><p>RGB色彩模型是通过R（红）、G（绿）、B（蓝）三种颜色混合表示其他颜色。根据物理学上的三原色原理，三种原色可以按比例混合出任意一种光色。而RGB就是一种三原色（三原色之间是相互独立的，任何一种光色都不能由其余的两种光色来组成）。</p><p>RGB很适合通过硬件实现，但是不适合人眼分辨。因为任意一种颜色的形成都是有R、G、B三个通道共同决定的，想要调整颜色，需要调整R、G、B三个通道。</p><h2 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h2><h3 id="HSV色彩模型"><a href="#HSV色彩模型" class="headerlink" title="HSV色彩模型"></a>HSV色彩模型</h3><p>HSV是指Hue、Saturation和Value。</p><ul><li>Hue：色调，是色彩的基本属性，就是平常所说的颜色，如红色、黄色等</li><li>Saturation：饱和度，色彩的纯度，越高色彩越纯，低则逐渐变灰。</li><li>Value：明度，色彩的亮度</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h3 id="RGB-to-HSV"><a href="#RGB-to-HSV" class="headerlink" title="RGB to HSV"></a>RGB to HSV</h3><h3 id="HSV-to-RGB"><a href="#HSV-to-RGB" class="headerlink" title="HSV to RGB"></a>HSV to RGB</h3><h2 id="HSL"><a href="#HSL" class="headerlink" title="HSL"></a>HSL</h2><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li><a href="https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4</a></li><li><a href="https://zhuanlan.zhihu.com/p/67930839" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/67930839</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在数字图像处理中，有很多颜色模型，比如最常见的RGB，还有HSV和HSL等。这篇博客主要讲述一下HSV和HSL色彩模型。&lt;/p&gt;
    
    </summary>
    
      <category term="CV" scheme="https://yx1302317313.github.io/categories/CV/"/>
    
    
      <category term="Opencv" scheme="https://yx1302317313.github.io/tags/Opencv/"/>
    
      <category term="数字图像处理" scheme="https://yx1302317313.github.io/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>书单</title>
    <link href="https://yx1302317313.github.io/2020/03/05/reading-list/"/>
    <id>https://yx1302317313.github.io/2020/03/05/reading-list/</id>
    <published>2020-03-05T06:23:57.000Z</published>
    <updated>2020-06-15T10:44:03.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在读"><a href="#在读" class="headerlink" title="在读"></a>在读</h3><ul><li>经济学原理-微观经济学</li><li>北欧神话</li><li>浩荡两千年</li><li>人月神话</li></ul><h3 id="经济类"><a href="#经济类" class="headerlink" title="经济类"></a>经济类</h3><ul><li><input disabled="" type="checkbox"> 经济学原理-微观经济学</li><li><input disabled="" type="checkbox"> 经济学原理-宏观经济学</li><li><input disabled="" type="checkbox"> 浩荡两千年</li><li><input disabled="" type="checkbox"> 跌荡一百年</li><li><input disabled="" type="checkbox"> 激荡三十年</li></ul><h3 id="计算机类"><a href="#计算机类" class="headerlink" title="计算机类"></a>计算机类</h3><ul><li><input disabled="" type="checkbox"> 人月神话</li><li><input disabled="" type="checkbox"> 摩托车维修艺术</li><li><input disabled="" type="checkbox"> 设计模式之禅</li><li><input checked="" disabled="" type="checkbox"> 浪潮之巅</li><li><input checked="" disabled="" type="checkbox"> AI未来</li><li><input disabled="" type="checkbox"> 软件估算</li><li><input disabled="" type="checkbox"> 一本书读懂互联网思维</li><li><input disabled="" type="checkbox"> 集成测试框架</li></ul><h3 id="历史类"><a href="#历史类" class="headerlink" title="历史类"></a>历史类</h3><ul><li><input checked="" disabled="" type="checkbox"> 明朝那些事儿</li><li><input disabled="" type="checkbox"> 易中天中华史</li><li><input checked="" disabled="" type="checkbox"> 血腥的盛唐</li><li><input checked="" disabled="" type="checkbox"> 被封印的唐史</li><li><input checked="" disabled="" type="checkbox"> 两宋风云</li></ul><h3 id="科幻类"><a href="#科幻类" class="headerlink" title="科幻类"></a>科幻类</h3><ul><li><input checked="" disabled="" type="checkbox"> 三体</li><li><input checked="" disabled="" type="checkbox"> 球状闪电</li><li><input checked="" disabled="" type="checkbox"> 乡村教师</li><li><input checked="" disabled="" type="checkbox"> 白垩纪往事</li><li><input disabled="" type="checkbox"> 流浪地球</li></ul><h3 id="文学类"><a href="#文学类" class="headerlink" title="文学类"></a>文学类</h3><ul><li><input checked="" disabled="" type="checkbox"> 百年孤独</li><li><input checked="" disabled="" type="checkbox"> 白夜行</li><li><input checked="" disabled="" type="checkbox"> 流星之绊</li><li><input checked="" disabled="" type="checkbox"> 解忧杂货店</li><li><input checked="" disabled="" type="checkbox"> 迷宫中的将军</li><li><input disabled="" type="checkbox"> 北欧神话</li><li><input checked="" disabled="" type="checkbox"> 小李飞刀-多情剑客无情剑</li><li><input checked="" disabled="" type="checkbox"> 追风筝的人</li></ul><h3 id="传记"><a href="#传记" class="headerlink" title="传记"></a>传记</h3><ul><li><input checked="" disabled="" type="checkbox"> 特斯拉传</li><li><input checked="" disabled="" type="checkbox"> 世界因我而不同</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><input checked="" disabled="" type="checkbox"> 白说</li><li><input disabled="" type="checkbox"> 黑天鹅</li><li><input disabled="" type="checkbox"> 灰犀牛</li><li><input disabled="" type="checkbox"> …</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在读&quot;&gt;&lt;a href=&quot;#在读&quot; class=&quot;headerlink&quot; title=&quot;在读&quot;&gt;&lt;/a&gt;在读&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;经济学原理-微观经济学&lt;/li&gt;
&lt;li&gt;北欧神话&lt;/li&gt;
&lt;li&gt;浩荡两千年&lt;/li&gt;
&lt;li&gt;人月神话&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="阅读" scheme="https://yx1302317313.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="书籍" scheme="https://yx1302317313.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce-翻译</title>
    <link href="https://yx1302317313.github.io/2020/03/01/google-mapreduce/"/>
    <id>https://yx1302317313.github.io/2020/03/01/google-mapreduce/</id>
    <published>2020-03-01T13:18:35.000Z</published>
    <updated>2020-06-15T10:52:39.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>MapReduce是一个编程模型，是一个与处理和生成大数据集相关的实现。用户指定一个处理<code>键值对</code>的  _Map_ 函数生成一个中间<code>键值对</code>的集合，指定一个 _Reduce_ 函数来合并有相同中间<code>键</code>的所有中间<code>值</code>。许多现实中的任务都可以用这种模型表达，像这篇论文中所展示的一样。 </p><p>用这种函数风格写成的程序可以自动在大型商用机器集群上并行化执行。这个运行时系统负责分割输入数据的细节，调度程序在机器集群上执行，处理机器的错误和管理请求的内部机器通信。这样允许没有任何并行化和分布式系统经验的程序员可以轻松地利用大型分布式系统的资源。</p><p>我们实现的MapReduce运行在大型商业机器集群上并且是高度可拓展的：一个典型的MapReduce计算在数以千计的机器上处理许多兆兆字节（2^40字节）的数据。程序员发现这个系统使用起来是简单的：数以百计的MapReduce程序已经被实现，每天高达一千多个MapReduce工作正在Google的集群上执行。</p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>在过去的五年里，作者和许多在Google工作的其他人实现了数百种有专用目的的计算，用来处理大量原始数据，例如爬取的文档，网络请求日志等等，计算多种多样的派生数据，例如反向索引，网页文档图结构的各种表示方式，爬取主机的页数摘要，在给定一天的最频繁查询集合等等。大多数此类计算在概念上是简单明了的。但是输入数据通常是巨大的，为了在合理的时间内完成计算必须分布在成百上千个机器上。怎样并行化计算，分布数据和处理错误这些问题共同困扰了原先使用大量复杂代码处理这些问题的简单计算。</p><p>为了应对这种复杂性，我们设计了一个新的抽象概念允许我们表达试图执行的简单计算，但是我们在库中隐藏了并行化，容错，数据分布和负载平衡的复杂细节。我们的抽象概念的灵感来源于当前在 _Lisp_ 和许多其他函数式语言中的 _Map_ 和 _Reduce_ 原函数。我们意识到大多数我们的计算涉及到对输入数据的每一个逻辑“记录”应用一个 _Map_ 操作来计算一组中间<code>键值对</code>，然后对共享同一个键的所有值应用一个 _Reduce_ 操作适当地合并派生的数据。我们使用具有用户指定的 _Map_ 和 _Reduce_ 操作的函数模型，使我们方便地并行化进行大型计算，我们使用重新计算作为容错的主要机制。</p><p>这项工作的主要贡献是一个简单而又强大的接口，该接口能够自动实现大规模计算的并行化和分布，并且该接口的是实现在大型商业计算机集群上达到高性能。</p><p>第2节描述了基本的编程模型并且给出了若干实例。第3节 描述了为我们基于集群计算环境定制的MapReduce接口的实现。第4节描述了我们发现有用的对编程模型的一些改进。第5节对大量任务的实现进行了性能度量。第6节探索了MapReduce在Google的应用，包括我们将其作为重写产品索引系统的基础的经历。第7节讨论了与其相关的和未来的工作。</p><h2 id="2-编程模型"><a href="#2-编程模型" class="headerlink" title="2 编程模型"></a>2 编程模型</h2><p>计算会获取一个输入<code>键值对</code>集合，然后产生一个输出<code>键值对</code>集合。MapReduce库的用户通过两个函数：_Map_ 和 _Reduce_ 来表达计算。</p><p>由用户编写的 _Map_ 函数获取一个输入对，产生一个中间键值对集合。MapReduce库将具有相同中间键 _I_ 的中间值分成一组，然后把它们传递给 _Reduce_ 函数。</p><p> _Reduce_ 函数同样由用户编写，接受一个中间键 _I_ 和一个与该键对应的中间值集合。它将这些值合并起来形成一个可能更小的值的集合。通常每一次 _Reduce_ 调用仅仅产生零或一个输出值。中间值通过一个迭代器被提供给用户的reduce函数。这样允许我们处理太大而不能放入内存的值列表。</p><h3 id="2-1-实例"><a href="#2-1-实例" class="headerlink" title="2.1 实例"></a>2.1 实例</h3><p>考虑统计大量文档中每个单词出现次数的问题。用户需要编写类似于下面伪码的代码：</p><pre class=" language-python"><code class="language-python">map<span class="token punctuation">(</span>String key<span class="token punctuation">,</span> String value<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> key<span class="token punctuation">:</span> document name    <span class="token operator">//</span> value<span class="token punctuation">:</span> document contents    <span class="token keyword">for</span> each word w <span class="token keyword">in</span> value<span class="token punctuation">:</span>        EmitIntermediate<span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> reduce<span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Iterator values<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> key<span class="token punctuation">:</span> a word    <span class="token operator">//</span> values<span class="token punctuation">:</span> a list of counts    int result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> each v <span class="token keyword">in</span> values<span class="token punctuation">:</span>        result <span class="token operator">+=</span> ParseInt<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        Emit<span class="token punctuation">(</span>AsString<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>_map_ 函数发出（emit）每个单词加上一个相关的出现次数（在这个简单的例子中仅仅是“1”）。_reduce_ 函数将每一个特定单词的所有发出的（emited）次数加在一起。</p><p>另外，用户需要编写代码用输入，输出文件的文件名和额外的调整参数填充 _mapreduce_ 规范对象。用户然后调用 _MapRedece_ 函数，将这个规范的对象传递给它。用户代码会被MapReduce库（用C++实现的）链接到一起。附录A包含了这个例子的所有程序文本。</p><h3 id="2-2-类型"><a href="#2-2-类型" class="headerlink" title="2.2 类型"></a>2.2 类型</h3><p>尽管之前的伪码是根据字符串输入输出编写的，但是概念上用户提供的map和reduce函数具有相关的类型：</p><pre><code>map (k1, v1) -&gt; list(k2, v2)reduce (k2, list(v2)) -&gt; list(v2)</code></pre><p>也就是说，输入键和值从不同于输出键和值的域中提取。另外，中间键和值与输出键和值来自同一个域。</p><p>我们的C++实现向用户定义的函数传递字符串，而从字符串转换为合适的类型留给用户定义的代码实现。</p><h3 id="2-3-更多实例"><a href="#2-3-更多实例" class="headerlink" title="2.3 更多实例"></a>2.3 更多实例</h3><p>这里有一些有趣而又简单的例子，这些例子能够轻易的表达成MapReduce计算。</p><p><strong>Distributed Grep:</strong> 如果与提供的模式匹配，map函数会发出（emit）一行文本。reduce函数是一个identity函数，它仅仅将提供的中间数据复制到输出。</p><p>_译者注：grep是Linux的一个命令，该命令会根据给定的模式查找文本中匹配的部分，如果匹配会输出所在行。_</p><p><strong>Count of URL Access Frequency:</strong> map函数处理网页请求日志，输出 _&lt;URL, 1&gt;_ 。reduce函数将来自相同URL的值加在一起并且发出（emit）一个 _&lt;URL, total count&gt;_ 键值对。</p><p><strong>Reverse Web-Link Graph:</strong> map函数为在名为 _source_ 的网页中找到的所以指向 _target_ URL的每一个链接输出 _&lt;target, source&gt;_ 键值对。reduce函数将与给定的目标URL有关的所有源URL列表连接起来，发出（emit）键值对： _&lt;target, list(source)&gt;_</p><p><strong>Term-Vector per Host:</strong> 术语向量（term vector）将出现在一个文档或者一组文档中最重要的单词概括为 _&lt;words, frequence&gt;_ 键值对。map函数为每一个输入文档发出（emit）一个 _&lt;hostname, term vector&gt;_ 键值对（主机名从文档的URL中提取）。将给定主机所有文档的术语向量传递给reduce函数。它把这些术语向量加在一起，去掉不常出现的属于，然后发出（emit）一个最终的 _&lt;hostnamem, term vetor&gt;_ 键值对。</p><p><strong>Inverted Index:</strong> map函数解析每一个文档，然后发出（emit）_&lt;word, document ID&gt;_ 键值对序列。reduce函数接收给定单词的所有键值对，根据文档ID排序，之后发出（emit）一个 _&lt;word, list(document ID)&gt;_ 键值对。所有输出键值对构成的集合形成了一个简单的反向索引。这样很容易拓展计算来跟踪每个单词的位置。</p><p><strong>Distributed Sort:</strong> map函数从每个记录中提取键，然后发出（emit）一个 _&lt;key, record&gt;_ 键值对。reduce函数发出（emit）没有变化的全部键值对。这个计算依赖于在4.1节描述的隔离设施和在4.2节描述的可排序属性。</p><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3 实现"></a>3 实现</h2><p>MapReduce接口可能有多种不同的实现方式。正确的选择依赖于环境。例如，一种实现可能适合小型共享内存机器，另一种适合大型的NUMA多处理器，另一种适合更大的网络计算机集群。本节描述了一个针对Google广泛使用的计算环境：通过交换以太网连接在一起的大型商用计算机集群的实现。在我们的环境中：</p><ol><li>机器通常是运行Linux系统的双X86处理器，每台有2-4G内存。</li><li>使用的是商用网络硬件，在机器级别上通常是100M/s或者是1G/s，但是平均考虑下来要少于一半的带宽。</li><li>一个集群包含成百上千台机器，因此机器故障是很常见的。</li><li>存储使用的是廉价的IDE磁盘，这些磁盘与单独的机器直接相连。使用内部开发的分布式文件系统管理存储在这些磁盘上的数据。文件系统使用拷贝的方式在不可靠的硬件之上提供实用性和可靠性。</li><li>用户提交作业到一个调度系统。每个作业由一系列任务组成，作业被调度器映射到集群内一系列可使用的机器上。</li></ol><br><h3 id="3-1-执行概述"><a href="#3-1-执行概述" class="headerlink" title="3.1 执行概述"></a>3.1 执行概述</h3><center><img src="/img/blog/blog-28-1.png"></center><p>通过自动地将输入数据分割成 _M_ 份，_Map_ 函数的调用被分布在多台机器上。分割后的输入数据可以被不同的机器并行处理。使用分割函数（例如： _hash(key) mod R_）将中间键分成 _R_ 份, _Reduce_ 函数的调用也被分布化。分割的份数（ _R_ ）和分割函数由用户指定。</p><p>图1展示了我们实现的MapReduce操作的全部流程。当用户程序调用MapReduce函数时，会发生以下一系列动作（图1中的数字标签对应下面列表中的编号）：</p><ol><li>用户程序中的MapReduce库首先将输入文件分成M份，通常每份是16MB或者64MB（用户可以通过一个可选参数控制）。然后在机器集群上启动多个程序副本。</li><li>这些程序副本当中有一个是特殊的——master。其余的是被master分配任务的worker。这里分配了 _M_ 个map任务和 _R_ 个reduce任务。管理程序找出空闲的worker然后给它分配一个map任务或者reduce任务。</li><li>被分配了map任务的worker从相应的输入文件中读取内容。它从输入数据中解析出键值对，将每一个键值对传递给用户定义的 _Map_ 函数。_Map_ 函数生成中间键值对并缓冲在内存中。</li><li>缓冲的键值对被周期性地写入本地磁盘，然后被分割程序分割成 _R_ 份。这些在本地磁盘上缓冲的键值对的位置被传回master，master负责将这些位置向前传递给reduce worker。</li><li>当reduce worker被master告知中间键值对的位置时，它使用远程调用读取在map worker的磁盘上缓冲的数据。当reduce worker读取了全部的中间数据后，它通过中间键对读取数据排序，因此所有有相同键的数据被分成了一组。排序是必须的，因为通常会有许多不同的键映射到同一个reduce任务。如果中间数据的数量太大而不能装入内存，此时使用外部排序。</li><li>reduce worker遍历已排序的中间数据，对于遇到的每个唯一的中间键，它将键和相应的中间值集合传递给用户的reduce函数。_Reduce_ 函数的输出被附加到这个reduce分区的输出文件中。 </li><li>当所有的map任务和reduce任务完成时，master唤醒用户程序。这时候，用户程序从MapReduce调用返回到用户代码中。</li></ol><p>在顺利完成后，mapreduce执行结果保存在 _R_ 个输出文件中(每一个reduce任务有一个输出文件，文件名由用户指定)。通常，用户不需要将这_R_ 个输出文件合并成一个文件——他们通常将这些文件作为另一个MapReduce调用的输入，或者在另一个分布式应用中使用它们，这个分布式应用能够处理被分成多个文件的输入。</p><h3 id="3-2-Master-数据结构"><a href="#3-2-Master-数据结构" class="headerlink" title="3.2 Master 数据结构"></a>3.2 Master 数据结构</h3><p>master保存多个数据结构。对于每一个map任务和reduce任务，它存储它们的状态（空闲，正在处理，已经完成）和worker机器的身份（对于非空闲任务）。（译者注：所谓的身份指的是该计算机运行的是map任务还是reduce任务）</p><p>master是一个将中间文件区的位置从map任务传输到reduce任务的管道。因此，对于每一个已经完成的map任务，master存储了由该map任务处理的 _R_ 个中间文件区的位置和大小。当map任务完成时，接收位置和大小信息的更新。这些信息以增量的方式推送到正在处理reduce任务的worker。</p><h3 id="3-3-容错性"><a href="#3-3-容错性" class="headerlink" title="3.3 容错性"></a>3.3 容错性</h3><p>因为MapReduce库的设计目的是帮助使用成百上千的机器处理大量数据，因此MapReduce库必须优雅地容忍机器故障。</p><h4 id="Worker-故障"><a href="#Worker-故障" class="headerlink" title="Worker 故障"></a>Worker 故障</h4><p>master会定期的ping（译者注：向计算机发送信号等待回复测试是否连通互联网）每一个worker。如果在一定时间内没有收到worker的响应，master会将该worker标记为故障。任何由worker完成的map任务都会被重置为初始的空闲状态，然后可以被其他worker调度。同样地，任何在故障的worker上处理的map和reduce任务也会被重置为空闲状态，变得可以被调度。</p><p>发生故障时已经完成的map任务会重新执行，因为它们的输出存储在故障机器的本地磁盘上，所以不能访问。已经完成的reduce任务不必重新执行，因为它们的输出存储在全局文件系统。</p><p>当map任务被一个worker A首次执行，之后又被worker B执行（因为A失败了）时，所有正在执行reduce任务的worker被通知重新执行。任何还没有从worker A读取数据的reduce任务将会从worker B读取数据。</p><p>MapReduce对于大规模worker故障具有弹性。例如，在MapReduce操作过程中，正在运行的集群的网络维护导致了80台机器在数分钟之内无法访问。MapReduce master简单地重新执行被这些不可访问的机器完成的工作，继续向前处理，最终完成MapReduce操作。</p><h4 id="Master-故障"><a href="#Master-故障" class="headerlink" title="Master 故障"></a>Master 故障</h4><p>很容易使master写入上面描述的master数据结构的周期性检查点。如果master任务失败了，可以从上一次检查点状态启动一个新的备份。然而，鉴于只有一个master，它不太可能出现故障。因此，如果master故障了，我们当前的实现会终止MapReduce计算。用户可以检查状态，如果愿意可以重新尝试MapReduce操作。</p><h4 id="表示故障的语义"><a href="#表示故障的语义" class="headerlink" title="表示故障的语义"></a>表示故障的语义</h4><p>当用户提供的map和reduce操作对于他们输入的值是确定性的函数，我们的分布式实现会产生和整个程序无错串行执行相同的结果。</p><p>我们依赖于map、reduce任务输出的原子性提交来实现这一特性。每一个正在处理的任务将它的输出写到私有临时文件。reduce任务会产生一个这样的文件，map任务会产生 $R$ 个这样的文件（每个reduce任务一个）。当一个map任务完成时，worker发送一条消息给master，在这个消息包括了这 $R$ 个临时文件的文件名。如果master接收到已经完成的map任务发来的一条完成消息，它会忽略这条消息。否则，它在master数据结构中记录这 $R$ 个文件的文件名。</p><p>当一个reduce任务完成时，reducer worker自动将它的临时输出文件重命名为最终输出文件名。如果同一个reduce任务在多个机器上被执行，那么将对同一个最终输出文件执行多次重命名操作。我们依赖于由底层文件系统提供的原子性重命名操作，来保证最终文件系统状态仅包含reduce任务的一个执行结果产生的数据。</p><p>我们绝大多数的map和reduce操作是确定性的，在这种情况下我们的语义与顺序执行是等价的，这使得程序员推理程序的行为非常容易。当map和reduce操作是非确定的，我们提供弱化但仍然可推理的语义。在非确定操作中会出现，一个特定reduce任务 $R_1$ 的输出等价于非确定程序一种串行执行产生的$R_1$的输出。但是另外一个不同的reduce任务$R_2$的输出可能与非确定程序另外一种不同的串行执行产生的$R_2$的输出相对应。</p><p>考虑map任务$M$和reduce任务$R_1$和$R_2$。令$e(R_i)$表示已经提交的$R_i$的执行结果（准确的说只有一个执行结果）。弱化的语义产生了，因为$e(R_1)$可能读取了任务$M$的一个执行产生的输出，$e(R_2)$可能读取了任务$M$另外一个不同的执行产生的输出。</p><h3 id="3-4-局部性"><a href="#3-4-局部性" class="headerlink" title="3.4 局部性"></a>3.4 局部性</h3><p>在我们的计算环境中，网络带宽是一个相对紧缺的资源。我们通过利用输入数据保存在组成集群的机器的本地磁盘上的优势来节约网络带宽。</p><h3 id="3-5-任务粒度"><a href="#3-5-任务粒度" class="headerlink" title="3.5 任务粒度"></a>3.5 任务粒度</h3><h3 id="3-6-备份任务"><a href="#3-6-备份任务" class="headerlink" title="3.6 备份任务"></a>3.6 备份任务</h3><h2 id="4-改进"><a href="#4-改进" class="headerlink" title="4 改进"></a>4 改进</h2><h3 id="4-1-分割函数"><a href="#4-1-分割函数" class="headerlink" title="4.1 分割函数"></a>4.1 分割函数</h3><h3 id="4-2-有序保证"><a href="#4-2-有序保证" class="headerlink" title="4.2 有序保证"></a>4.2 有序保证</h3><h3 id="4-3-合并函数"><a href="#4-3-合并函数" class="headerlink" title="4.3 合并函数"></a>4.3 合并函数</h3><h3 id="4-4-输入输出类型"><a href="#4-4-输入输出类型" class="headerlink" title="4.4 输入输出类型"></a>4.4 输入输出类型</h3><h3 id="4-5-副作用"><a href="#4-5-副作用" class="headerlink" title="4.5 副作用"></a>4.5 副作用</h3><h3 id="4-6-跳过糟糕的记录"><a href="#4-6-跳过糟糕的记录" class="headerlink" title="4.6 跳过糟糕的记录"></a>4.6 跳过糟糕的记录</h3><h3 id="4-7-局部执行"><a href="#4-7-局部执行" class="headerlink" title="4.7 局部执行"></a>4.7 局部执行</h3><h3 id="4-8-状态信息"><a href="#4-8-状态信息" class="headerlink" title="4.8 状态信息"></a>4.8 状态信息</h3><h3 id="4-9-计数器"><a href="#4-9-计数器" class="headerlink" title="4.9 计数器"></a>4.9 计数器</h3><h2 id="5-性能"><a href="#5-性能" class="headerlink" title="5 性能"></a>5 性能</h2><h3 id="5-1-集群配置"><a href="#5-1-集群配置" class="headerlink" title="5.1 集群配置"></a>5.1 集群配置</h3><h3 id="5-2-Grep"><a href="#5-2-Grep" class="headerlink" title="5.2 Grep"></a>5.2 Grep</h3><h3 id="5-3-排序"><a href="#5-3-排序" class="headerlink" title="5.3 排序"></a>5.3 排序</h3><h3 id="5-4-备份任务的作用"><a href="#5-4-备份任务的作用" class="headerlink" title="5.4 备份任务的作用"></a>5.4 备份任务的作用</h3><h3 id="5-5-机器故障"><a href="#5-5-机器故障" class="headerlink" title="5.5 机器故障"></a>5.5 机器故障</h3><h2 id="6-实验"><a href="#6-实验" class="headerlink" title="6 实验"></a>6 实验</h2><h3 id="6-1-大规模索引"><a href="#6-1-大规模索引" class="headerlink" title="6.1 大规模索引"></a>6.1 大规模索引</h3><h2 id="7-相关工作"><a href="#7-相关工作" class="headerlink" title="7 相关工作"></a>7 相关工作</h2><h2 id="8-结论"><a href="#8-结论" class="headerlink" title="8 结论"></a>8 结论</h2><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>致谢请查阅原论文，此处不做翻译。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>参考文献请查阅原论文。</p><h3 id="A-单词频率"><a href="#A-单词频率" class="headerlink" title="A 单词频率"></a>A 单词频率</h3><p>本节包含了一个程序，该程序统计了通过命令行指定的文件集合中的每一个单词的出现次数。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"mapreduce/mapreduce.h"</span></span><span class="token comment" spellcheck="true">// User’s map function</span><span class="token keyword">class</span> <span class="token class-name">WordCounter</span> <span class="token operator">:</span> <span class="token keyword">public</span> Mapper <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Map</span><span class="token punctuation">(</span><span class="token keyword">const</span> MapInput<span class="token operator">&amp;</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> string<span class="token operator">&amp;</span> text <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Skip past leading whitespace</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isspace</span><span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Find word end</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isspace</span><span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> i<span class="token punctuation">)</span>            <span class="token function">Emit</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>i<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">REGISTER_MAPPER</span><span class="token punctuation">(</span>WordCounter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// User’s reduce function</span><span class="token keyword">class</span> <span class="token class-name">Adder</span> <span class="token operator">:</span> <span class="token keyword">public</span> Reducer <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Reduce</span><span class="token punctuation">(</span>ReduceInput<span class="token operator">*</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Iterate over all entries with the</span>    <span class="token comment" spellcheck="true">// same key and add the values</span>    int64 value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>input<span class="token operator">-</span><span class="token operator">></span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">StringToInt</span><span class="token punctuation">(</span>input<span class="token operator">-</span><span class="token operator">></span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        input<span class="token operator">-</span><span class="token operator">></span><span class="token function">NextValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Emit sum for input->key()</span>    <span class="token function">Emit</span><span class="token punctuation">(</span><span class="token function">IntToString</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">REGISTER_REDUCER</span><span class="token punctuation">(</span>Adder<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ParseCommandLineFlags</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    MapReduceSpecification spec<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Store list of input files into "spec"</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        MapReduceInput<span class="token operator">*</span> input <span class="token operator">=</span> spec<span class="token punctuation">.</span><span class="token function">add_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        input<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_format</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        input<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_filepattern</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        input<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_mapper_class</span><span class="token punctuation">(</span><span class="token string">"WordCounter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Specify the output files:</span>    <span class="token comment" spellcheck="true">// /gfs/test/freq-00000-of-00100</span>    <span class="token comment" spellcheck="true">// /gfs/test/freq-00001-of-00100</span>    <span class="token comment" spellcheck="true">// ...</span>    MapReduceOutput<span class="token operator">*</span> out <span class="token operator">=</span> spec<span class="token punctuation">.</span><span class="token function">output</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_filebase</span><span class="token punctuation">(</span><span class="token string">"/gfs/test/freq"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_num_tasks</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_format</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_reducer_class</span><span class="token punctuation">(</span><span class="token string">"Adder"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Optional: do partial sums within map</span>    <span class="token comment" spellcheck="true">// tasks to save network bandwidth</span>    out<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_combiner_class</span><span class="token punctuation">(</span><span class="token string">"Adder"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Tuning parameters: use at most 2000</span>    <span class="token comment" spellcheck="true">// machines and 100 MB of memory per task</span>    spec<span class="token punctuation">.</span><span class="token function">set_machines</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    spec<span class="token punctuation">.</span><span class="token function">set_map_megabytes</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    spec<span class="token punctuation">.</span><span class="token function">set_reduce_megabytes</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Now run it</span>    MapReduceResult result<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">MapReduce</span><span class="token punctuation">(</span>spec<span class="token punctuation">,</span> <span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Done: ’result’ structure contains info</span>    <span class="token comment" spellcheck="true">// about counters, time taken, number of</span>    <span class="token comment" spellcheck="true">// machines used, etc.</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;MapReduce是一个编程模型，是一个与处理和生成大数据集相关的实现。用户指定一个处理&lt;code&gt;键值对&lt;/code&gt;的  _Map_ 函
      
    
    </summary>
    
      <category term="翻译" scheme="https://yx1302317313.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="并行处理" scheme="https://yx1302317313.github.io/tags/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>将QImage转换为numpy array</title>
    <link href="https://yx1302317313.github.io/2020/02/26/convert-qimage-to-numpy-array/"/>
    <id>https://yx1302317313.github.io/2020/02/26/convert-qimage-to-numpy-array/</id>
    <published>2020-02-26T14:26:16.000Z</published>
    <updated>2020-06-15T10:56:55.688Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做手写体识别，需要将QT中手写的数字转换成像训练集一样图片。因此需要将QImage转换为numpy array。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者使用的是PyQt，但是对QT和Python之间数据之间的转换不太熟悉。查了很长时间，也没有找到详细的说明，最后在stackoverflow中查到了转换方法，但是说的也不清楚。</p><p>终于，经过查阅QT的参考手册终于明白了转换过程。</p><h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimage <span class="token operator">=</span> self<span class="token punctuation">.</span>canvas_label<span class="token punctuation">.</span>canvas<span class="token punctuation">.</span>toImage<span class="token punctuation">(</span><span class="token punctuation">)</span>size <span class="token operator">=</span> image<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span>s <span class="token operator">=</span> image<span class="token punctuation">.</span>bits<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asstring<span class="token punctuation">(</span>size<span class="token punctuation">.</span>width<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">.</span>height<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> image<span class="token punctuation">.</span>depth<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">8</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># format 0xffRRGGBB</span>arr <span class="token operator">=</span> np<span class="token punctuation">.</span>fromstring<span class="token punctuation">(</span>s<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">.</span>height<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">.</span>width<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> image<span class="token punctuation">.</span>depth<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>new_image <span class="token operator">=</span> Image<span class="token punctuation">.</span>fromarray<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># convert to gray</span>new_image<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">"L"</span><span class="token punctuation">)</span>new_image<span class="token punctuation">.</span>thumbnail<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>new_image<span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'gray'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="1-将QImage转换为字符串"><a href="#1-将QImage转换为字符串" class="headerlink" title="1. 将QImage转换为字符串"></a>1. 将QImage转换为字符串</h3><p>笔者的原图是通过QPixmap绘制的一幅RGB图。之后将其转换为QImage。</p><p>通过<code>s = image.bits().asstring(size.width() * size.height() * image.depth() // 8)</code>将图像数据转换成字符串。</p><p>参数是图像中字节数，字节数等于图像宽度 × 图像高度 × 通道数，即$bytes = width <em> height </em> channels$</p><p>需要注意的是通道数，查看QT的手册知道QT的RGB图像的格式是0xFFRRGGBB,其实就是将Alpha通道全部置为了0xFF。</p><p>之前以为只有3个通道，所以一直有问题。<code>QImage.depth()</code>可以返回图像深度的比特数，对于RGB图<code>QImage.depth()</code>返回值为32，所以整除8之后就是通道数。</p><h3 id="2-将字符串转换为Numpy-array"><a href="#2-将字符串转换为Numpy-array" class="headerlink" title="2. 将字符串转换为Numpy array"></a>2. 将字符串转换为Numpy array</h3><p>之后使用<code>np.fromstring()</code>即可通过字符串构造numpy array。</p><p>到这里QImage转换为numpy array的任务就完成了。之后需要将原图进行灰度处理和压缩。</p><h3 id="3-灰度处理-amp-压缩"><a href="#3-灰度处理-amp-压缩" class="headerlink" title="3. 灰度处理 &amp; 压缩"></a>3. 灰度处理 &amp; 压缩</h3><ul><li>使用<code>Image.convert()</code>可以进行格式转换，详细用法见<a href="https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.convert" target="_blank" rel="noopener">https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.convert</a></li><li>使用<code>Image.thumbnail()</code>进行压缩，注意该方法只能进行压缩，不能放大，而且是等比例压缩。如果需要放大可以使用<code>Image.resize()</code>方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做手写体识别，需要将QT中手写的数字转换成像训练集一样图片。因此需要将QImage转换为numpy array。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="https://yx1302317313.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Qt" scheme="https://yx1302317313.github.io/tags/Qt/"/>
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="Python" scheme="https://yx1302317313.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Load Mnist database of handwritten digit via Python</title>
    <link href="https://yx1302317313.github.io/2020/02/20/parser-mnist/"/>
    <id>https://yx1302317313.github.io/2020/02/20/parser-mnist/</id>
    <published>2020-02-20T12:35:08.000Z</published>
    <updated>2020-06-15T10:43:51.448Z</updated>
    
    <content type="html"><![CDATA[<p>The handwritten digits recognition may be your first project when you get started with Tensorflow or Pytorch, and the dataset used in this project is the Mnist database of handwritten digit.</p><a id="more"></a><h2 id="What-is-Mnist"><a href="#What-is-Mnist" class="headerlink" title="What is Mnist?"></a>What is Mnist?</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The <strong>MNIST database</strong> (Modified National Institute of Standards and Technology database) is a large database of handwritten digits that is commonly used for training various image processing systems.The database is also widely used for training and testing in the field of machine learning.It was created by “re-mixing” the samples from NIST’s original datasets. Source: Wikipedia.</p><h3 id="Get-Mnist"><a href="#Get-Mnist" class="headerlink" title="Get Mnist"></a>Get Mnist</h3><p>You can download the Mnist database from its website, <a href="http://yann.lecun.com/exdb/mnist/index.html" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/index.html</a>.</p><p>There are four compressed files incluing training set images, training set labels, test set images and test set labels.</p><h2 id="The-format-of-Mnist"><a href="#The-format-of-Mnist" class="headerlink" title="The format of Mnist"></a>The format of Mnist</h2><p>The data of Mnist  is stored in a very simple file format. However, you can’t open them with common application program, and you need write your own program to read these files.</p><p>The above website has given the format of both image files and label files. </p><p>Oh, there is a little problem about thd data.</p><blockquote><p>All the integers in the files are stored in the MSB first (high endian) format used by most non-Intel processors. Users of Intel processors and other low-endian machines must flip the bytes of the header.</p></blockquote><p>It points out that the integers in the files is differen from the integers in Intel processor which used by most people’s computers.</p><p>Let’s use 0x00000102 as an example. We start the memory address from 0x0000.</p><p>In Intel processor, the 0x00000102 was stored like this.</p><table><thead><tr><th>address</th><th>value</th></tr></thead><tbody><tr><td>0x0000</td><td>0x02</td></tr><tr><td>0x0001</td><td>0x01</td></tr><tr><td>0x0002</td><td>0x00</td></tr><tr><td>0x0003</td><td>0x00</td></tr></tbody></table><p>In most non-Intel processor, it likes this.</p><table><thead><tr><th>address</th><th>value</th></tr></thead><tbody><tr><td>0x0000</td><td>0x00</td></tr><tr><td>0x0001</td><td>0x00</td></tr><tr><td>0x0002</td><td>0x01</td></tr><tr><td>0x0003</td><td>0x02</td></tr></tbody></table><p>Now, you have known the difference.</p><h3 id="The-format-of-images"><a href="#The-format-of-images" class="headerlink" title="The format of images"></a>The format of images</h3><pre><code>[offset] [type]          [value]          [description]0000     32 bit integer  0x00000803(2051) magic number0004     32 bit integer  60000            number of images0008     32 bit integer  28               number of rows0012     32 bit integer  28               number of columns0016     unsigned byte   ??               pixel0017     unsigned byte   ??               pixel........xxxx     unsigned byte   ??               pixelPixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).</code></pre><p>The first integer is a magic number 0x803. I guess it was used to comfirm whether the file is parsed correctly. You can compare your first interget with 0x803 when you read the file using your own program.</p><p>The next three integers are number of images, the rows of image and the cols of image. Their meaning is obvious.</p><p>Other data is the pixel of images, ranging from 0 to 255.</p><h3 id="The-format-of-Labels"><a href="#The-format-of-Labels" class="headerlink" title="The format of Labels"></a>The format of Labels</h3><pre><code>[offset] [type]          [value]          [description]0000     32 bit integer  0x00000801(2049) magic number (MSB first)0004     32 bit integer  60000            number of items0008     unsigned byte   ??               label0009     unsigned byte   ??               label........xxxx     unsigned byte   ??               labelThe labels values are 0 to 9.</code></pre><p>The first integer is also a magic number, but it is different from the image files. The next integer is number of labels.</p><p>Other data is the label of images, ranging from 0 to 9.</p><h2 id="Load-Mnist-via-Python"><a href="#Load-Mnist-via-Python" class="headerlink" title="Load Mnist via Python"></a>Load Mnist via Python</h2><p>We will import a python package help us to produce the bytes data effectively.</p><p>It is <code>struct</code> which is a build-in class of python. The <code>struct</code> class is very easy, you can learn about it from Python API reference manual.</p><h3 id="Load-images"><a href="#Load-images" class="headerlink" title="Load images"></a>Load images</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> struct<span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">load_image</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    size <span class="token operator">=</span> struct<span class="token punctuation">.</span>calcsize<span class="token punctuation">(</span><span class="token string">">IIII"</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">with</span> open<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> file<span class="token punctuation">:</span>            buffer <span class="token operator">=</span> file<span class="token punctuation">.</span>read<span class="token punctuation">(</span>size<span class="token punctuation">)</span>            magic<span class="token punctuation">,</span> number<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">">IIII"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span>            <span class="token keyword">if</span> magic <span class="token operator">!=</span> <span class="token number">0x803</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"parse error!"</span><span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">or</span> count <span class="token operator">></span> number<span class="token punctuation">:</span>                count <span class="token operator">=</span> number            <span class="token comment" spellcheck="true"># read image</span>            size <span class="token operator">=</span> count <span class="token operator">*</span> row  <span class="token operator">*</span> col            size <span class="token operator">=</span> struct<span class="token punctuation">.</span>calcsize<span class="token punctuation">(</span><span class="token string">'>'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'B'</span><span class="token punctuation">)</span>            buffer <span class="token operator">=</span> file<span class="token punctuation">.</span>read<span class="token punctuation">(</span>size<span class="token punctuation">)</span>            images <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'>'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'B'</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span>            images <span class="token operator">=</span> np<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>images<span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> row <span class="token operator">*</span> col<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> FileNotFoundError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"file \"%s\" not found!"</span> <span class="token operator">%</span> filename<span class="token punctuation">)</span>        <span class="token keyword">return</span> images</code></pre><p>First, we need to read four integers in the head of images file. Then we verify the magic number, there are some bugs if they are not corressonding.</p><p>After that we read some images accoding to a variant <code>count</code>.</p><p>Now, you may understand the steps of <code>struct</code>.</p><ol><li>use function <code>calcsize</code> get the size of bytes.</li><li>read some bytes from file.</li><li>use function <code>unpack</code> get some variants according to designative format.</li></ol><p>Finally, the variant <code>images</code> is a long vector, it is necessary to reshape it use numpy before return it.</p><h3 id="Load-labels"><a href="#Load-labels" class="headerlink" title="Load labels"></a>Load labels</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">load_label</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    size <span class="token operator">=</span> struct<span class="token punctuation">.</span>calcsize<span class="token punctuation">(</span><span class="token string">">II"</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">with</span> open<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> file<span class="token punctuation">:</span>            buffer <span class="token operator">=</span> file<span class="token punctuation">.</span>read<span class="token punctuation">(</span>size<span class="token punctuation">)</span>            magic<span class="token punctuation">,</span> number<span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">">II"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span>            <span class="token keyword">if</span> magic <span class="token operator">!=</span> <span class="token number">0x801</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"parse error!"</span><span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">or</span> count <span class="token operator">></span> number<span class="token punctuation">:</span>                count <span class="token operator">=</span> number            <span class="token comment" spellcheck="true"># parser image            </span>            size <span class="token operator">=</span> struct<span class="token punctuation">.</span>calcsize<span class="token punctuation">(</span><span class="token string">'>'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'B'</span><span class="token punctuation">)</span>            buffer <span class="token operator">=</span> file<span class="token punctuation">.</span>read<span class="token punctuation">(</span>size<span class="token punctuation">)</span>            labels <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'>'</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'B'</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span>                <span class="token keyword">except</span> FileNotFoundError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"file \"%s\" not found!"</span> <span class="token operator">%</span> filename<span class="token punctuation">)</span>        <span class="token keyword">return</span> labels</code></pre><p>The code of <code>load_label</code> is same as <code>load_image</code>. You are so smart that you will understand it.</p><h3 id="Show-images"><a href="#Show-images" class="headerlink" title="Show images"></a>Show images</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_image</span><span class="token punctuation">(</span>images<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">:</span>    figure <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>subplots_adjust<span class="token punctuation">(</span>left<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">,</span> bottom<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span> top<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">,</span> hspace<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> wspace<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>        image <span class="token operator">=</span> np<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        ax <span class="token operator">=</span> figure<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span>math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>count<span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        ax<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>image<span class="token punctuation">,</span> cmap<span class="token operator">=</span>plt<span class="token punctuation">.</span>cm<span class="token punctuation">.</span>binary<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>We use <code>matplotlib</code> to show  loaded images.</p><p>The result:</p><center><img src="/img/blog/blog-25-1.png" width=600></center><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The handwritten digits recognition may be your first project when you get started with Tensorflow or Pytorch, and the dataset used in this project is the Mnist database of handwritten digit.&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="https://yx1302317313.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="Python" scheme="https://yx1302317313.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Gitee导入Github仓库</title>
    <link href="https://yx1302317313.github.io/2020/02/20/gitee-import-from-github/"/>
    <id>https://yx1302317313.github.io/2020/02/20/gitee-import-from-github/</id>
    <published>2020-02-20T11:59:59.000Z</published>
    <updated>2020-06-15T10:40:50.425Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们可能需要将项目同时提交到Github和Gitee，通过使用Gitee导入Github仓库我们可以轻松完成这个任务。</p><a id="more"></a><h2 id="导入Github仓库"><a href="#导入Github仓库" class="headerlink" title="导入Github仓库"></a>导入Github仓库</h2><p>在新建仓库时最下方有一个 <code>导入已有仓库</code> 的选项，点击后可以输入github仓库的URL链接。如果选择导入，上面的所有信息都不需要填写，即使填写了也会被覆盖。</p><center><img src="/img/blog/blog-24-1.png" width=600></center><p>如果是私有仓库，需要提供Github的账号和密码，如下图：</p><center><img src="/img/blog/blog-24-2.png" width=600></center><p>点击创建后，导入Github仓库就成功了。</p><h2 id="同步Github仓库"><a href="#同步Github仓库" class="headerlink" title="同步Github仓库"></a>同步Github仓库</h2><p>通过导入github仓库建立的gitee仓库可以同步在github中原仓库。</p><center><img src="/img/blog/blog-24-3.png" width=600></center><p>点击上图中的强制同步选项，可以直接同步在github中的仓库。</p><p>这样在本地主机上的项目只需要提交到github的服务器之后再同步到gitee中，就可以轻松实现 <strong>将项目同时提交到github和gitee</strong> 。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><h3 id="Gitee与Github的发行版设置不同。"><a href="#Gitee与Github的发行版设置不同。" class="headerlink" title="Gitee与Github的发行版设置不同。"></a>Gitee与Github的发行版设置不同。</h3><ul><li>Github会直接将tags作为发行版，如果创建了一个tag，那么在releases中也可以看到多了一个发行版。</li><li>Gitee的tags和发行版是独立的，创建tag之后，不会自动创建发行版，而是由用户决定是否从该tag创建发行版。</li></ul><p><strong>在同步时，Github的发行版不会同步到Gitee，但是tags会进行同步。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时我们可能需要将项目同时提交到Github和Gitee，通过使用Gitee导入Github仓库我们可以轻松完成这个任务。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://yx1302317313.github.io/categories/Git/"/>
    
    
      <category term="Tool" scheme="https://yx1302317313.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-最长有效括号</title>
    <link href="https://yx1302317313.github.io/2020/01/22/leetcode-zui-chang-you-xiao-gua-hao/"/>
    <id>https://yx1302317313.github.io/2020/01/22/leetcode-zui-chang-you-xiao-gua-hao/</id>
    <published>2020-01-22T08:28:59.000Z</published>
    <updated>2020-06-17T14:00:36.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目：最长有效括号"><a href="#题目：最长有效括号" class="headerlink" title="题目：最长有效括号"></a>题目：最长有效括号</h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><pre><code>输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot;</code></pre><p>示例 2:</p><pre><code>输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot;</code></pre><p>示例 3:</p><pre><code>输入: &quot;)(())())&quot;输出: 6解释: 最长有效括号子串为 &quot;(())()&quot;</code></pre><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">来源：力扣（LeetCode）</a></p><h2 id="算法：动态规划"><a href="#算法：动态规划" class="headerlink" title="算法：动态规划"></a>算法：动态规划</h2><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><p>定义 $dp[i]$ 表示以第i个字符结尾的字符串中最长的有效括号长度。</p><p>example1:</p><pre><code>string: &quot;()()()&quot;index  : 0 1 2 3 4 5dp:      0 2 0 4 0 6</code></pre><p>example2:</p><pre><code>string: &quot;()((())&quot;index  : 0 1 2 3 4 5 6 dp:      0 2 0 0 0 2 4</code></pre><p>example3:</p><pre><code>string: &quot;()(())&quot;index: 0 1 2 3 4 5dp:    0 2 0 0 2 6</code></pre><ol><li>若$s[j] = ‘(‘$, 由于’（’不可能是有效括号的结束字符，所以$dp[j] = 0$。</li><li>若$s[j] = ‘）’$，存在多种情况<ul><li>若$s[j-1]为’（’$， 若是则可以组成有效括号，有效括号长度+2。</li><li>若$s[j-1]为’）’$， 也不一定不是有效括号，还可能存在括号嵌套的情况，如”example2”, 这种情况则要判断 $s[dp[j-1] - 1]$是否等于’(‘，是则+2。该情况可以和上一种情况合并，都可表示为判断 $s[dp[j-1] - 1] == ‘(‘$ 是否成立。</li></ul></li><li>当 $dp[j]$是有效括号的结束字符时，要判断是否和之前的有效括号连续，如果连续要加上之前的长度。如”example3”， $s[5]= ‘)’$, 且 $s[5 - dp[4] - 1] = ‘(‘$, 所以 $dp[5] = dp[4] + 2 = 4$。但是由于可以和之前的”()”连起来，所以 $dp[5] = dp[4] + 2 + dp[5 - dp[4] - 2] = 6$。</li></ol><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>$$<br>dp[i]=<br>\left\{<br>\begin{align}<br>&amp;0,&amp;s[i]=”(“\\<br>&amp;0,&amp;s[i]= “）” \quad \&amp;\&amp; \quad s[i-dp[i-1]-1] \neq “(“\\<br>&amp;dp[i-1] + 2 + dp[i-dp[i-1]-2], &amp;s[i]= “）” \quad \&amp;\&amp; \quad s[i-dp[i-1]-1] = “(“\\<br>\end{align}<br>\right.<br>$$</p><h3 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度&amp;空间复杂度"></a>时间复杂度&amp;空间复杂度</h3><ol><li>时间复杂度: $O(n)$</li><li>空间复杂度: $O(n)$</li></ol><h2 id="LeetCode执行结果"><a href="#LeetCode执行结果" class="headerlink" title="LeetCode执行结果"></a>LeetCode执行结果</h2><ul><li>执行用时 : <strong>4 ms</strong>, 在所有 C++ 提交中击败了 <strong>95.63%</strong>的用户。</li><li>内存消耗 : <strong>9.8 MB</strong>, 在所有 C++ 提交中击败了 <strong>15.58%</strong>的用户。</li></ul><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>其实动规比较简单，有套路可循。尤其是和字符串有关的题目，基本都与子串有关。但是难在子问题的划分，比如这道题中定义 $dp[i]$ 表示以第i个字符结尾的字符串中最长的有效括号长度，这样就比较简单。而我之前想的是定义为子串中最长有效括号的长度，到后面很难处理。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestValidParentheses</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>  s<span class="token punctuation">[</span>i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">2</span> <span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                        <span class="token punctuation">}</span>                    <span class="token keyword">else</span>                    <span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                        <span class="token punctuation">}</span>                                    <span class="token punctuation">}</span>                            <span class="token punctuation">}</span>                <span class="token keyword">else</span>            <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string str<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"input:"</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cin <span class="token operator">>></span> str<span class="token punctuation">;</span>    Solution s<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">longestValidParentheses</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目：最长有效括号&quot;&gt;&lt;a href=&quot;#题目：最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;题目：最长有效括号&quot;&gt;&lt;/a&gt;题目：最长有效括号&lt;/h2&gt;&lt;p&gt;给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。&lt;
      
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="C++" scheme="https://yx1302317313.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-扰乱字符串</title>
    <link href="https://yx1302317313.github.io/2020/01/19/leecode-rao-luan-zi-fu-chuan/"/>
    <id>https://yx1302317313.github.io/2020/01/19/leecode-rao-luan-zi-fu-chuan/</id>
    <published>2020-01-19T14:07:49.000Z</published>
    <updated>2020-06-17T11:36:54.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：扰乱字符串"><a href="#题目：扰乱字符串" class="headerlink" title="题目：扰乱字符串"></a>题目：扰乱字符串</h3><p>给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。</p><p>下图是字符串 s1 = “great” 的一种可能的表示形式。</p><pre><code>    great   /    \  gr    eat / \    /  \g   r  e   at           / \          a   t</code></pre><p>在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。</p><p>例如，如果我们挑选非叶节点 “gr” ，交换它的两个子节点，将会产生扰乱字符串 “rgeat” 。</p><pre><code>    rgeat   /    \  rg    eat / \    /  \r   g  e   at           / \          a   t</code></pre><p>我们将 “rgeat” 称作 “great” 的一个扰乱字符串。</p><p>同样地，如果我们继续交换节点 “eat” 和 “at” 的子节点，将会产生另一个新的扰乱字符串 “rgtae” 。</p><pre><code>    rgtae   /    \  rg    tae / \    /  \r   g  ta  e       / \      t   a</code></pre><p>我们将 “rgtae” 称作 “great” 的一个扰乱字符串。</p><p>给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。</p><p>示例 1:</p><pre><code>输入: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;输出: true</code></pre><p>示例 2:</p><pre><code>输入: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;输出: false</code></pre><p>来源：力扣（LeetCode）。链接：<a href="https://leetcode-cn.com/problems/scramble-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/scramble-string</a></p><h3 id="解题思路：递归"><a href="#解题思路：递归" class="headerlink" title="解题思路：递归"></a>解题思路：递归</h3><p>由于无法得知原字符串分割的位置，所以通过蛮力遍历每一个位置对原字符串进行分割，然后比较原字符串和扰乱字符串分割之后的子串是否相等。子串同样进行了分割，则需要再对子串进行分割判断。这个时候就可以使用递归了。</p><p>由于分割之后还可能进行交换，所以需要判断两种情况：</p><ol><li>直接对原字符串进行分割，比较原字符串和扰乱字符串分割之后的子串是否相等。即s1[0, i] == s2[0, i] &amp;&amp; s1[i+1, len - 1] == s2[i+1, len -1]。</li><li>将分割后的两个子串交换，然后比较交换后的子串。s1[0, i] == s2[len-1 - i, len-1] &amp;&amp; s1[i+1, len - 1] == s2[0, len-i]。</li></ol><p>优化：<br>由于分割交换并不会改变字符串中字符的个数，所以可以通过统计并比较两字符串中各字符的个数是否相等做一次筛选。<br>如果不等，则一定不是扰乱字符串。这是一个 <strong>必要条件</strong>。</p><h3 id="LeetCode-运行结果"><a href="#LeetCode-运行结果" class="headerlink" title="LeetCode 运行结果"></a>LeetCode 运行结果</h3><ul><li>执行用时 :8 ms, 在所有 C++ 提交中击败88.36的用户。</li><li>内存消耗 :10 MB, 在所有 C++ 提交中击败了78.16%的用户。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">bool</span> <span class="token function">isScramble</span><span class="token punctuation">(</span>string s1<span class="token punctuation">,</span> string s2<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token function">_isScramble</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">bool</span> <span class="token function">_isScramble</span><span class="token punctuation">(</span>string s1<span class="token punctuation">,</span> string s2<span class="token punctuation">)</span>        <span class="token punctuation">{</span>                                       <span class="token keyword">int</span> m <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//统计s1和s2的字符个数，判断相应的字符个数是否相等。（必要条件）</span>                <span class="token keyword">int</span> char_num<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                        char_num<span class="token punctuation">[</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                        char_num<span class="token punctuation">[</span>s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>char_num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//蛮力切割</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_isScramble</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                        <span class="token function">_isScramble</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//切割并且交换</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_isScramble</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>m<span class="token operator">-</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                        <span class="token function">_isScramble</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：扰乱字符串&quot;&gt;&lt;a href=&quot;#题目：扰乱字符串&quot; class=&quot;headerlink&quot; title=&quot;题目：扰乱字符串&quot;&gt;&lt;/a&gt;题目：扰乱字符串&lt;/h3&gt;&lt;p&gt;给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。&lt;/p
      
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="C++" scheme="https://yx1302317313.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux 管道通信</title>
    <link href="https://yx1302317313.github.io/2019/11/14/linux-pipe/"/>
    <id>https://yx1302317313.github.io/2019/11/14/linux-pipe/</id>
    <published>2019-11-14T10:42:32.000Z</published>
    <updated>2020-04-02T07:45:53.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统调用-fork"><a href="#系统调用-fork" class="headerlink" title="系统调用 fork"></a>系统调用 fork</h2><p>在linux系统中创建进程有两种方式</p><ul><li>一是由操作系统创建。</li><li>二是由父进程创建进程。系统调用函数fork()是创建一个新进程的唯一方式。</li></ul><p>fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程。</p><ol><li>系统先给新的进程分配资源，例如存储数据和代码的空间。</li><li>然后把原来的进程（父进程）的所有值都复制到新的新进程（子进程）中，只有少数值与原来的进程的值不同。</li><li>Linux的fork()采用写时拷贝实现，只有子进程发起写操作时才正真执行拷贝，在写时拷贝之前都是以只读的方式共享。这样可以避免发生拷贝大量数据而不被使用的情况。</li></ol><p>fork是Linux系统中一个比较特殊的函数，其一次调用会有两个返回值。在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。如果失败返回值是1。</p><ul><li>在子进程中，fork函数返回0。</li><li>在父进程中，fork返回新创建子进程的进程ID。</li></ul><p>因此我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>Linux中，每个管道允许两个进程交互数据，一个进程向管道写入数据，一个进程从管道读出数据。Linux并没有给管道定义一个新的数据结构，而是借用了文件系统中文件的数据结构。即管道实际是一个文件（但是与文件并不完全形同）。</p><p>操作系统在内存中为每个管道开辟一页内存（4KB），给这一页赋予了文件的属性。这一页内存由两个进程共享，但不会分配给任何进程，只由内核掌控。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote><p>Linux pipe手册中的例子</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        pid_t cpid<span class="token punctuation">;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>                <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Usage: %s &lt;string>\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cpid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cpid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cpid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>                         <span class="token comment" spellcheck="true">/* Child reads from pipe */</span>                <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Close unused write end */</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                        <span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">_exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>                         <span class="token comment" spellcheck="true">/* Parent writes argv[1] to pipe */</span>                <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Close unused read end */</span>                <span class="token function">write</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Reader will see EOF */</span>                <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* Wait for child */</span>                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/inter-process-communication/pipe/%E6%A0%B7%E4%BE%8B%E7%A4%BA%E5%9B%BE.png" alt=""></p><h3 id="管道的读写"><a href="#管道的读写" class="headerlink" title="管道的读写"></a>管道的读写</h3><ul><li>读管道进程执行时，如果管道中有未读数据，就读取数据，没有未读数据就挂起，这样就不会读取垃圾数据。</li><li>写管道进程执行时，如果管道中有剩余空间，就写入数据，没有剩余空间了，就挂起，这样就不会覆盖尚未读取的数据。</li></ul><h4 id="读管道"><a href="#读管道" class="headerlink" title="读管道"></a>读管道</h4><p>对于读管道操作，数据是从管道尾读出，并使管道尾指针前移‘读取字节数’个位置。</p><p><img src="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/inter-process-communication/pipe/%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><p>Linux 0.11 源码</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//fs/pipe.c</span><span class="token keyword">int</span> <span class="token function">read_pipe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> m_inode <span class="token operator">*</span> inode<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> chars<span class="token punctuation">,</span> size<span class="token punctuation">,</span> read <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token function">PIPE_SIZE</span><span class="token punctuation">(</span><span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//管道空</span>            <span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inode<span class="token operator">-></span>i_wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//唤醒等待写管道进程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inode<span class="token operator">-></span>i_count <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* are there any writers? */</span>                <span class="token keyword">return</span> read<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//没有writer，返回</span>            <span class="token function">sleep_on</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inode<span class="token operator">-></span>i_wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//挂起读管道进程</span>        <span class="token punctuation">}</span>        chars <span class="token operator">=</span> PAGE_SIZE<span class="token operator">-</span><span class="token function">PIPE_TAIL</span><span class="token punctuation">(</span><span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//PAGE_SIZE: 4KB </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chars <span class="token operator">></span> count<span class="token punctuation">)</span>            chars <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chars <span class="token operator">></span> size<span class="token punctuation">)</span>            chars <span class="token operator">=</span> size<span class="token punctuation">;</span>        count <span class="token operator">-</span><span class="token operator">=</span> chars<span class="token punctuation">;</span>        read <span class="token operator">+</span><span class="token operator">=</span> chars<span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token function">PIPE_TAIL</span><span class="token punctuation">(</span><span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PIPE_TAIL</span><span class="token punctuation">(</span><span class="token operator">*</span>inode<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token operator">=</span> chars<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 读多少数据，指针就偏移多少</span>        <span class="token function">PIPE_TAIL</span><span class="token punctuation">(</span><span class="token operator">*</span>inode<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_SIZE<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 指针超过一个页面，（&amp;= ）操作可以实现自动回滚</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>chars<span class="token operator">--</span> <span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">put_fs_byte</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>inode<span class="token operator">-></span>i_size<span class="token punctuation">)</span><span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span>buf<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//将管道中的数据拷贝至buf</span>    <span class="token punctuation">}</span>    <span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inode<span class="token operator">-></span>i_wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//唤醒等待写管道进程</span>    <span class="token keyword">return</span> read<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// include/linux/fs.h</span><span class="token macro property">#<span class="token directive keyword">define</span> PIPE_HEAD(inode) ((inode).i_zone[0])</span><span class="token macro property">#<span class="token directive keyword">define</span> PIPE_TAIL(inode) ((inode).i_zone[1])</span><span class="token comment" spellcheck="true">//PIPE_HEAD(inode)-PIPE_TAIL(inode) &lt; 0，和 (PAGE_SIZE-1) 相与能够计算出管道未读数据的长度</span><span class="token macro property">#<span class="token directive keyword">define</span> PIPE_SIZE(inode) ((PIPE_HEAD(inode)-PIPE_TAIL(inode))&amp;(PAGE_SIZE-1))</span></code></pre><h4 id="写管道"><a href="#写管道" class="headerlink" title="写管道"></a>写管道</h4><p>对于写管道操作，数据是向管道头部写入，并使管道头指针前移‘写入字节数’个位置。</p><p>Linux 0.11 源码</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//fs/pipe.c</span><span class="token keyword">int</span> <span class="token function">write_pipe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> m_inode <span class="token operator">*</span> inode<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> chars<span class="token punctuation">,</span> size<span class="token punctuation">,</span> written <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span>PAGE_SIZE<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">PIPE_SIZE</span><span class="token punctuation">(</span><span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//管道已满</span>            <span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inode<span class="token operator">-></span>i_wait<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//唤醒等待读管道进程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inode<span class="token operator">-></span>i_count <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* no readers */</span>                current<span class="token operator">-></span>signal <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>SIGPIPE<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> written<span class="token operator">?</span>written<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//没有reader，返回</span>            <span class="token punctuation">}</span>            <span class="token function">sleep_on</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inode<span class="token operator">-></span>i_wait<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//挂起写管道进程</span>        <span class="token punctuation">}</span>        chars <span class="token operator">=</span> PAGE_SIZE<span class="token operator">-</span><span class="token function">PIPE_HEAD</span><span class="token punctuation">(</span><span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chars <span class="token operator">></span> count<span class="token punctuation">)</span>            chars <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chars <span class="token operator">></span> size<span class="token punctuation">)</span>            chars <span class="token operator">=</span> size<span class="token punctuation">;</span>        count <span class="token operator">-</span><span class="token operator">=</span> chars<span class="token punctuation">;</span>        written <span class="token operator">+</span><span class="token operator">=</span> chars<span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token function">PIPE_HEAD</span><span class="token punctuation">(</span><span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PIPE_HEAD</span><span class="token punctuation">(</span><span class="token operator">*</span>inode<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token operator">=</span> chars<span class="token punctuation">;</span>        <span class="token function">PIPE_HEAD</span><span class="token punctuation">(</span><span class="token operator">*</span>inode<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_SIZE<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 指针超过一个页面，（&amp;= ）操作可以实现自动回滚</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>chars<span class="token operator">--</span> <span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>inode<span class="token operator">-></span>i_size<span class="token punctuation">)</span><span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">get_fs_byte</span><span class="token punctuation">(</span>buf<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//读取buf中的数据写入管道</span>    <span class="token punctuation">}</span>    <span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inode<span class="token operator">-></span>i_wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//唤醒等待读管道进程</span>    <span class="token keyword">return</span> written<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// include/linux/fs.h</span><span class="token macro property">#<span class="token directive keyword">define</span> PIPE_HEAD(inode) ((inode).i_zone[0])</span><span class="token macro property">#<span class="token directive keyword">define</span> PIPE_TAIL(inode) ((inode).i_zone[1])</span><span class="token comment" spellcheck="true">//PIPE_HEAD(inode)-PIPE_TAIL(inode) &lt; 0，和 (PAGE_SIZE-1) 相与能够计算出管道未读数据的长度</span><span class="token macro property">#<span class="token directive keyword">define</span> PIPE_SIZE(inode) ((PIPE_HEAD(inode)-PIPE_TAIL(inode))&amp;(PAGE_SIZE-1))</span></code></pre><h3 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h3><ul><li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li><li>只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；</li><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。</li><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li></ul><h3 id="管道的局限性"><a href="#管道的局限性" class="headerlink" title="管道的局限性"></a>管道的局限性</h3><ul><li>只支持单向数据流。</li><li>只能用于具有亲缘关系的进程之间。</li><li>没有名字（有名管道是 FIFO）。</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）。</li><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）。</li><li>…</li></ul><h2 id="双向管道通信"><a href="#双向管道通信" class="headerlink" title="双向管道通信"></a>双向管道通信</h2><ol><li>父进程创建两个管道,pipe1和pipe2.</li><li>父进程创建子进程,调用fork()的过程中子进程会复制父进程创建的两个管道.</li><li>实现父进程向子进程通信:父进程关闭pipe1的读端,保留写端;而子进程关闭pipe1的写端,保留读端.</li><li>实现子进程向父进程通信:子进程关闭pipe2的读端,保留写端;而父进程关闭pipe2的写端,保留读端.</li></ol><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> pipe_command<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//管道1 父进程 -> 子进程</span>        <span class="token keyword">int</span> pipe_result<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//管道2 子进程 -> 父进程 </span>        pid_t cpid<span class="token punctuation">;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//父进程创建管道</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>pipe_command<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe_command"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>pipe_result<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe_result"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//创建子进程</span>        cpid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cpid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cpid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/*子进程*/</span>        <span class="token punctuation">{</span>                                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sub: pid %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//输出子进程ID</span>                <span class="token function">close</span><span class="token punctuation">(</span>pipe_command<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//关闭管道写端</span>                <span class="token function">close</span><span class="token punctuation">(</span>pipe_result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//关闭管道读端</span>                <span class="token keyword">int</span> read_status<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                        read_status <span class="token operator">=</span>  <span class="token function">read</span><span class="token punctuation">(</span>pipe_command<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//读取父进程的命令</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>read_status <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sub: command %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"hell"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                                <span class="token punctuation">{</span>                                                                                <span class="token function">write</span><span class="token punctuation">(</span>pipe_result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"okok"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//回应父进程</span>                                <span class="token punctuation">}</span>                                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"exit"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                                <span class="token punctuation">{</span>                                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sub: exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                        <span class="token keyword">break</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                         <span class="token punctuation">}</span>                                               <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>read_status <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//读取错误</span>                        <span class="token punctuation">{</span>                                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sub: read error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                                                       <span class="token punctuation">}</span>                        <span class="token function">close</span><span class="token punctuation">(</span>pipe_command<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关闭管道</span>                <span class="token function">close</span><span class="token punctuation">(</span>pipe_result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>    <span class="token comment" spellcheck="true">/*父进程*/</span>        <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent: pid %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//输出父进程ID</span>                <span class="token function">close</span><span class="token punctuation">(</span>pipe_command<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关闭管道读端</span>                <span class="token function">close</span><span class="token punctuation">(</span>pipe_result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//关闭管道写端</span>                <span class="token function">write</span><span class="token punctuation">(</span>pipe_command<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"hell"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//向子进程发送命令</span>                 <span class="token keyword">int</span> read_status<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                        read_status <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>pipe_result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>read_status <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent: received %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//接收子进程回应</span>                                <span class="token function">write</span><span class="token punctuation">(</span>pipe_command<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"exit"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//通知子进程退出</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                                                      <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>read_status <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">//读取错误</span>                        <span class="token punctuation">{</span>                                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"parent: read error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                                                                          <span class="token punctuation">}</span>                <span class="token function">close</span><span class="token punctuation">(</span>pipe_command<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token function">close</span><span class="token punctuation">(</span>pipe_result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* 等待子进程退出,并判断状态吗码*/</span>                <span class="token keyword">int</span> status<span class="token punctuation">;</span>                <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status <span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exited: %d\n"</span><span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                                                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"signaled: %d\n"</span><span class="token punctuation">,</span> <span class="token function">WTERMSIG</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《Linux内核设计的艺术》</li><li>《Linux内核设计与实现》</li><li>Linux v0.11内核源码(<a href="https://github.com/karottc/linux-0.11" target="_blank" rel="noopener">https://github.com/karottc/linux-0.11</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统调用-fork&quot;&gt;&lt;a href=&quot;#系统调用-fork&quot; class=&quot;headerlink&quot; title=&quot;系统调用 fork&quot;&gt;&lt;/a&gt;系统调用 fork&lt;/h2&gt;&lt;p&gt;在linux系统中创建进程有两种方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是由操作系统创建。
      
    
    </summary>
    
      <category term="Linux" scheme="https://yx1302317313.github.io/categories/Linux/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="Kernel" scheme="https://yx1302317313.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Git子模块（submodule）</title>
    <link href="https://yx1302317313.github.io/2019/11/09/git-zi-mo-kuai-submodule/"/>
    <id>https://yx1302317313.github.io/2019/11/09/git-zi-mo-kuai-submodule/</id>
    <published>2019-11-09T14:22:32.000Z</published>
    <updated>2020-06-15T10:41:14.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="submodule的作用"><a href="#submodule的作用" class="headerlink" title="submodule的作用"></a>submodule的作用</h3><p>Git使用submodule(子模块)解决Git仓库的嵌套问题，允许一个 Git 仓库作为另一个 Git 仓库的子目录。 能够将一个仓库同步到自己的项目中的同时，保持Git仓库提交的独立性。详细参见<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">《pro git》子模块</a></p><h3 id="submodule的原理"><a href="#submodule的原理" class="headerlink" title="submodule的原理"></a>submodule的原理</h3><p>submodule的实现很巧妙也很简单。其实submodule只是在原Git仓库中多添加了一条或者几条子模块的记录(保存在 <code>.gitmodule</code> 中)，它记录了仓库中包含的子模块的路径和URL。</p><pre><code>[submodule &quot;project/submodule&quot;]    path = project/submodule    # 在项目中的路径，即子模块所在的文件夹是project/submodule    url = https://github.com/submodule.git    # 远程仓库的URL</code></pre><p>当需要同步子模块的文件时，通过指定的URL使用HTTP协议下载到本地，同样如果对子模块里的内容做出修改之后，通过该URL可以提交到子模块的远程仓库（而不是提交到依赖该子模块项目的仓库）。</p><p>为了保证父仓库当前子模块的内容不会随着子模块仓库内容更新而改变，父仓库中还记录了子模块当前指向的提交记录。</p><p>例如：project仓库中包含了一个submodule子模块，当前子模块指向的远程仓库中的索引是 <code>ef34</code> 。Git会对每一次提交建立一个索引，该索引与提交记录一一对应。</p><pre><code>---project    |---submodule@ef34    |---others    |---.git</code></pre><p>如果子模块仓库发生了不兼容更新，最新的提交记录是 <code>ty23</code> 。由于父仓库中子模块指向的索引是 <code>ef34</code> ，即使子模块远程仓库中的内容发生了变化，也不会影响依赖于旧代码的项目。project在clone或者pull的时候，拉取的仍然是 <code>ef34</code> 的内容。如果此时project需要使用最新的submodule代码，通过更新子模块即可将子模块的索引修改为 <code>ty23</code> 。</p><pre><code>commit ty23 commit ef34commit jk93......</code></pre><h3 id="使用submodule"><a href="#使用submodule" class="headerlink" title="使用submodule"></a>使用submodule</h3><h4 id="1、新建submodule"><a href="#1、新建submodule" class="headerlink" title="1、新建submodule"></a>1、新建submodule</h4><p>使用<code>git submodule add</code>添加新的子模块</p><pre class=" language-sh"><code class="language-sh">$ git submodule add "URL"</code></pre><p>下图演示了添加名为Game的子模块</p><center><img src="/img/blog/blog-23-1.png" width=600></center><p>之后会发现目录下多了一个Game目录和.gitmodules的文件。其中Game目录下是你所希望包含项目的分支代码，而gitmodules的内容如下。也就是之前提到的submodule使用子模块的名称和URL记录本仓库包含的子模块。</p><pre><code>[submodule &quot;Game&quot;]    path = Game    url = https://github.com/yx1302317313/Game.git</code></pre><p>提交之后查看远程仓库会发现添加的子模块的文件并没有传到远程仓库，子模块的文件夹实际是一个URL，指向了包含子模块本身的远程仓库。</p><center><img src="/img/blog/blog-23-2.png" width=600></center><h4 id="2、克隆包含submodule的项目"><a href="#2、克隆包含submodule的项目" class="headerlink" title="2、克隆包含submodule的项目"></a>2、克隆包含submodule的项目</h4><p>当使用<code>git clone</code>克隆一个包含子模块的项目时，子模块的文件并不会一同并拉取到本地，而只是一个空目录。</p><center><img src="/img/blog/blog-23-3.png" width=600></center><p>这时需要使用<code>git submodule init</code>用来初始化本地配置文件,而 <code>git submodule update</code>则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p><center><img src="/img/blog/blog-23-4.png" width=600></center><br><center><img src="/img/blog/blog-23-5.png" width=600></center><p>一个更简单的方法是给<code>git clone</code>加上递归选项<code>--recursive</code></p><pre class=" language-sh"><code class="language-sh">$ git clone --recursive "URL" # 自动初始化并更新仓库中的每一个子模块</code></pre><p><strong>[注意]：</strong> 由于git的子模块跟踪的是提交记录(commit id)，所以拉取下来的是一个游离分支，其实是将一个提交记录作为了一个游离的分支。这时候还需要切换到master分支。</p><pre class=" language-sh"><code class="language-sh">$ cd Game$ git checkout master</code></pre><p>所以整个克隆的步骤如下：</p><ol><li>克隆远程仓库：git clone “URL”</li><li>初始化子模块：git submodule init</li><li>拉取子模块的内容：git submodule update</li><li>进入子模块切换至主分支: git checkout master</li></ol><h4 id="3、更新submodule"><a href="#3、更新submodule" class="headerlink" title="3、更新submodule"></a>3、更新submodule</h4><ol><li>进入submodule的目录。</li><li>使用<code>git fetch</code>和<code>git merge</code>更新submodule,与远程仓库的最新代码合并（当然也可以直接使用<code>git pull</code>）。</li></ol><h5 id="关于-git-fetch-与-git-pull"><a href="#关于-git-fetch-与-git-pull" class="headerlink" title="关于 git fetch 与 git pull"></a>关于 git fetch 与 git pull</h5><blockquote><p>git pull = git fetch + git merge, 可以参考<a href="https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch" target="_blank" rel="noopener">stack overflow</a></p></blockquote><p><strong>更简单的方式</strong>：运行<code>git submodule update--remote</code>, 使用该命令Git将会进入子模块然后进行抓取并更新。</p><p><strong>注意：该命令默认fetch和merge主分支（master），如果是其他分支，需要进行配置（见《pro git》）。</strong></p><h4 id="4、修改并提交submodule"><a href="#4、修改并提交submodule" class="headerlink" title="4、修改并提交submodule"></a>4、修改并提交submodule</h4><h5 id="提交前的fetch"><a href="#提交前的fetch" class="headerlink" title="提交前的fetch"></a>提交前的fetch</h5><p>当修改了submodule的文件时，这里有一个需要注意的地方。一般我们在提交之前都需要查看远程分支是否有更新，会不会有冲突。我们的方法是使用<code>git fetch</code>抓取远程分支查看是否更新然后进行<code>git merge</code>。（使用<code>git pull</code>也没什么太大的问题）。</p><p>需要注意的地方是<code>git submodule update</code>，之前提到这个命令也可以完成上面的功能，还更方便。</p><p>但是《pro git》中提到</p><blockquote><p>当我们运行 git submodule update 从子模块仓库中抓取修改时,Git 将会获得这些改动并更新子目录中的文件,但是会将子仓库留在一个称作“游离的 HEAD”的状态。 这意味着没有本地工作分支(例如“master” )跟踪改动。 所以你做的任何改动都不会被跟踪。</p></blockquote><p>这段话感觉很难理解，英文版说的更直接一点。</p><blockquote><p>So far, when we’ve run the git submodule update command to fetch changes from the submodule repositories, Git would get the changes and update the files in the subdirectory but will leave the sub-repository in what’s called a “detached HEAD” state. This means that there is no local working branch (like “master”, for example) tracking changes. With no working branch tracking changes, that means even if you commit changes to the submodule, those changes will quite possibly be lost the next time you run git submodule update. You have to do some extra steps if you want changes in a submodule to be tracked.</p></blockquote><p>关键是这句话</p><blockquote><p> With no working branch tracking changes, that means even if you commit changes to the submodule, those changes will quite possibly be lost the next time you run git submodule update. </p></blockquote><p>意思就是如果远程仓库发生了改动，并且你本地有未推送到远程仓库的提交（commit），执行<code>git submodule update</code>后你的提交并不会与远程仓库进行合并（merge）。而是成为了一个游离的分支。</p><p>像这样，在update之后，分支变成了a58a3ae,而不再是master（master变成了游离状态）。</p><center><img src="/img/blog/blog-23-11.png" width=600></center><br><center><img src="/img/blog/blog-23-12.png" width=600></center><p>如果发生了这种情况，处理很简单，使用<code>git checkout master</code></p><center><img src="/img/blog/blog-23-13.png" width=600></center><p>正确的做法是使用<code>git submodule update --merge</code>，这个命令会告诉Git进行合并（前提是不发生冲突，如果发生了冲突请看下一节）。</p><center><img src="/img/blog/blog-23-14.png" width=600></center><h5 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h5><p><strong>注意：使用git push并不会提交子模块。</strong></p><p>为了防止这种错误发生，git推荐提交使用<code>git push --recurse-submodules=check</code>，如果没有提交子模块，会提示你使用两种方法完成子模块的提交。</p><ol><li>进入各个子模块目录使用<code>git push</code>提交各个子模块，然后提交你的项目。</li><li>使用<code>git push --recurse-submodules=on-demand</code>命令提交， 该命令会自动提交子模块，然后再提交你的项目。如果子模块提交失败，整个提交也会失败。</li></ol><center><img src="/img/blog/blog-23-15.png" width=600></center><p>到这里，子模块的使用就快基本完成了。最后一部分是最令人麻烦的conflict。</p><h4 id="5、解决submodule冲突"><a href="#5、解决submodule冲突" class="headerlink" title="5、解决submodule冲突"></a>5、解决submodule冲突</h4><p>解决冲突的步骤如下：</p><ol><li>进入子模块目录，解决冲突。（方法同解决正常的git冲突）</li><li>在子模块中提交解决冲突的记录。</li><li>切换到你的项目目录。</li><li>提交解决子模块冲突的记录。</li><li>推送到远程（如果需要）。</li></ol><center><img src="/img/blog/blog-23-16.png" width=600><p>git pull 发生冲突</p></center><br><center><img src="/img/blog/blog-23-17.png" width=600><p>找到冲突的文件</p></center><br><center><img src="/img/blog/blog-23-18.png" width=600><p>解决冲突，并在子模块目录提交记录</p></center><br><center><img src="/img/blog/blog-23-19.png" width=600><p>在父目录中提交子模块冲突的提交记录</p></center><br><center><img src="/img/blog/blog-23-20.png" width=600><p>成功推送到远程仓库</p></center><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>当然子模块还有些技巧，比如子模块遍历，命令别名等，见《pro git》。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;submodule的作用&quot;&gt;&lt;a href=&quot;#submodule的作用&quot; class=&quot;headerlink&quot; title=&quot;submodule的作用&quot;&gt;&lt;/a&gt;submodule的作用&lt;/h3&gt;&lt;p&gt;Git使用submodule(子模块)解决Git仓库的嵌套问
      
    
    </summary>
    
      <category term="Git" scheme="https://yx1302317313.github.io/categories/Git/"/>
    
    
      <category term="Tool" scheme="https://yx1302317313.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Python编码</title>
    <link href="https://yx1302317313.github.io/2019/10/19/qian-tan-python-bian-ma/"/>
    <id>https://yx1302317313.github.io/2019/10/19/qian-tan-python-bian-ma/</id>
    <published>2019-10-19T04:28:19.000Z</published>
    <updated>2020-06-15T10:50:25.406Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python的编码问题可能是很多人都遇到过的问题（没遇到的终将会遇到的），笔者之前也对这个问题很模糊，今天看了《Effective Python》之后总结一下自己的理解。</p></blockquote><a id="more"></a><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>先看ASCII码，ASCII码我们比较熟悉，用一个字节表示了128个字符，其中包含标点符号，数字，英文字母等。</p><p>但是ASCII有一个问题，就是一个字节只有8位最多只能表示256个字符，不可能表示世界各个国家的字符。于是有了Unicode码。</p><p>Unicode码（统一码，万国码）：用多个字节表示全世界的所有字符，为每一个字符分配了一个唯一的标识（一个整数），在表示一个 Unicode 的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。</p><p><strong>来自Wiki百科</strong>：在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8：由于Unicode只是给每一个字符分配了一个整数值，但是没有规定如何存储这个整数值（比如：用几个字节存储），所以需要utf-8等编码。utf-8是一种将Unicode码转换成字节序列编码方式，是一种可变长编码。</p><p>可以这样理解：</p><ul><li>Unicode -&gt; utf-8编码 -&gt; bytes</li><li>bytes -&gt; utf-8解码 -&gt; Unicode  </li></ul><p>UTF-8只是Unicode与字节流编码方式中的一种，还有UTF-16, GB-2312, GBK（windows系统的中文编码是GBK）编码等等。这些编码做的工作就是将Unicode规定字符对应的整数值用一个或多个字节表示出来。</p><p>因为IO，网络数据传输都是通过字节流的方式，所以在编程时需要将Unicode码转换成字节流再进行传输；同样需要将从IO，网络接收到的字节流转换成Unicode码。</p><h3 id="bytes、str与unicode"><a href="#bytes、str与unicode" class="headerlink" title="bytes、str与unicode"></a>bytes、str与unicode</h3><p>Python2和Python3的不同点之一就是编码问题。其中str和unicode是Python2中的编码，而bytes和str是Python3中的编码。</p><p>Python2中的编码：</p><ul><li>str：bytes序列的字符串</li><li>unicode：unicode码点序列 的字符串</li></ul><p>Python3中的编码：</p><ul><li>bytes: bytes序列的字符串。</li><li>str: unicode码点序列 的字符串。</li></ul><p>让人疑惑的是str，str在Python2和Python3中表示不同的编码，Python2中表示字节序列，即bytes; Python3中表示Unicode码。<strong>个人理解是Python3想让在程序中定义的字符串使用Unicode码表示，而不是Python2中用字节流表示。</strong></p><h4 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h4><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> string <span class="token operator">=</span> <span class="token string">"python"</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> u_str <span class="token operator">=</span> u<span class="token string">"python"</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>u_str<span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'unicode'</span><span class="token operator">></span></code></pre><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> string <span class="token operator">=</span> <span class="token string">"python"</span><span class="token operator">>></span><span class="token operator">></span> bytes <span class="token operator">=</span> b<span class="token string">"python"</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bytes'</span><span class="token operator">></span></code></pre><h3 id="encode与decode"><a href="#encode与decode" class="headerlink" title="encode与decode"></a>encode与decode</h3><blockquote><p>encode()和decode()是Python中用于bytes字节序列与Unicode序列转换的函数。</p></blockquote><ul><li>unicode.encode() -&gt; bytes:只有对于unicode对象我们才应该使用.encode()方法。这一方法用来将一系列unicode编码为bytes流。</li><li>bytes.decode() -&gt; unicode: 只有对于bytes，或说Python2中的str对象，我们才应该调用.decode()方法。这一方法将一系列bytes流解码为原本的unicode码点。</li></ul><h4 id="Python2-1"><a href="#Python2-1" class="headerlink" title="Python2"></a>Python2</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># str 与 unicode</span><span class="token operator">>></span><span class="token operator">></span> string <span class="token operator">=</span> <span class="token string">"python"</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> u_str <span class="token operator">=</span> u<span class="token string">"python"</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>u_str<span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'unicode'</span><span class="token operator">></span><span class="token comment" spellcheck="true"># str解码 -> Unicode</span><span class="token operator">>></span><span class="token operator">></span> de_string <span class="token operator">=</span> string<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>de_string<span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'unicode'</span><span class="token operator">></span><span class="token comment" spellcheck="true"># unicode 编码 -> str</span><span class="token operator">>></span><span class="token operator">></span> en_u_str <span class="token operator">=</span> u_str<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>en_u_str<span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'str'</span><span class="token operator">></span></code></pre><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># str 与 bytes</span><span class="token operator">>></span><span class="token operator">></span> string <span class="token operator">=</span> <span class="token string">"python"</span><span class="token operator">>></span><span class="token operator">></span> bytes <span class="token operator">=</span> b<span class="token string">"python"</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bytes'</span><span class="token operator">></span><span class="token comment" spellcheck="true"># str编码 -> butes</span><span class="token operator">>></span><span class="token operator">></span> en_string <span class="token operator">=</span> string<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>en_string<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bytes'</span><span class="token operator">></span><span class="token comment" spellcheck="true"># bytes 解码 -> str</span><span class="token operator">>></span><span class="token operator">></span> de_bytes <span class="token operator">=</span> bytes<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>de_bytes<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Python的编码问题可能是很多人都遇到过的问题（没遇到的终将会遇到的），笔者之前也对这个问题很模糊，今天看了《Effective Python》之后总结一下自己的理解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Language" scheme="https://yx1302317313.github.io/categories/Language/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="Python" scheme="https://yx1302317313.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>球状闪电[阅读]</title>
    <link href="https://yx1302317313.github.io/2019/10/07/qiu-zhuang-shan-dian/"/>
    <id>https://yx1302317313.github.io/2019/10/07/qiu-zhuang-shan-dian/</id>
    <published>2019-10-07T07:56:04.000Z</published>
    <updated>2020-06-15T10:39:37.502Z</updated>
    
    <content type="html"><![CDATA[<!-- <center><img src="/img/blog/blog-22-1.jpg" width=800></center> --><blockquote><p>考试周的时候重新看了刘慈欣的《球状闪电》，个人一直很喜欢这本书，甚至超过了《三体》。但是一直没时间为这本书写一点东西，趁机抓住国庆假期的尾巴，写写我的体会。</p></blockquote><a id="more"></a><center><img src="/img/blog/blog-27-balllightning.jpg" width=600></center><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次看《球状闪电》是一场意外。本来在看三体，第一部看完之后，应该是第二部《黑暗森林》。但是越看越不对，为什么和前面一点关系都没有，陈博士是干吗的？球状闪电是什么？</p><p>看了一半了才发现原来这个不是《黑暗森林》，而是《球状闪电》。<del>(论盗版小说的危害)</del>。但是看都看了，而且感觉写的不错，索性就看完了。可能当时还太年轻，没有太多感触，哈哈~~。不过对其中的一段话影响很深。</p><center>一片树林里分出两条路，<br>而我选了人迹更少的一条，<br>从此决定了我一生的道路。</center><p>这段话来自弗罗斯特的《未选择的路》， 考试周期间的一些事又让我想起了这段话，于是决定重新看一遍《球状闪电》。</p><p><strong>以下内容可能会因为记忆错误或者理解错误有所偏差，当然也有剧透噢</strong></p><h3 id="没有名字的男主"><a href="#没有名字的男主" class="headerlink" title="没有名字的男主"></a>没有名字的男主</h3><p>前一段时间一直在想男主的名字是什么，想了很长时间也没有想起来。<del>(疯狂怀疑自己的记忆力)</del>。之后查了才发现，原来刘慈欣根本就没有提及男主的名字，全书都是用“我”、“陈博士”叙述，卑微呀。</p><p>仔细想想男主确实挺惨的，少年时期父母因球状闪电双双去世；自己追寻球状闪电十几年，发现球状闪电原来是自然界最基本的物质，并不是自己所学能解决的；注定与自己喜欢的女孩无缘；没有林云的勇敢；没有丁仪对物理学的那份热爱与执着；甚至在林云的大尉男友面前都感到自惭形秽。</p><p>不过，他也是幸运的。和那些追寻球状闪电一生却连球状闪电都没有见过的人比起来，他简直是幸福的，他发现了球状闪电的秘密，甚至捕捉到了球状闪电。</p><blockquote><p>一个美妙的人生并不难，听爸爸教你：你选一个公认的世界难题，最好只用一张纸和一支铅笔的数学难题，比如哥德巴赫猜想或者费马大定理什么的，或连纸笔都不要的纯自然哲学难题，比如宇宙的本源之类，投入全部身心钻研，只问耕耘不问收获，不知不觉的专注中，一辈子也就过去了。</p></blockquote><p>上面的这段话是男主的父亲之前对他说的，男主的前半生可以说是做到了这一点，一直在追寻球状闪电的秘密。当然，这句话不仅在说男主，书中的很多人都在做着这样的事——用一生追寻一个问题或者一件事。像男主的老师那样终生寻找球状闪电之谜的人；对武器痴迷的林云少校；对物理学执着追求的丁仪教授…</p><h3 id="物理学家——六分仪"><a href="#物理学家——六分仪" class="headerlink" title="物理学家——六分仪"></a>物理学家——六分仪</h3><p>在发现球状闪电是自然界的基本物质之后，另外一位主角上场了——丁仪教授（很多人叫他六分仪，因为他出现在刘慈欣多部小说中，包括三体。每部小说中都是一个物理学家的身份，只不过研究领域不同）。</p><p>他的出现是因为主角这些搞应用科学的人根本没有办法解开自然界基本物质之谜，只能请“神仙”了。</p><blockquote><p>我们只能在牛顿、爱因斯坦、麦克斯韦这些人设定的框架中进行推演，不可能越雷池半步，否则就行步入没有空气的虚空一样，但在这个框架中，我们什么也推演不出来。</p></blockquote><p>这是另一句触动我的话，我相信只要是工科或者应用科学的人都多少会被这句话触动。对于工科或者应用科学的人来说，我们确实在那些伟大的科学家制定的框架中活着，很难越过雷池，甚至是不敢越过雷池。有些羡慕那些搞理论科学的人了，至少他们有机会“天马行空”。</p><p>丁仪的出现，很快解开了球状闪电之谜，<code>球状闪电是宏电子</code>。佩服刘慈欣的想象力，不过球状闪电的一些表现出来的现象还真的可以用量子力学解释。</p><p>我觉得他的解释还是有一定道理的（我对量子力学的了解有限）。至于球状闪电究竟是什么，我也不知道呀，毕竟对于现在的物理学，球状闪电还是个迷。不过是宏电子的可能性微乎其微（如果是，刘慈欣可以再拿一个诺贝尔物理学奖啦）</p><p>看完小说之后，我都想在有生之年见一次球状闪电了。据说河北邯郸曾经出现过。</p><h3 id="危险与魅力并存的美女少校"><a href="#危险与魅力并存的美女少校" class="headerlink" title="危险与魅力并存的美女少校"></a>危险与魅力并存的美女少校</h3><p>小说中另外一位主角就是林云少校了。她是国防科技大学的博士研究生，专业为防控武器系统。</p><p>这是陈博士第一次见到林云时的印象。</p><blockquote><p>雾散了一些，天上有稀疏的星星出现，这星光立刻映在她那清澈的双眸中，我出神地看着她眼中的星光，又赶紧将目光转向真正的星空。如果说我的人生是一部电影，那前面已经放映过的都是黑白色，今天，在泰山之巅，画面突然变成彩色的了。</p></blockquote><p><del>后半句是一句不错的情话。。。</del></p><p>你以为他们最后会在一起？你想多了。像林云这样的女孩，或者说想她这样的人感情不会成为他们最重要的东西，因为有一种东西已经占据了他们的方寸之地。</p><p>陈博士对丁仪的情人说过“有物理学在，谁在他（丁仪）心里都不可能是第一位的”。《球状闪电》中人物的性格还是很鲜明的。</p><p>对于林云来说，武器就是那样一种东西。</p><p>你很难想象一个女孩会痴迷于武器，会在本应该抱着洋娃娃的年纪抱着枪膛仍然发热的机枪，会把一个精致的小型地雷作为饰品挂在车前，会将一个由硅材料制成如剑般锋利的胸针戴在胸前，会偷偷研制液体地雷并出售给正在交战的两个国家。</p><p>她之所以痴迷于武器是因为她母亲。她父亲是一位将军，母亲同样是一位军人。但不幸的是她母亲在越战期间惨死于一种武器——杀人蜂。年幼的林云因此憎恨武器，不过慢慢地变成了痴迷。</p><p>林云最后为了强行进行宏聚变实验而坍缩成量子态。其实林云这个人物才像整本书的主角，因为她和球状闪电一样即危险又令人着迷。</p><h3 id="球状闪电"><a href="#球状闪电" class="headerlink" title="球状闪电"></a>球状闪电</h3><p>最后说说球状闪电。</p><p>球状闪电，俗称滚地雷。通常在雷暴时发生，为圆球形状的闪电。这是一种真实的物理现象。它十分亮，近圆球形，直径约15至40厘米不等。通常仅维持数秒，但也有维持了1至2分钟的记录。颜色除常见的橙色和红色外，还有黄色、紫色、蓝色、亮白色、幽绿色的光环，呈多种多样的色彩。</p><p>球状闪电的危害较大，它可以随气流起伏在近地空中自在飘飞或逆风而行。它可以通过开着的门窗进入室内，常见的是穿过烟囱后进入建筑物。它甚至可以在导线上滑动，有时会悬停，有时会无声消失，有时又会因为碰到障碍物爆炸。</p><p>球状闪电是形成雷电的电动趋势，在半击穿空气时产生的空气离子球。它其中携带能量，包裹相对稳定。当有导体破坏它的平衡时，它会和周围的空气中和，并释放出能量。</p><p>来源：百度百科。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>据说，刘慈欣写这本小说之前被查出疑似有癌症，于是他将《球状闪电》作为他的最后一本书来写，所以《球状闪电》的结局也比较凄美。不过，写完之后再查发现根本不是癌症。“重获新生”之后，刘慈欣开始构建三体世界。</p><h3 id="附：《未选择的路》"><a href="#附：《未选择的路》" class="headerlink" title="附：《未选择的路》"></a>附：《未选择的路》</h3><center>黄色的树林里分出两条路，<br>可惜我不能同时去涉足，<br>我在那路口久久伫立，<br>我向着一条路极目望去，<br>直到它消失在丛林深处。<br>但我却选了另外一条路，<br>它荒草萋萋，十分幽寂，<br>显得更诱人、更美丽，<br>虽然在这两条小路上，<br>都很少留下旅人的足迹，<br>虽然那天清晨落叶满地，<br>两条路都未经脚印污染。<br>呵，留下一条路等改日再见！<br>但我知道路径延绵无尽头，<br>恐怕我难以再回返。<br>也许多少年后在某个地方，<br>我将轻声叹息把往事回顾，<br>一片树林里分出两条路，<br>而我选了人迹更少的一条，<br>从此决定了我一生的道路。<br></center>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;center&gt;
&lt;img src=&quot;/img/blog/blog-22-1.jpg&quot; width=800&gt;
&lt;/center&gt; --&gt;

&lt;blockquote&gt;
&lt;p&gt;考试周的时候重新看了刘慈欣的《球状闪电》，个人一直很喜欢这本书，甚至超过了《三体》。但是一直没时间为这本书写一点东西，趁机抓住国庆假期的尾巴，写写我的体会。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="阅读" scheme="https://yx1302317313.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="书籍" scheme="https://yx1302317313.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="科幻" scheme="https://yx1302317313.github.io/tags/%E7%A7%91%E5%B9%BB/"/>
    
  </entry>
  
  <entry>
    <title>仙境蓬莱</title>
    <link href="https://yx1302317313.github.io/2019/10/07/xian-jing-peng-lai/"/>
    <id>https://yx1302317313.github.io/2019/10/07/xian-jing-peng-lai/</id>
    <published>2019-10-07T06:42:11.000Z</published>
    <updated>2020-06-15T10:45:43.287Z</updated>
    
    <content type="html"><![CDATA[<p>蓬莱市为山东省烟台市的一个县级市，位于渤海和黄海的交界之处。“八仙过海”的神话传说，便发生在这里。中国四大名楼之一的蓬莱阁也坐落在这里。</p><a id="more"></a><p><strong>多图预警，小心流量</strong></p><center><img src="/img/blog/blog-26-penglai1.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai2.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai3.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai4.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai5.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai6.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai7.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai8.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai9.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai10.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai11.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai12.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai13.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai14.jpg" width=500></center><br><center><img src="/img/blog/blog-26-penglai15.jpg" width=500></center><br><p>有没有感觉不对劲？</p><p>对，为什么有知乎的水印。当然是因为照片不是我拍的啦。</p><p>好吧，其实我没有照片，<strong>但我真真真真真的去了蓬莱</strong>，不过因为某些原因拍的照片没了。</p><p>原因就是你——<strong>华为手机</strong>。</p><p><em>你为什么在删除云端相册的时候会把本地相册也删了？</em></p><p><em>你为什么不提醒我？</em></p><p><em>你为什么要做这么鸡肋的一个云相册？</em></p><p><em>我为什么没备份？</em></p><p><em>我为什么要删除云相册？</em></p><p><em>我为什么还要清空回收站？</em></p><p><strong>一定注意：华为手机在删除云相册的时候本地相册也会被删除</strong></p><p>其他感受等心情好了再说……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;蓬莱市为山东省烟台市的一个县级市，位于渤海和黄海的交界之处。“八仙过海”的神话传说，便发生在这里。中国四大名楼之一的蓬莱阁也坐落在这里。&lt;/p&gt;
    
    </summary>
    
      <category term="远方" scheme="https://yx1302317313.github.io/categories/%E8%BF%9C%E6%96%B9/"/>
    
    
      <category term="Travel" scheme="https://yx1302317313.github.io/tags/Travel/"/>
    
  </entry>
  
  <entry>
    <title>自控力</title>
    <link href="https://yx1302317313.github.io/2019/10/07/zi-kong-li/"/>
    <id>https://yx1302317313.github.io/2019/10/07/zi-kong-li/</id>
    <published>2019-10-07T06:41:43.592Z</published>
    <updated>2020-06-15T10:55:18.413Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="自控力" scheme="https://yx1302317313.github.io/categories/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>Shadowsocks网络代理</title>
    <link href="https://yx1302317313.github.io/2019/09/17/shadowsocks-wang-luo-dai-li/"/>
    <id>https://yx1302317313.github.io/2019/09/17/shadowsocks-wang-luo-dai-li/</id>
    <published>2019-09-17T04:41:18.000Z</published>
    <updated>2020-06-15T10:45:01.321Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>昨天,在2019年网络安全周的第一天,搭建不到一个月的国外VPS被封了…特来记录一下最近的搭建过程.</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天荷兰和西雅图的VPS都被封了.期间还用traceroute(之后会介绍)分析了半天节点也没找到问题. 之后才知道是网络安全周. 据说, 网络安全周是特殊情况,之后可能会被解封.  <strong>Waiting…</strong></p><p> 再说使用国外VPS会不会被请去喝茶的问题. 只要是 <strong>正常访问</strong> Facebook,Google,YouTube之类的都没什么问题. 不过具体的我也不清楚,想知道请查阅国家法律或者咨询法律人士. 但是如果自己搭建网络代理然后出售VPN一类的东西好像是违法的,网上也有一些案例. 自己搭个服务器自己玩就行了,不要去碰这种生意. 还有也不要浏览什么政治敏感话题,更不要在这些方面发表不适合的言论.</p><h2 id="国外VPS购买"><a href="#国外VPS购买" class="headerlink" title="国外VPS购买"></a>国外VPS购买</h2><p>提供国外VPS的公司有很多, 比如Vultr, DigitalOcean, hostwinds等等.我用的是<a href="https://clients.hostwinds.com" target="_blank" rel="noopener">hostwinds</a>, 因为hostwinds相对比较便宜, 最低配版一个月$4.49元. 不过大部分价格差不多,每个月5美元左右. 有的也提供一些更便宜的服务器, 比如3美元左右, 但是现在基本已经售空了, 一般很难抢到. 如果你发现了一定要快点下手, 并且通过邮箱通知我一下. 哈哈…</p><p>对于服务器配置, 如果只是自己搭建Shadowsocks, 搭建个人博客, 做FTP, 做图床等等, 最低配就够用了. </p><p>下图是某网站发布的2019国外VPS服务商排行, 可以参考一下, 然后根据自己的需求选择即可.</p><center><img src="/img/blog/blog-20-1.png"></center><h2 id="Shadowsocks服务端搭建"><a href="#Shadowsocks服务端搭建" class="headerlink" title="Shadowsocks服务端搭建"></a>Shadowsocks服务端搭建</h2><p>买完服务器之后就可以开始Shadowsocks服务器的搭建了. </p><p>通过ssh远程登录服务器 <del>(既然都准备自己搭建服务器了, 这个应该都会吧)</del>. 可以先对服务器配置一下, 再开始.</p><ul><li>创建个普通用户, 尽量少用root用户.</li><li>换换终端, 强烈推荐zsh, 让终端操作更加丝滑.</li><li>…</li></ul><p>好了, 正式开始!</p><ol><li><p>服务器上安装Shadowsocks, 下面是一个一键安装脚本. 在终端运行下面的命令</p><pre class=" language-sh"><code class="language-sh">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2>&1 | tee shadowsocks-all.log</code></pre></li><li><p>运行之后需要选择一些选项</p><ul><li>选择ss服务端的版本, 有Python, R, 和Go等等, 我选择的是Go.</li><li>输入密码: 输入自己想要设定的密码.</li><li>输入端口: 回车默认.</li><li>输入加密方式: 同样选默认, 回车.</li></ul></li><li><p>按任意健开始, 或者按Ctrl + C 取消. 当然是开始了.</p></li><li><p>等待安装完成. 然后将ip, 端口等信息截图保存一下.</p></li><li><p>完成, Enjoy it!</p></li></ol><p><strong>[注意]</strong>: 密码,端口和加密方式需要记住, 因为配置客户端时要用. 安装完成后会显示这些信息, 到时候截个图就可以. 同时会生成一个二维码, 可以使用手机扫描, 或者使用电脑读取二维码配置客户端. 至于怎么把二维码从服务器下载下来… 可以利用vsftpd搭一个FTP服务器, 然后下载. 不过这里使用手动配置.</p><p>完成之后可以看一下ss服务是否启动</p><pre class=" language-sh"><code class="language-sh">$ systemctl list-units --type=service | grep Shadowsocks</code></pre><p>如果看到有Shadowsocks服务, 并且状态是active和running, 则服务已经启动. 服务端配置就完成了.</p><h2 id="Shadowsocks客户端"><a href="#Shadowsocks客户端" class="headerlink" title="Shadowsocks客户端"></a>Shadowsocks客户端</h2><p>在Github上有各个平台的Shadowsocks客户端. <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">Shadowsocks</a></p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>国内的应用商店肯定是没有shadowsocks应用的, 直接下github上的apk安装包安装即可.<del>(不过墙内好像下载速度极慢)</del>.</p><p>打开Android端Shadowsocks.</p><center><img src="/img/blog/blog-21-1.jpg" height=500></center><p>点击右上角的添加图标, 选择手动设置.</p><center><img src="/img/blog/blog-21-2.jpg" height=500></center><p>现在就用到之前保留的截图了, 按照服务器的配置信息依次设置服务器IP, 服务器端口, 密码, 以及加密方式.</p><p><strong>[注意]</strong>: 最下面的路由选择 <strong>绕过局域网及中国大陆地址</strong> , 这样访问局域网的网址和大陆网址时不使用代理. 你访问国内网站, 总不想绕大半个地球到欧洲或者北美再回来吧.</p><p>还有, 国内某些网站是不对国外的IP提供服务的, 比如网易云音乐, 如果使用国外的IP访问, 不能播放音乐, 更不能下载了.</p><center><img src="/img/blog/blog-21-3.jpg" height=500></center><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows安装之后, 打开应用之后会直接显示在底栏的右下角. 右键进行手动配置, 基本同Android端配置一样.</p><p>同样, 为了访问局域网的网址和大陆网址时不使用代理, 也需要进行相应的配置, 在右键菜单中找到系统代理这一项, 将默认的全局模式改为PAC模式.</p><p>由于电脑上没有Windows系统, 就不截图了. Windows具体配置见<a href="https://github.com/Shadowsocks-Wiki/shadowsocks/blob/master/2-windows-setup-guide-cn.md" target="_blank" rel="noopener">Windows Shadowsocks配置</a>.</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><blockquote><p>Linux当然是最”麻烦”的了.</p></blockquote><p>我的Linux发行版是Ubuntu18，不同发行版之间操作可能不同。</p><h4 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h4><ol><li><p>打开设置-&gt;网络-&gt;网络代理</p></li><li><p>选择网络代理中的手动代理，再选择sockts主机为本地IP地址：172.0.0.1，端口为1080。具体设置见下图</p></li></ol><center><img src="/img/blog/blog-21-7.png"></center><h5 id="终端的全局代理"><a href="#终端的全局代理" class="headerlink" title="终端的全局代理"></a>终端的全局代理</h5><p>在shell的配置文件(.bashrc、.zshrc等等)中添加下面内容</p><pre class=" language-sh"><code class="language-sh">export http_proxy="socks5://127.0.0.1:1080"export https_proxy="socks5://127.0.0.1:1080"</code></pre><p><strong>目前还没有找到终端使用PAC代理的方法，我在终端使用的还是全局代理。。。</strong></p><h4 id="PAC代理"><a href="#PAC代理" class="headerlink" title="PAC代理"></a>PAC代理</h4><blockquote><p>PAC，一个自动代理配置脚本，包含了很多使用 JavaScript 编写的规则，它能够决定网络流量走默认通道还是代理服务器通道，控制的流量类型包括：HTTP、HTTPS 和 FTP。</p></blockquote><h5 id="系统的PAC代理"><a href="#系统的PAC代理" class="headerlink" title="系统的PAC代理"></a>系统的PAC代理</h5><ul><li>安装pip（很多人可能已经装了）</li></ul><pre class=" language-sh"><code class="language-sh">sudo apt-get install python-pip python-dev build-essential sudo pip install --upgrade pip sudo pip install --upgrade virtualenv</code></pre><ul><li>安装genpac</li></ul><pre class=" language-sh"><code class="language-sh">sudo pip install genpac</code></pre><ul><li>建立一个存放pac文件的目录，进入该目录。（注意，在执行时需挂系统代理 sock5，否则会出现获取 gfwlist 失败的情况）</li></ul><pre class=" language-sh"><code class="language-sh">genpac --proxy="SOCKS5 127.0.0.1:1080" --gfwlist-proxy="SOCKS5 127.0.0.1:1080" -o autoproxy.pac --gfwlist-url="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" </code></pre><ul><li>选择网络代理中的自动代理，url 填写刚生成的 pac 文件的路径file:///path/autoproxy.pac (# 这个文件是一个JS脚本文件，里面存放着目前大部分被gfw屏蔽的域名)，<strong>如果有需要添加的域名，可以自己手动添加进去。</strong></li></ul><h5 id="Chrome的PAC代理"><a href="#Chrome的PAC代理" class="headerlink" title="Chrome的PAC代理"></a>Chrome的PAC代理</h5><ol><li>安装chrome插件SwitchyOmega</li><li>打开SwitchyOmega配置</li><li>新建情景模式，选择PAC情景模式</li><li>在PAC脚本内复制下载的PAC文件的内容，也可以通过填写PAC网址从网站下载PAC文件。</li><li>选择SwitchyOmega的模式是刚刚新建的情景模式。</li></ol><h5 id="Firefox的PAC代理"><a href="#Firefox的PAC代理" class="headerlink" title="Firefox的PAC代理"></a>Firefox的PAC代理</h5><ol><li>打开：设置 -&gt;首选项 -&gt;常规 -&gt;最下方的网络设置。</li><li>点击设置-&gt; 选择自动代理配置URL（PAC）</li><li>填写下载的PAC文件的路径，例如： file:///path/autoproxy.pac</li><li>确认</li></ol><h2 id="traceroute分析"><a href="#traceroute分析" class="headerlink" title="traceroute分析"></a>traceroute分析</h2><blockquote><p>说说traceroute, 这是一个Linux命令(在Windows下相应命令为tracert). 它的作用就是跟踪消息在网络核心之间的传输, 也就是在各个路由器之间的传输. 通过这个命令我们可以看到网络传输中的时延和丢包现象.</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>traceroute主要使用了IP头部生存时间(time to live, TTL), TTL值在每经过一个路由之后会减去1, 当TTL值为0时, 路由器认为发送超时, 将报文丢弃并向源主机发送ICMP超时差错报文. 报文中包含了路由器的IP.</p><p>利用TTL的这种工作原理, traceroute可以依次得到每一个路由器的IP地址.</p><ul><li>源主机将TTL值设置为1发送报文, 在报文到达第一个路由器时, $TTL - 1 = 0$, 于是路由器认为超时, 发送一份ICMP超时差错报文给源主机, 得到第一个路由器的IP.</li><li>源主机再将TTL值设置为2发送报文, 同理得到第二个路由器的IP地址.</li><li>…</li><li>当报文到达目的主机时, 由于traceroute通过UDP数据包向不常见端口发送数据包，因此会收到目的主机ICMP port unreachable消息，故可判断到达目的地。</li><li>停止发送报文.</li></ul><p>通过上述方法可以得到从源主机到目的主机过程中各个路由器的IP地址, 由于源主机收到路由器或者目的主机的消息所用的时间是从源主机到路由器或者目的主机的2倍, 可以简单的将这个时间除以2得到从源主机到路由器或者目的主机的时间. 通过这个时间我们可以分析传输时延和丢包现象.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是traceroute访问百度的过程, 其中*表示丢包.</p><center><img src="/img/blog/blog-21-4.png" width=800></center><p>访问cnn, 其中202.97.50.54是电信主干网, 之后的一个IP 38.104.138.105就已经到了美国了.</p><center><img src="/img/blog/blog-21-5.png" width=800></center><p>再看youtube, 在电信主干网就挂掉了, 连走出国门的机会都没有(-_-).</p><center><img src="/img/blog/blog-21-6.png" width=800></center>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;昨天,在2019年网络安全周的第一天,搭建不到一个月的国外VPS被封了…特来记录一下最近的搭建过程.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Network" scheme="https://yx1302317313.github.io/categories/Network/"/>
    
    
      <category term="Shadowsocks" scheme="https://yx1302317313.github.io/tags/Shadowsocks/"/>
    
      <category term="Server" scheme="https://yx1302317313.github.io/tags/Server/"/>
    
  </entry>
  
</feed>
