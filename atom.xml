<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YuanXu&#39;s Blog</title>
  
  <subtitle>天之道, 利而不害; 人之道, 为而不争.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yx1302317313.github.io/"/>
  <updated>2019-11-16T13:54:57.523Z</updated>
  <id>https://yx1302317313.github.io/</id>
  
  <author>
    <name>Yuan Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 管道通信</title>
    <link href="https://yx1302317313.github.io/2019/11/14/Linux-Pipe/"/>
    <id>https://yx1302317313.github.io/2019/11/14/Linux-Pipe/</id>
    <published>2019-11-14T10:42:32.000Z</published>
    <updated>2019-11-16T13:54:57.523Z</updated>
    
    <content type="html"><![CDATA[<!--more## 系统调用 fork在linux系统中创建进程有两种方式- 一是由操作系统创建。- 二是由父进程创建进程。系统调用函数fork()是创建一个新进程的唯一方式。fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程。1. 系统先给新的进程分配资源，例如存储数据和代码的空间。2. 然后把原来的进程（父进程）的所有值都复制到新的新进程（子进程）中，只有少数值与原来的进程的值不同。3. Linux的fork()采用写时拷贝实现，只有子进程发起写操作时才正真执行拷贝，在写时拷贝之前都是以只读的方式共享。这样可以避免发生拷贝大量数据而不被使用的情况。fork是Linux系统中一个比较特殊的函数，其一次调用会有两个返回值。在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。如果失败返回值是1。- 在子进程中，fork函数返回0。- 在父进程中，fork返回新创建子进程的进程ID。因此我们可以通过fork返回的值来判断当前进程是子进程还是父进程。## 管道Linux中，每个管道允许两个进程交互数据，一个进程向管道写入数据，一个进程从管道读出数据。Linux并没有给管道定义一个新的数据结构，而是借用了文件系统中文件的数据结构。即管道实际是一个文件（但是与文件并不完全形同）。操作系统在内存中为每个管道开辟一页内存（4KB），给这一页赋予了文件的属性。这一页内存由两个进程共享，但不会分配给任何进程，只由内核掌控。### 示例> Linux pipe手册中的例子```c#include <sys/types.h>#include <sys/wait.h>#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <string.h>int main(int argc, char *argv[]){        int pipefd[2];        pid_t cpid;        char buf;        if (argc != 2)        {                fprintf(stderr, "Usage: %s <string>\n", argv[0]);                exit(EXIT_FAILURE);        }        if (pipe(pipefd) == -1)        {                perror("pipe");                exit(EXIT_FAILURE);        }        cpid = fork();        if (cpid == -1)        {                perror("fork");                exit(EXIT_FAILURE);        }        if (cpid == 0)        {                         /* Child reads from pipe */                close(pipefd[1]); /* Close unused write end */                while (read(pipefd[0], &buf, 1) > 0)                        write(STDOUT_FILENO, &buf, 1);                write(STDOUT_FILENO, "\n", 1);                close(pipefd[0]);                _exit(EXIT_SUCCESS);        }        else        {                         /* Parent writes argv[1] to pipe */                close(pipefd[0]); /* Close unused read end */                write(pipefd[1], argv[1], strlen(argv[1]));                close(pipefd[1]); /* Reader will see EOF */                wait(NULL);       /* Wait for child */                exit(EXIT_SUCCESS);        }}```![](http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/inter-process-communication/pipe/%E6%A0%B7%E4%BE%8B%E7%A4%BA%E5%9B%BE.png)### 管道的读写- 读管道进程执行时，如果管道中有未读数据，就读取数据，没有未读数据就挂起，这样就不会读取垃圾数据。- 写管道进程执行时，如果管道中有剩余空间，就写入数据，没有剩余空间了，就挂起，这样就不会覆盖尚未读取的数据。#### 读管道对于读管道操作，数据是从管道尾读出，并使管道尾指针前移‘读取字节数’个位置。![](http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/inter-process-communication/pipe/%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png)Linux 0.11 源码```c//fs/pipe.cint read_pipe(struct m_inode * inode, char * buf, int count){    int chars, size, read = 0;    while (count>0) {        while (!(size=PIPE_SIZE(*inode))) {    //管道空            wake_up(&inode->i_wait);    //唤醒等待写管道进程            if (inode->i_count != 2) /* are there any writers? */                return read;            //没有writer，返回            sleep_on(&inode->i_wait);    //挂起读管道进程        }        chars = PAGE_SIZE-PIPE_TAIL(*inode);    //PAGE_SIZE: 4KB         if (chars > count)            chars = count;        if (chars > size)            chars = size;        count -= chars;        read += chars;        size = PIPE_TAIL(*inode);        PIPE_TAIL(*inode) += chars;     // 读多少数据，指针就偏移多少        PIPE_TAIL(*inode) &= (PAGE_SIZE-1);     // 指针超过一个页面，（&= ）操作可以实现自动回滚        while (chars-- >0)            put_fs_byte(((char *)inode->i_size)[size++],buf++);     //将管道中的数据拷贝至buf    }    wake_up(&inode->i_wait);    //唤醒等待写管道进程    return read;}// include/linux/fs.h#define PIPE_HEAD(inode) ((inode).i_zone[0])#define PIPE_TAIL(inode) ((inode).i_zone[1])//PIPE_HEAD(inode)-PIPE_TAIL(inode) < 0，和 (PAGE_SIZE-1) 相与能够计算出管道未读数据的长度#define PIPE_SIZE(inode) ((PIPE_HEAD(inode)-PIPE_TAIL(inode))&(PAGE_SIZE-1))```#### 写管道对于写管道操作，数据是向管道头部写入，并使管道头指针前移‘写入字节数’个位置。Linux 0.11 源码```c//fs/pipe.cint write_pipe(struct m_inode * inode, char * buf, int count){    int chars, size, written = 0;    while (count>0) {        while (!(size=(PAGE_SIZE-1)-PIPE_SIZE(*inode))) {   //管道已满            wake_up(&inode->i_wait);         //唤醒等待读管道进程            if (inode->i_count != 2) { /* no readers */                current->signal |= (1<<(SIGPIPE-1));                return written?written:-1;      //没有reader，返回            }            sleep_on(&inode->i_wait);       //挂起写管道进程        }        chars = PAGE_SIZE-PIPE_HEAD(*inode);        if (chars > count)            chars = count;        if (chars > size)            chars = size;        count -= chars;        written += chars;        size = PIPE_HEAD(*inode);        PIPE_HEAD(*inode) += chars;        PIPE_HEAD(*inode) &= (PAGE_SIZE-1);     // 指针超过一个页面，（&= ）操作可以实现自动回滚        while (chars-- >0)            ((char *)inode->i_size)[size++]=get_fs_byte(buf++); //读取buf中的数据写入管道    }    wake_up(&inode->i_wait);    //唤醒等待读管道进程    return written;}// include/linux/fs.h#define PIPE_HEAD(inode) ((inode).i_zone[0])#define PIPE_TAIL(inode) ((inode).i_zone[1])//PIPE_HEAD(inode)-PIPE_TAIL(inode) < 0，和 (PAGE_SIZE-1) 相与能够计算出管道未读数据的长度#define PIPE_SIZE(inode) ((PIPE_HEAD(inode)-PIPE_TAIL(inode))&(PAGE_SIZE-1))```### 管道的特点- 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；- 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；- 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。- 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。### 管道的局限性- 只支持单向数据流。- 只能用于具有亲缘关系的进程之间。- 没有名字（有名管道是 FIFO）。- 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）。- 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）。- ...## 双向管道通信1. 父进程创建两个管道,pipe1和pipe2.2. 父进程创建子进程,调用fork()的过程中子进程会复制父进程创建的两个管道.3. 实现父进程向子进程通信:父进程关闭pipe1的读端,保留写端;而子进程关闭pipe1的写端,保留读端.4. 实现子进程向父进程通信:子进程关闭pipe2的读端,保留写端;而父进程关闭pipe2的写端,保留读端.```c#include <sys/types.h>#include <sys/wait.h>#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <string.h>int main(int argc, char *argv[]){        int pipe_command[2];    //管道1 父进程 -> 子进程        int pipe_result[2];     //管道2 子进程 -> 父进程         pid_t cpid;        char buf[4];        //父进程创建管道        if (pipe(pipe_command) == -1)        {                perror("pipe_command");                exit(EXIT_FAILURE);        }        if(pipe(pipe_result) == -1)        {                perror("pipe_result");                exit(EXIT_FAILURE);        }        //创建子进程        cpid = fork();        if (cpid == -1)        {                perror("fork error");                exit(EXIT_FAILURE);        }        if (cpid == 0)  /*子进程*/        {                                        printf("sub: pid %d\n", getpid());      //输出子进程ID                close(pipe_command[1]);         //关闭管道写端                close(pipe_result[0]);            //关闭管道读端                int read_status;                while (1)                {                        read_status =  read(pipe_command[0], buf, 4);   //读取父进程的命令                        if(read_status > 0)                        {                                printf("sub: command %s\n", buf);                                if(strcmp(buf, "hell") == 0)                                {                                                                                write(pipe_result[1], "okok", 4);       //回应父进程                                }                                else if( strcmp(buf, "exit") == 0)                                {                                        printf("sub: exit\n");                                        break;                                }                         }                                               else if(read_status < 0)        //读取错误                        {                                perror("sub: read error!");                                break;                        }                                                       }                        close(pipe_command[0]); //关闭管道                close(pipe_result[1]);                exit(EXIT_SUCCESS);        }        else    /*父进程*/        {                printf("parent: pid %d\n", getpid());      //输出父进程ID                close(pipe_command[0]); //关闭管道读端                close(pipe_result[1]);  //关闭管道写端                write(pipe_command[1], "hell", 4);      //向子进程发送命令                 int read_status;                while (1)                {                        read_status = read(pipe_result[0], buf, 4);                        if(read_status > 0)                        {                                printf("parent: received %s\n", buf);           //接收子进程回应                                write(pipe_command[1], "exit", 4);      //通知子进程退出                                break;                        }                                                      else if(read_status < 0)         //读取错误                        {                                perror("parent: read error!");                                break;                        }                                                                          }                close(pipe_command[1]);                 close(pipe_result[0]);                /* 等待子进程退出,并判断状态吗码*/                int status;                waitpid(-1, &status , 0);                             if(WIFEXITED(status))                {                        printf("exited: %d\n", WEXITSTATUS(status));                }                                                else if(WIFSIGNALED(status))                {                        printf("signaled: %d\n", WTERMSIG(status));                }                exit(EXIT_SUCCESS);        }}```## 参考1. 《Linux内核设计的艺术》2. 《Linux内核设计与实现》3.  Linux v0.11内核源码(https://github.com/karottc/linux-0.11)-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--more
## 系统调用 fork
在linux系统中创建进程有两种方式
- 一是由操作系统创建。
- 二是由父进程创建进程。系统调用函数fork()是创建一个新进程的唯一方式。

fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程。

1. 系统先给新的进
      
    
    </summary>
    
      <category term="Linux" scheme="https://yx1302317313.github.io/categories/Linux/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
      <category term="kernel" scheme="https://yx1302317313.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Git 的子模块（submodule）</title>
    <link href="https://yx1302317313.github.io/2019/11/09/Git-%E7%9A%84%E5%AD%90%E6%A8%A1%E5%9D%97%EF%BC%88submodule%EF%BC%89/"/>
    <id>https://yx1302317313.github.io/2019/11/09/Git-的子模块（submodule）/</id>
    <published>2019-11-09T14:22:32.000Z</published>
    <updated>2019-11-16T13:45:51.951Z</updated>
    
    <content type="html"><![CDATA[<h3 id="submodule的作用"><a href="#submodule的作用" class="headerlink" title="submodule的作用"></a>submodule的作用</h3><blockquote><p>Git使用submodule(子模块)解决git仓库的嵌套问题，允许一个 Git 仓库作为另一个 Git 仓库的子目录。 能在将另一个仓库克隆到自己的项目中的同时,保持项目提交的独立性。详细参见<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">《pro git》子模块</a></p></blockquote><h3 id="submodule的原理"><a href="#submodule的原理" class="headerlink" title="submodule的原理"></a>submodule的原理</h3><blockquote><p>submodule的实现很巧妙也很简单。其实submodule对于原本的git仓库只是多添加了一条或者几条记录(在.gitmodule中),它记录了仓库中包含的子模块的名称和URL.</p><p>当需要使用子模块的文件时，通过指定的URL使用HTTP协议下载到本地，同样如果对子模块里的内容做出修改之后，通过该URL可以提交到子模块的远程仓库（而不是提交到你的仓库），而本地仓库只是修改了一条记录（其实只是修改了指向子模块仓库的分支）。</p></blockquote><h3 id="使用submodule"><a href="#使用submodule" class="headerlink" title="使用submodule"></a>使用submodule</h3><h4 id="1、新建submodule"><a href="#1、新建submodule" class="headerlink" title="1、新建submodule"></a>1、新建submodule</h4><p>使用<code>git submodule add</code>添加新的子模块</p><pre><code class="lang-sh">$ git submodule add &quot;URL&quot;</code></pre><p>下图演示了添加名为Game的子模块</p><center><img src="/img/blog/blog-23-1.png" width="600"></center><p>之后会发现目录下多了一个Game目录和.gitmodules的文件。其中Game目录下是你所希望包含项目的分支代码，而gitmodules的内容如下。也就是之前提到的submodule使用子模块的名称和URL记录本仓库包含的子模块。</p><pre><code>[submodule &quot;Game&quot;]    path = Game    url = https://github.com/yx1302317313/Game.git</code></pre><p>提交之后查看远程仓库会发现添加的子模块的文件并没有传到远程仓库，子模块的文件夹实际是一个URL，指向了包含子模块本身的远程仓库。</p><center><img src="/img/blog/blog-23-2.png" width="600"></center><h4 id="2、克隆包含submodule的项目"><a href="#2、克隆包含submodule的项目" class="headerlink" title="2、克隆包含submodule的项目"></a>2、克隆包含submodule的项目</h4><p>当使用<code>git clone</code>克隆一个包含子模块的项目时，子模块的文件并不会一同并拉取到本地，而只是一个空目录。</p><center><img src="/img/blog/blog-23-3.png" width="600"></center><p>这时需要使用<code>git submodule init</code>用来初始化本地配置文件,而 <code>git submodule update</code>则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p><center><img src="/img/blog/blog-23-4.png" width="600"></center><p><br></p><center><img src="/img/blog/blog-23-5.png" width="600"></center><p>一个更简单的方法是给<code>git clone</code>加上递归选项<code>--recursive</code></p><pre><code class="lang-sh">$ git clone --recursive &quot;URL&quot; # 自动初始化并更新仓库中的每一个子模块</code></pre><p><strong>[注意]：</strong> 由于git的子模块跟踪的是提交记录(commit id)，所以拉取下来的是一个游离分支，其实是将一个提交记录作为了一个游离的分支。这时候还需要切换到master分支。</p><pre><code class="lang-sh">$ cd Game$ git checkout master</code></pre><p>所以整个克隆的步骤如下：</p><ol><li>克隆远程仓库：git clone “URL”</li><li>初始化子模块：git submodule init</li><li>拉取子模块的内容：git submodule update</li><li>进入子模块切换至主分支: git checkout master</li></ol><h4 id="3、更新submodule"><a href="#3、更新submodule" class="headerlink" title="3、更新submodule"></a>3、更新submodule</h4><ol><li>进入submodule的目录。</li><li>使用<code>git fetch</code>和<code>git merge</code>更新submodule,与远程仓库的最新代码合并（当然也可以直接使用<code>git pull</code>）。</li></ol><h5 id="关于-git-fetch-与-git-pull"><a href="#关于-git-fetch-与-git-pull" class="headerlink" title="关于 git fetch 与 git pull"></a>关于 git fetch 与 git pull</h5><blockquote><p>git pull = git fetch + git merge, 可以参考<a href="https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch" target="_blank" rel="noopener">stack overflow</a></p></blockquote><p><strong>更简单的方式</strong>：运行<code>git submodule update--remote</code>, 使用该命令Git将会进入子模块然后进行抓取并更新。</p><p><strong>注意：该命令默认fetch和merge主分支（master），如果是其他分支，需要进行配置（见《pro git》）。</strong></p><h4 id="4、修改并提交submodule"><a href="#4、修改并提交submodule" class="headerlink" title="4、修改并提交submodule"></a>4、修改并提交submodule</h4><h5 id="提交前的fetch"><a href="#提交前的fetch" class="headerlink" title="提交前的fetch"></a>提交前的fetch</h5><p>当修改了submodule的文件时，这里有一个需要注意的地方。一般我们在提交之前都需要查看远程分支是否有更新，会不会有冲突。我们的方法是使用<code>git fetch</code>抓取远程分支查看是否更新然后进行<code>git merge</code>。（使用<code>git pull</code>也没什么太大的问题）。</p><p>需要注意的地方是<code>git submodule update</code>，之前提到这个命令也可以完成上面的功能，还更方便。</p><p>但是《pro git》中提到</p><blockquote><p>当我们运行 git submodule update 从子模块仓库中抓取修改时,Git 将会获得这些改动并更新子目录中的文件,但是会将子仓库留在一个称作“游离的 HEAD”的状态。 这意味着没有本地工作分支(例如“master” )跟踪改动。 所以你做的任何改动都不会被跟踪。</p></blockquote><p>这段话感觉很难理解，英文版说的更直接一点。</p><blockquote><p>So far, when we’ve run the git submodule update command to fetch changes from the submodule repositories, Git would get the changes and update the files in the subdirectory but will leave the sub-repository in what’s called a “detached HEAD” state. This means that there is no local working branch (like “master”, for example) tracking changes. With no working branch tracking changes, that means even if you commit changes to the submodule, those changes will quite possibly be lost the next time you run git submodule update. You have to do some extra steps if you want changes in a submodule to be tracked.</p></blockquote><p>关键是这句话</p><blockquote><p> With no working branch tracking changes, that means even if you commit changes to the submodule, those changes will quite possibly be lost the next time you run git submodule update. </p></blockquote><p>意思就是如果远程仓库发生了改动，并且你本地有未推送到远程仓库的提交（commit），执行<code>git submodule update</code>后你的提交并不会与远程仓库进行合并（merge）。而是成为了一个游离的分支。</p><p>像这样，在update之后，分支变成了a58a3ae,而不再是master（master变成了游离状态）。</p><center><img src="/img/blog/blog-23-11.png" width="600"></center><p><br></p><center><img src="/img/blog/blog-23-12.png" width="600"></center><p>如果发生了这种情况，处理很简单，使用<code>git checkout master</code></p><center><img src="/img/blog/blog-23-13.png" width="600"></center><p>正确的做法是使用<code>git submodule update --merge</code>，这个命令会告诉Git进行合并（前提是不发生冲突，如果发生了冲突请看下一节）。</p><center><img src="/img/blog/blog-23-14.png" width="600"></center><h5 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h5><p><strong>注意：使用git push并不会提交子模块。</strong></p><p>为了防止这种错误发生，git推荐提交使用<code>git push --recurse-submodules=check</code>，如果没有提交子模块，会提示你使用两种方法完成子模块的提交。</p><ol><li>进入各个子模块目录使用<code>git push</code>提交各个子模块，然后提交你的项目。</li><li>使用<code>git push --recurse-submodules=on-demand</code>命令提交， 该命令会自动提交子模块，然后再提交你的项目。如果子模块提交失败，整个提交也会失败。</li></ol><center><img src="/img/blog/blog-23-15.png" width="600"></center><p>到这里，子模块的使用就快基本完成了。最后一部分是最令人麻烦的conflict。</p><h4 id="5、解决submodule冲突"><a href="#5、解决submodule冲突" class="headerlink" title="5、解决submodule冲突"></a>5、解决submodule冲突</h4><p>解决冲突的步骤如下：</p><ol><li>进入子模块目录，解决冲突。（方法同解决正常的git冲突）</li><li>在子模块中提交解决冲突的记录。</li><li>切换到你的项目目录。</li><li>提交解决子模块冲突的记录。</li><li>推送到远程（如果需要）。</li></ol><center><img src="/img/blog/blog-23-16.png" width="600"><p>git pull 发生冲突</p></center><p><br></p><center><img src="/img/blog/blog-23-17.png" width="600"><p>找到冲突的文件</p></center><p><br></p><center><img src="/img/blog/blog-23-18.png" width="600"><p>解决冲突，并在子模块目录提交记录</p></center><p><br></p><center><img src="/img/blog/blog-23-19.png" width="600"><p>在父目录中提交子模块冲突的提交记录</p></center><p><br></p><center><img src="/img/blog/blog-23-20.png" width="600"><p>成功推送到远程仓库</p></center><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>当然子模块还有些技巧，比如子模块遍历，命令别名等，见《pro git》。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;submodule的作用&quot;&gt;&lt;a href=&quot;#submodule的作用&quot; class=&quot;headerlink&quot; title=&quot;submodule的作用&quot;&gt;&lt;/a&gt;submodule的作用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Git使用submodule(子模
      
    
    </summary>
    
      <category term="Git" scheme="https://yx1302317313.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈Python编码</title>
    <link href="https://yx1302317313.github.io/2019/10/19/%E6%B5%85%E8%B0%88Python%E7%BC%96%E7%A0%81/"/>
    <id>https://yx1302317313.github.io/2019/10/19/浅谈Python编码/</id>
    <published>2019-10-19T04:28:19.000Z</published>
    <updated>2019-10-19T08:51:44.191Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python的编码问题可能是很多人都遇到过的问题（没遇到的终将会遇到的），笔者之前也对这个问题很模糊，今天看了《Effective Python》之后总结一下自己的理解。</p></blockquote><a id="more"></a><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>先看ASCII码，ASCII码我们比较熟悉，用一个字节表示了128个字符，其中包含标点符号，数字，英文字母等。</p><p>但是ASCII有一个问题，就是一个字节只有8位最多只能表示256个字符，不可能表示世界各个国家的字符。于是有了Unicode码。</p><p>Unicode码（统一码，万国码）：用多个字节表示全世界的所有字符，为每一个字符分配了一个唯一的标识（一个整数），在表示一个 Unicode 的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。</p><p><strong>来自Wiki百科</strong>：在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8：由于Unicode只是给每一个字符分配了一个整数值，但是没有规定如何存储这个整数值（比如：用几个字节存储），所以需要utf-8等编码。utf-8是一种将Unicode码转换成字节序列编码方式，是一种可变长编码。</p><p>可以这样理解：</p><ul><li>Unicode -&gt; utf-8编码 -&gt; bytes</li><li>bytes -&gt; utf-8解码 -&gt; Unicode  </li></ul><p>UTF-8只是Unicode与字节流编码方式中的一种，还有UTF-16, GB-2312, GBK（windows系统的中文编码是GBK）编码等等。这些编码做的工作就是将Unicode规定字符对应的整数值用一个或多个字节表示出来。</p><p>因为IO，网络数据传输都是通过字节流的方式，所以在编程时需要将Unicode码转换成字节流再进行传输；同样需要将从IO，网络接收到的字节流转换成Unicode码。</p><h3 id="bytes、str与unicode"><a href="#bytes、str与unicode" class="headerlink" title="bytes、str与unicode"></a>bytes、str与unicode</h3><p>Python2和Python3的不同点之一就是编码问题。其中str和unicode是Python2中的编码，而bytes和str是Python3中的编码。</p><p>Python2中的编码：</p><ul><li>str：bytes序列的字符串</li><li>unicode：unicode码点序列 的字符串</li></ul><p>Python3中的编码：</p><ul><li>bytes: bytes序列的字符串。</li><li>str: unicode码点序列 的字符串。</li></ul><p>让人疑惑的是str，str在Python2和Python3中表示不同的编码，Python2中表示字节序列，即bytes; Python3中表示Unicode码。<strong>个人理解是Python3想让在程序中定义的字符串使用Unicode码表示，而不是Python2中用字节流表示。</strong></p><h4 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h4><pre><code class="lang-python">&gt;&gt;&gt; string = &quot;python&quot;&gt;&gt;&gt; type(string)&lt;type &#39;str&#39;&gt;&gt;&gt;&gt; u_str = u&quot;python&quot;&gt;&gt;&gt; type(u_str)&lt;type &#39;unicode&#39;&gt;</code></pre><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><pre><code class="lang-python">&gt;&gt;&gt; string = &quot;python&quot;&gt;&gt;&gt; bytes = b&quot;python&quot;&gt;&gt;&gt; type(string)&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; type(bytes)&lt;class &#39;bytes&#39;&gt;</code></pre><h3 id="encode与decode"><a href="#encode与decode" class="headerlink" title="encode与decode"></a>encode与decode</h3><blockquote><p>encode()和decode()是Python中用于bytes字节序列与Unicode序列转换的函数。</p></blockquote><ul><li>unicode.encode() -&gt; bytes:只有对于unicode对象我们才应该使用.encode()方法。这一方法用来将一系列unicode编码为bytes流。</li><li>bytes.decode() -&gt; unicode: 只有对于bytes，或说Python2中的str对象，我们才应该调用.decode()方法。这一方法将一系列bytes流解码为原本的unicode码点。</li></ul><h4 id="Python2-1"><a href="#Python2-1" class="headerlink" title="Python2"></a>Python2</h4><pre><code class="lang-python"># str 与 unicode&gt;&gt;&gt; string = &quot;python&quot;&gt;&gt;&gt; type(string)&lt;type &#39;str&#39;&gt;&gt;&gt;&gt; u_str = u&quot;python&quot;&gt;&gt;&gt; type(u_str)&lt;type &#39;unicode&#39;&gt;# str解码 -&gt; Unicode&gt;&gt;&gt; de_string = string.decode()&gt;&gt;&gt; type(de_string)&lt;type &#39;unicode&#39;&gt;# unicode 编码 -&gt; str&gt;&gt;&gt; en_u_str = u_str.encode()&gt;&gt;&gt; type(en_u_str)&lt;type &#39;str&#39;&gt;</code></pre><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><pre><code class="lang-python"># str 与 bytes&gt;&gt;&gt; string = &quot;python&quot;&gt;&gt;&gt; bytes = b&quot;python&quot;&gt;&gt;&gt; type(string)&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; type(bytes)&lt;class &#39;bytes&#39;&gt;# str编码 -&gt; butes&gt;&gt;&gt; en_string = string.encode()&gt;&gt;&gt; type(en_string)&lt;class &#39;bytes&#39;&gt;# bytes 解码 -&gt; str&gt;&gt;&gt; de_bytes = bytes.decode()&gt;&gt;&gt; type(de_bytes)&lt;class &#39;str&#39;&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Python的编码问题可能是很多人都遇到过的问题（没遇到的终将会遇到的），笔者之前也对这个问题很模糊，今天看了《Effective Python》之后总结一下自己的理解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://yx1302317313.github.io/categories/Python/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>球状闪电</title>
    <link href="https://yx1302317313.github.io/2019/10/07/%E7%90%83%E7%8A%B6%E9%97%AA%E7%94%B5/"/>
    <id>https://yx1302317313.github.io/2019/10/07/球状闪电/</id>
    <published>2019-10-07T07:56:04.000Z</published>
    <updated>2019-11-10T01:39:28.038Z</updated>
    
    <content type="html"><![CDATA[<!-- <center><img src="/img/blog/blog-22-1.jpg" width=800></center> --><blockquote><p>考试周的时候重新看了刘慈欣的《球状闪电》，个人一直很喜欢这本书，甚至超过了《三体》。但是一直没时间为这本书写一点东西，趁机抓住国庆假期的尾巴，写写我的体会。</p></blockquote><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次看《球状闪电》是一场意外。本来在看三体，第一部看完之后，应该是第二部《黑暗森林》。但是越看越不对，为什么和前面一点关系都没有，陈博士是干吗的？球状闪电是什么？</p><p>看了一半了才发现原来这个不是《黑暗森林》，而是《球状闪电》。<del>(论盗版小说的危害)</del>。但是看都看了，而且感觉写的不错，索性就看完了。可能当时还太年轻，没有很多感触，哈哈~~。不过对其中的一段话影响很深。</p><center>一片树林里分出两条路，<br>而我选了人迹更少的一条，<br>从此决定了我一生的道路。</center><p>这段话来自弗罗斯特的《未选择的路》， 考试周期间的一些事又让我想起了这段话，于是决定重新看一遍《球状闪电》。</p><h3 id="没有名字的男主"><a href="#没有名字的男主" class="headerlink" title="没有名字的男主"></a>没有名字的男主</h3><p>前一段时间一直在想男主的名字是什么，想了很长时间也没有想起来。<del>(疯狂怀疑自己的记忆力)</del>。之后查了才发现，原来刘慈欣根本就没有提及男主的名字，全书都是用“我”、“陈博士”叙述，卑微呀。</p><p>仔细想想男主确实挺惨的，少年时期父母因球状闪电双双去世；自己追寻球状闪电十几年，发现球状闪电原来是自然界最基本的物质，并不是自己所学能解决的；注定与自己喜欢的女孩无缘；没有林云的勇敢；没有丁仪对物理学的那份热爱与执着；甚至在林云的男友大尉面前都感到自惭形秽。</p><p>不过，他也是幸运的。和那些追寻球状闪电一生却连球状闪电都没有见过的人比起来，他简直是幸福的，他发现了球状闪电的秘密，甚至捕捉到了球状闪电。</p><blockquote><p>一个美妙的人生并不难，听爸爸教你：你选一个公认的世界难题，最好只用一张纸和一支铅笔的数学难题，比如哥德巴赫猜想或者费马大定理什么的，或连纸笔都不要的纯自然哲学难题，比如宇宙的本源之类，投入全部身心钻研，只问耕耘不问收获，不知不觉的专注中，一辈子也就过去了。</p></blockquote><p>上面的这段话是男主的父亲之前对他说的，男主的前半生可以说是做到了这一点，一直在追寻球状闪电的秘密。当然，这句话不仅在说男主，书中的很多人都在做着这样的事——用一生追寻一个问题或者一件事。像男主的老师那样终生寻找球状闪电之谜的人；对武器痴迷的林云少校；对物理学执着追求的丁仪教授…</p><h3 id="物理学家——六分仪"><a href="#物理学家——六分仪" class="headerlink" title="物理学家——六分仪"></a>物理学家——六分仪</h3><p>在发现球状闪电是自然界的基本物质之后，另外一位主角上场了——丁仪教授（很多人叫他六分仪，因为他出现在刘慈欣多部小说中，包括三体。每部小说中都是一个物理学家的身份，只不过研究领域不同）。</p><p>他的出现是因为主角这些搞应用科学的人根本没有办法解开自然界基本物质之谜，只能请“神仙”了。</p><blockquote><p>我们只能在牛顿、爱因斯坦、麦克斯韦这些人设定的框架中进行推演，不可能越雷池半步，否则就行步入没有空气的虚空一样，但在这个框架中，我们什么也推演不出来。</p></blockquote><p>这是另一句触动我的话，我相信只要是工科或者应用科学的人都多少会被这句话触动。对于工科或者应用科学的人来说，我们确实在那些伟大的科学家制定的框架中活着，很难越过雷池，甚至是不敢越过雷池。有些羡慕那些搞理论科学的人了，至少他们有机会“天马行空”。</p><p>丁仪的出现，很快解开了球状闪电之谜，<code>球状闪电是宏电子</code>。佩服刘慈欣的想象力，不过球状闪电的一些表现出来的现象还真的可以用量子力学解释。</p><p>根据我对量子力学的浅显认识，觉得他的解释还是有一定道理的。至于球状闪电究竟是什么，我也不知道呀，毕竟对于现在的物理学，球状闪电还是个迷。不过是宏电子的可能性微乎其微（如果是，刘慈欣可以再拿一个诺贝尔物理学奖啦）</p><p>看完小说之后，我都想在有生之年见一次球状闪电了。据说河北邯郸曾经出现过。</p><h3 id="危险与魅力并存的少校"><a href="#危险与魅力并存的少校" class="headerlink" title="危险与魅力并存的少校"></a>危险与魅力并存的少校</h3><h3 id="有梦想的人，永远年少"><a href="#有梦想的人，永远年少" class="headerlink" title="有梦想的人，永远年少"></a>有梦想的人，永远年少</h3><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>据说，刘慈欣写这本小说之前被查出疑似有癌症，于是他将《球状闪电》作为他的最后一本书来写，所以《球状闪电》的结局也比较凄美。不过，写完之后再查发现根本不是癌症。“重获新生”之后，刘慈欣开始构建三体世界。</p><h3 id="附：《未选择的路》"><a href="#附：《未选择的路》" class="headerlink" title="附：《未选择的路》"></a>附：《未选择的路》</h3><center>黄色的树林里分出两条路，<br>可惜我不能同时去涉足，<br>我在那路口久久伫立，<br>我向着一条路极目望去，<br>直到它消失在丛林深处。<br>但我却选了另外一条路，<br>它荒草萋萋，十分幽寂，<br>显得更诱人、更美丽，<br>虽然在这两条小路上，<br>都很少留下旅人的足迹，<br>虽然那天清晨落叶满地，<br>两条路都未经脚印污染。<br>呵，留下一条路等改日再见！<br>但我知道路径延绵无尽头，<br>恐怕我难以再回返。<br>也许多少年后在某个地方，<br>我将轻声叹息把往事回顾，<br>一片树林里分出两条路，<br>而我选了人迹更少的一条，<br>从此决定了我一生的道路。<br></center>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;center&gt;
&lt;img src=&quot;/img/blog/blog-22-1.jpg&quot; width=800&gt;
&lt;/center&gt; --&gt;
&lt;blockquote&gt;
&lt;p&gt;考试周的时候重新看了刘慈欣的《球状闪电》，个人一直很喜欢这本书，甚至超过了《三体》。但是一直没时间为这本书写一点东西，趁机抓住国庆假期的尾巴，写写我的体会。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="阅读" scheme="https://yx1302317313.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>仙境蓬莱</title>
    <link href="https://yx1302317313.github.io/2019/10/07/%E4%BB%99%E5%A2%83%E8%93%AC%E8%8E%B1/"/>
    <id>https://yx1302317313.github.io/2019/10/07/仙境蓬莱/</id>
    <published>2019-10-07T06:42:11.000Z</published>
    <updated>2019-10-19T08:20:36.339Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="远方" scheme="https://yx1302317313.github.io/categories/%E8%BF%9C%E6%96%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>自控力</title>
    <link href="https://yx1302317313.github.io/2019/10/07/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    <id>https://yx1302317313.github.io/2019/10/07/自控力/</id>
    <published>2019-10-07T06:41:43.000Z</published>
    <updated>2019-10-07T06:42:56.523Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="自控力" scheme="https://yx1302317313.github.io/categories/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>Shadowsocks网络代理</title>
    <link href="https://yx1302317313.github.io/2019/09/17/Shadowsocks%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"/>
    <id>https://yx1302317313.github.io/2019/09/17/Shadowsocks网络代理/</id>
    <published>2019-09-17T04:41:18.000Z</published>
    <updated>2019-11-09T14:45:40.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>昨天,在2019年网络安全周的第一天,搭建不到一个月的国外VPS被封了…特来记录一下最近的搭建过程.</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天荷兰和西雅图的VPS都被封了.期间还用traceroute(之后会介绍)分析了半天节点也没找到问题. 之后才知道是网络安全周. 据说, 网络安全周是特殊情况,之后可能会被解封.  <strong>Waiting…</strong></p><p> 再说使用国外VPS会不会被请去喝茶的问题. 只要是 <strong>正常访问</strong> Facebook,Google,YouTube之类的都没什么问题. 不过具体的我也不清楚,想知道请查阅国家法律或者咨询法律人士. 但是如果自己搭建网络代理然后出售VPN一类的东西好像是违法的,网上也有一些案例. 自己搭个服务器自己玩就行了,不要去碰这种生意. 还有也不要浏览什么政治敏感话题,更不要在这些方面发表不适合的言论.</p><h2 id="国外VPS购买"><a href="#国外VPS购买" class="headerlink" title="国外VPS购买"></a>国外VPS购买</h2><p>提供国外VPS的公司有很多, 比如Vultr, DigitalOcean, hostwinds等等.我用的是<a href="https://clients.hostwinds.com" target="_blank" rel="noopener">hostwinds</a>, 因为hostwinds相对比较便宜, 最低配版一个月$4.49元. 不过大部分价格差不多,每个月5美元左右. 有的也提供一些更便宜的服务器, 比如3美元左右, 但是现在基本已经售空了, 一般很难抢到. 如果你发现了一定要快点下手, 并且通过邮箱通知我一下. 哈哈…</p><p>对于服务器配置, 如果只是自己搭建Shadowsocks, 搭建个人博客, 做FTP, 做图床等等, 最低配就够用了. </p><p>下图是某网站发布的2019国外VPS服务商排行, 可以参考一下, 然后根据自己的需求选择即可.</p><center><img src="/img/blog/blog-20-1.png"></center><h2 id="Shadowsocks服务端搭建"><a href="#Shadowsocks服务端搭建" class="headerlink" title="Shadowsocks服务端搭建"></a>Shadowsocks服务端搭建</h2><p>买完服务器之后就可以开始Shadowsocks服务器的搭建了. </p><p>通过ssh远程登录服务器 <del>(既然都准备自己搭建服务器了, 这个应该都会吧)</del>. 可以先对服务器配置一下, 再开始.</p><ul><li>创建个普通用户, 尽量少用root用户.</li><li>换换终端, 强烈推荐zsh, 让终端操作更加丝滑.</li><li>…</li></ul><p>好了, 正式开始!</p><ol><li><p>服务器上安装Shadowsocks, 下面是一个一键安装脚本. 在终端运行下面的命令</p><pre><code class="lang-sh">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</code></pre></li><li><p>运行之后需要选择一些选项</p><ul><li>选择ss服务端的版本, 有Python, R, 和Go等等, 我选择的是Go.</li><li>输入密码: 输入自己想要设定的密码.</li><li>输入端口: 回车默认.</li><li>输入加密方式: 同样选默认, 回车.</li></ul></li><li><p>按任意健开始, 或者按Ctrl + C 取消. 当然是开始了.</p></li><li>等待安装完成. 然后将ip, 端口等信息截图保存一下.</li><li>完成, Enjoy it!</li></ol><p><strong>[注意]</strong>: 密码,端口和加密方式需要记住, 因为配置客户端时要用. 安装完成后会显示这些信息, 到时候截个图就可以. 同时会生成一个二维码, 可以使用手机扫描, 或者使用电脑读取二维码配置客户端. 至于怎么把二维码从服务器下载下来… 可以利用vsftpd搭一个FTP服务器, 然后下载. 不过这里使用手动配置.</p><p>完成之后可以看一下ss服务是否启动</p><pre><code class="lang-sh">$ systemctl list-units --type=service | grep Shadowsocks</code></pre><p>如果看到有Shadowsocks服务, 并且状态是active和running, 则服务已经启动. 服务端配置就完成了.</p><h2 id="Shadowsocks客户端"><a href="#Shadowsocks客户端" class="headerlink" title="Shadowsocks客户端"></a>Shadowsocks客户端</h2><p>在Github上有各个平台的Shadowsocks客户端. <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">Shadowsocks</a></p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>国内的应用商店肯定是没有shadowsocks应用的, 直接下github上的apk安装包安装即可.<del>(不过墙内好像下载速度极慢)</del>.</p><p>打开Android端Shadowsocks.</p><center><img src="/img/blog/blog-21-1.jpg" height="500"></center><p>点击右上角的添加图标, 选择手动设置.</p><center><img src="/img/blog/blog-21-2.jpg" height="500"></center><p>现在就用到之前保留的截图了, 按照服务器的配置信息依次设置服务器IP, 服务器端口, 密码, 以及加密方式.</p><p><strong>[注意]</strong>: 最下面的路由选择 <strong>绕过局域网及中国大陆地址</strong> , 这样访问局域网的网址和大陆网址时不使用代理. 你访问国内网站, 总不想绕大半个地球到欧洲或者北美再回来吧.</p><p>还有, 国内某些网站是不对国外的IP提供服务的, 比如网易云音乐, 如果使用国外的IP访问, 不能播放音乐, 更不能下载了.</p><center><img src="/img/blog/blog-21-3.jpg" height="500"></center><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows安装之后, 打开应用之后会直接显示在底栏的右下角. 右键进行手动配置, 基本同Android端配置一样.</p><p>同样, 为了访问局域网的网址和大陆网址时不使用代理, 也需要进行相应的配置, 在右键菜单中找到系统代理这一项, 将默认的全局模式改为PAC模式.</p><p>由于电脑上没有Windows系统, 就不截图了. Windows具体配置见<a href="https://github.com/Shadowsocks-Wiki/shadowsocks/blob/master/2-windows-setup-guide-cn.md" target="_blank" rel="noopener">Windows Shadowsocks配置</a>.</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><blockquote><p>Linux当然是最”麻烦”的了.</p></blockquote><p>我的Linux发行版是Ubuntu18，不同发行版之间操作可能不同。</p><h4 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h4><ol><li><p>打开设置-&gt;网络-&gt;网络代理</p></li><li><p>选择网络代理中的手动代理，再选择sockts主机为本地IP地址：172.0.0.1，端口为1080。具体设置见下图</p></li></ol><center><img src="/img/blog/blog-21-7.png"></center><h5 id="终端的全局代理"><a href="#终端的全局代理" class="headerlink" title="终端的全局代理"></a>终端的全局代理</h5><p>在shell的配置文件(.bashrc、.zshrc等等)中添加下面内容</p><pre><code class="lang-sh">export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot;</code></pre><p><strong>目前还没有找到终端使用PAC代理的方法，我在终端使用的还是全局代理。。。</strong></p><h4 id="PAC代理"><a href="#PAC代理" class="headerlink" title="PAC代理"></a>PAC代理</h4><blockquote><p>PAC，一个自动代理配置脚本，包含了很多使用 JavaScript 编写的规则，它能够决定网络流量走默认通道还是代理服务器通道，控制的流量类型包括：HTTP、HTTPS 和 FTP。</p></blockquote><h5 id="系统的PAC代理"><a href="#系统的PAC代理" class="headerlink" title="系统的PAC代理"></a>系统的PAC代理</h5><ul><li>安装pip（很多人可能已经装了）</li></ul><pre><code class="lang-sh">sudo apt-get install python-pip python-dev build-essential sudo pip install --upgrade pip sudo pip install --upgrade virtualenv</code></pre><ul><li>安装genpac</li></ul><pre><code class="lang-sh">sudo pip install genpac</code></pre><ul><li>建立一个存放pac文件的目录，进入该目录。（注意，在执行时需挂系统代理 sock5，否则会出现获取 gfwlist 失败的情况）</li></ul><pre><code class="lang-sh">genpac --proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; -o autoproxy.pac --gfwlist-url=&quot;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</code></pre><ul><li>选择网络代理中的自动代理，url 填写刚生成的 pac 文件的路径file:///path/autoproxy.pac (# 这个文件是一个JS脚本文件，里面存放着目前大部分被gfw屏蔽的域名)，<strong>如果有需要添加的域名，可以自己手动添加进去。</strong></li></ul><h5 id="Chrome的PAC代理"><a href="#Chrome的PAC代理" class="headerlink" title="Chrome的PAC代理"></a>Chrome的PAC代理</h5><ol><li>安装chrome插件SwitchyOmega</li><li>打开SwitchyOmega配置</li><li>新建情景模式，选择PAC情景模式</li><li>在PAC脚本内复制下载的PAC文件的内容，也可以通过填写PAC网址从网站下载PAC文件。</li><li>选择SwitchyOmega的模式是刚刚新建的情景模式。</li></ol><h5 id="Firefox的PAC代理"><a href="#Firefox的PAC代理" class="headerlink" title="Firefox的PAC代理"></a>Firefox的PAC代理</h5><ol><li>打开：设置 -&gt;首选项 -&gt;常规 -&gt;最下方的网络设置。</li><li>点击设置-&gt; 选择自动代理配置URL（PAC）</li><li>填写下载的PAC文件的路径，例如： file:///path/autoproxy.pac</li><li>确认</li></ol><h2 id="traceroute分析"><a href="#traceroute分析" class="headerlink" title="traceroute分析"></a>traceroute分析</h2><blockquote><p>说说traceroute, 这是一个Linux命令(在Windows下相应命令为tracert). 它的作用就是跟踪消息在网络核心之间的传输, 也就是在各个路由器之间的传输. 通过这个命令我们可以看到网络传输中的时延和丢包现象.</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>traceroute主要使用了IP头部生存时间(time to live, TTL), TTL值在每经过一个路由之后会减去1, 当TTL值为0时, 路由器认为发送超时, 将报文丢弃并向源主机发送ICMP超时差错报文. 报文中包含了路由器的IP.</p><p>利用TTL的这种工作原理, traceroute可以依次得到每一个路由器的IP地址.</p><ul><li>源主机将TTL值设置为1发送报文, 在报文到达第一个路由器时, $TTL - 1 = 0$, 于是路由器认为超时, 发送一份ICMP超时差错报文给源主机, 得到第一个路由器的IP.</li><li>源主机再将TTL值设置为2发送报文, 同理得到第二个路由器的IP地址.</li><li>…</li><li>当报文到达目的主机时, 由于traceroute通过UDP数据包向不常见端口发送数据包，因此会收到目的主机ICMP port unreachable消息，故可判断到达目的地。</li><li>停止发送报文.</li></ul><p>通过上述方法可以得到从源主机到目的主机过程中各个路由器的IP地址, 由于源主机收到路由器或者目的主机的消息所用的时间是从源主机到路由器或者目的主机的2倍, 可以简单的将这个时间除以2得到从源主机到路由器或者目的主机的时间. 通过这个时间我们可以分析传输时延和丢包现象.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是traceroute访问百度的过程, 其中*表示丢包.</p><center><img src="/img/blog/blog-21-4.png" width="800"></center><p>访问cnn, 其中202.97.50.54是电信主干网, 之后的一个IP 38.104.138.105就已经到了美国了.</p><center><img src="/img/blog/blog-21-5.png" width="800"></center><p>再看youtube, 在电信主干网就挂掉了, 连走出国门的机会都没有(-_-).</p><center><img src="/img/blog/blog-21-6.png" width="800"></center>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;昨天,在2019年网络安全周的第一天,搭建不到一个月的国外VPS被封了…特来记录一下最近的搭建过程.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://yx1302317313.github.io/categories/Linux/"/>
    
    
      <category term="网络代理" scheme="https://yx1302317313.github.io/tags/%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"/>
    
      <category term="shadowsocks" scheme="https://yx1302317313.github.io/tags/shadowsocks/"/>
    
      <category term="Network" scheme="https://yx1302317313.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>天津之行</title>
    <link href="https://yx1302317313.github.io/2019/08/31/%E5%A4%A9%E6%B4%A5%E4%B9%8B%E8%A1%8C/"/>
    <id>https://yx1302317313.github.io/2019/08/31/天津之行/</id>
    <published>2019-08-31T02:54:25.000Z</published>
    <updated>2019-09-07T04:13:47.625Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实很多人都希望一场旅行,去追寻自己心中的诗与远方.可能由于时间问题,经济问题等,只能一次次的打消念头.如果你真的下定决心去尝试一次,你会发现之前的那些问题并不会阻碍你.很幸运,我迈出了这一步.</p></blockquote><center><img src="/img/blog/blog-19-1.jpg" width="500"></center><a id="more"></a><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><h4 id="为什么想要一次旅行"><a href="#为什么想要一次旅行" class="headerlink" title="为什么想要一次旅行"></a>为什么想要一次旅行</h4><blockquote><p>当然,很久之前就想要来一次旅行,只不过由于开篇提到的问题很多次打消了念头.</p><p>让我下定决心的是想要放空自己.最近几场比赛都已结束了,感觉自己的大学也快要结束了 <del>(其实真的快结束啦)</del>, 而自己对于之后的”何去何从”还没有想清楚,说到底是没有想清楚自己想要的究竟是什么,是浪潮之巅,是诗与远方,亦或是其他的什么. </p><p>而当时又不愿去想,于是决定来一次旅行,放空自己,然后想一想这个哲学问题 — <strong>我要到哪里去?</strong></p></blockquote><div align="center"><audio controls>    <source src="/music/贝加尔湖畔.mp3"></audio><p>贝加尔湖畔-李健</p></div><h4 id="为什么是天津"><a href="#为什么是天津" class="headerlink" title="为什么是天津"></a>为什么是天津</h4><blockquote><p>这个问题好像很好回答,因为贫穷,哈哈!</p><p>某一天,忽然发现了一个问题. 从家到学校(或者学校到家),如果换不同的换乘方案,我可以经过很多城市,北京,天津,济南,青岛… 途中在这些城市玩几天可以节省旅行的路费 <del>(真的是因为贫穷)</del>.</p><p>北京消费有点高 <del>(再一次的贫穷)</del>,而且个人感觉北京的人太多了,所以就放弃了北京.至于天津,自己一直对这个城市有一种希冀,可能之前想过以后在天津定居吧.不过这次旅行真的让我喜欢上了这个城市.</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><blockquote><p>原本准备从学校回家的途中在天津停留几天,并且制定了一份比较详细的计划.但是由于某些原因,改到了从家到学校的途中.</p><p>第一次自己如此详细的准备一份出行计划,以前如果有其他人一起,自己就懒得计划了.其实最主要的问题就是规划各个景点的游览顺序和交通方式,想要在一定的时间内游览更多的地方. (不知不觉抽象成了一道优化问题 ^-^). 早知道在数据结构实验的时候就做景点之间的路径规划了.</p></blockquote><h4 id="我的计划"><a href="#我的计划" class="headerlink" title="我的计划"></a>我的计划</h4><div class="table-container"><table><thead><tr><th>日期</th><th>起点</th><th>终点</th><th>方式</th><th>时长</th></tr></thead><tbody><tr><td>8.29</td><td>天津西</td><td>古文化街</td><td>公交</td><td>0：7</td></tr><tr><td>8.29</td><td>古文化街</td><td>意风区</td><td>步行， 骑行</td><td>0：21， 0：10</td></tr><tr><td>8.29</td><td>意风区</td><td>天津之眼</td><td>公交， 骑行</td><td>0：34， 0：14</td></tr><tr><td>8.30</td><td>天津之眼</td><td>天大</td><td>公交</td><td>0：38</td></tr><tr><td>8.30</td><td>天大， 南开</td><td>河北工业大学</td><td></td><td></td></tr><tr><td>8.30</td><td>天大</td><td>滨海图书馆</td><td>公交</td><td>1：45</td></tr></tbody></table></div><p><br></p><blockquote><p>最终并没有完全按照计划进行,毕竟计划是赶不上变化的.但计划中的地方都去了,所以计划也没有白做.</p></blockquote><!--more### 青年旅社>  第一次尝试青年旅社，之前也想过住青年旅社，不过总觉得这样的地方不正规，不安全。经过这次的体验，改变了我的看法。--><h3 id="天津之眼"><a href="#天津之眼" class="headerlink" title="天津之眼"></a>天津之眼</h3><blockquote><p>第一天到天津已经是傍晚了,所以直接去了天津之眼（晚上是去天津之眼的绝佳时间）。</p><p>建在桥上的摩天轮还是很壮观的，也难怪会成为天津的名片，我个人比较喜欢建筑，每次见到这些建筑都有一种敬畏之感。（高考报志愿也曾考虑过建筑学，至于为什么没报…）</p><p>本来想上摩天轮上的，直径110米的摩天轮在最高点，确实能将两岸的景色尽收眼底。不过时间问题，过去已经停止售票了，有一点遗憾，但是之后听到曾经发生过一次没关舱门的事件(&gt;_&lt;)，这一点遗憾就荡然无存了。</p><p> 如果只有一个摩天轮，这个地方也没有那么大的吸引力。我感觉相比天津之眼，它所在的海河两岸的风景才是天津一张特殊的名片，天津之眼只是海河的锦上添花。</p><p> 到了天津之后才知道天津居然从海河这条“母亲河”发源的，乘船在海河游览一遍才能真正感觉到天津之美。</p><p>现在很多城市随着城市的现代化都已经失去了自己的特点。车水马龙中，见到的只是灯红酒绿，高楼大厦。漫步于城市中，某一瞬间可能真的不知自己身在何处。</p><p>不过天津让我看到了她的独特之处，乘船穿过一座座桥梁，每一座桥都有自己独特的风韵，有着自己的“故事”。而两岸是各种近代和现代建筑，你可以见到袁世凯的总统府，周总理与邓颖超的纪念馆，纪念弘一法师（李叔同）的大悲禅院……</p><p>天津有很多名人故居，少帅张学良的府邸，张伯苓先生的故居等等，所以天津确实是一个适合定居的地方。</p><p> 同样，你也可以经过天津的很多租界，意租界，英租界，法租界，奥租界等等，天津是中国保留租界最多的城市，其中的意租界最有名，是意大利在国外保留最大的租界。</p><p>所以天津是一个古今，中外文化融合的城市，有着自己风格。</p><p>感受天津独特之美的最好方式一定是沿着海河游览，或步行，或骑车，亦或乘船。</p></blockquote><center><img src="/img/blog/blog-19-2.jpg" width="500"></center><p><br></p><center><img src="/img/blog/blog-19-3.jpg" width="500"></center><p><br></p><center><img src="/img/blog/blog-19-4.jpg" width="500"></center><p><br></p><center><img src="/img/blog/blog-19-5.jpg" width="500"></center><p><br></p><h3 id="古文化街"><a href="#古文化街" class="headerlink" title="古文化街"></a>古文化街</h3><blockquote><p>按照计划，来到了古文化街。古文化街这个名字对于我来说就够有吸引力了，从小印象中的天津就是一个极具中国传统文化的地方，有着很多奇人异事，泥人张，刷子李等等。</p></blockquote><center><img src="/img/blog/blog-19-6.jpg" width="500"><p>传说中的泥人张</p></center><p><br></p><center><img src="/img/blog/blog-19-7.jpg" width="500"><p>达摩祖师</p></center><p>当然还有天津有名的狗不理，据说太贵，卑微的我只能在门外逗留一会儿。</p><center><img src="/img/blog/blog-19-8.jpg" width="500"></center><blockquote><p>之后就遇到了相声大会正好开始，本来没打算进去，但是转念一想，来天津总要体验一下天津相声。不过听相声最好多带个人一起去，或者一个人不要点茶，否则你喝不完那壶茶 <del>(一个半小时一直喝，也就喝了不到半壶)</del></p></blockquote><center><img src="/img/blog/blog-19-9.jpg" width="500"></center><p><br></p><center><img src="/img/blog/blog-19-10.jpg" width="500"><p>那壶万恶的茶...</p></center><h3 id="意风区"><a href="#意风区" class="headerlink" title="意风区"></a>意风区</h3><blockquote><p>下午和某个人来到了意风区，不是自己想象中的那样，这里主要是当时的意大利租界，保留了租界的建筑，然后最多的就是酒吧和咖啡馆了。</p></blockquote><center><img src="/img/blog/blog-19-11.jpg" width="500"><p>马可波罗像</p></center><p><br></p><center><img src="/img/blog/blog-19-21.jpg" width="500"><p>酒吧中唱歌的小姐姐</p></center><blockquote><p>之后喝了人生中的第一杯鸡尾酒，感觉还算不错，除了贵…不过积累了一个经验——鸡尾酒不要点看起来比较绿的，哈哈！</p></blockquote><center><img src="/img/blog/blog-19-12.jpg" width="500"></center><h3 id="南天门"><a href="#南天门" class="headerlink" title="南天门"></a>南天门</h3><blockquote><p>依然是按计划，第二天上午去了天大和南开，见到了传说中的“南天门”，真的天大和南开之间只是一门之隔，出了天大还没感觉就进了南开。</p></blockquote><h4 id="天大"><a href="#天大" class="headerlink" title="天大"></a>天大</h4><p>羡慕一下天大的食堂</p><center><img src="/img/blog/blog-19-13.jpg" width="500"></center><p>天大应该是中国最早的大学了。</p><center><img src="/img/blog/blog-19-14.jpg" width="500"></center><h4 id="南开"><a href="#南开" class="headerlink" title="南开"></a>南开</h4><blockquote><p>对于南开的印象应该主要是两个人，张伯苓先生——中国近代一位伟大的教育家，也是南开的创始人（好像还是西南联大的校长）；还有一位是被张伯苓先生称为南开最优秀的学生——周恩来总理。</p></blockquote><center><img src="/img/blog/blog-19-15.jpg" width="500"><p>南开主楼（感觉还是哈工大主楼好看）</p></center><p>今年是南开的百年校庆，下图是校庆的吉祥物，有点可爱(^_^)。</p><center><img src="/img/blog/blog-19-16.jpg" width="500"><p>南开百年校庆吉祥物</p></center><h3 id="传说中的网红图书馆"><a href="#传说中的网红图书馆" class="headerlink" title="传说中的网红图书馆"></a>传说中的网红图书馆</h3><blockquote><p> 在南开的时候已经有点玩不动了，于是决定休息一下，坐地铁去滨海新区。。。</p><p>之前是打算去滨海传说中的网红图书馆的，但是由于离市区太远了，一直犹豫去还是不去，不过现在有理由了。</p><p>出门一直用百度地图，不过百度地图你能不能好好搞一下立体空间导航，找了半天滨海图书馆在哪，结果是它在我上面。。。</p><p>想去滨海图书馆，主要是因为它的建筑风格很独特，真的很像梯田（怀疑这位欧洲的设计师去过云南）。</p></blockquote><center><img src="/img/blog/blog-19-17.jpg" width="500"></center><p><br></p><center><img src="/img/blog/blog-19-18.jpg" width="500"></center><blockquote><p> 确实像网上说的那样，高处的书是假的，只是画在了书架上。可能是因为书不够，这个好处理。不过我想知道天花板上的书要怎么取？</p></blockquote><center><img src="/img/blog/blog-19-19.jpg" width="500"></center><blockquote><p>成功通过图书馆的管理系统找到了最近正在看的书——《白说》，在图书馆里面看了一章，体验很好。</p></blockquote><center><img src="/img/blog/blog-19-20.jpg" width="500"></center><h3 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实很多人都希望一场旅行,去追寻自己心中的诗与远方.可能由于时间问题,经济问题等,只能一次次的打消念头.如果你真的下定决心去尝试一次,你会发现之前的那些问题并不会阻碍你.很幸运,我迈出了这一步.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;
&lt;img src=&quot;/img/blog/blog-19-1.jpg&quot; width=&quot;500&quot;&gt;
&lt;/center&gt;
    
    </summary>
    
      <category term="远方" scheme="https://yx1302317313.github.io/categories/%E8%BF%9C%E6%96%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>何去何从</title>
    <link href="https://yx1302317313.github.io/2019/07/29/%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E/"/>
    <id>https://yx1302317313.github.io/2019/07/29/何去何从/</id>
    <published>2019-07-29T15:48:42.000Z</published>
    <updated>2019-07-29T16:04:32.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>迷宫生成算法</title>
    <link href="https://yx1302317313.github.io/2019/06/24/%E8%BF%B7%E5%AE%AB%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
    <id>https://yx1302317313.github.io/2019/06/24/迷宫生成算法/</id>
    <published>2019-06-24T11:28:38.000Z</published>
    <updated>2019-06-24T15:09:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近做课设时,有一个部分需要用到迷宫的生成算法. 在这里介绍一种使用深度优先搜索生成迷宫的算法.</p></blockquote><a id="more"></a><center><audio controls>    <source src="/music/年少有为-李荣浩.mp3"></audio><p>年少有为-李荣浩</p></center><h3 id="最终的效果"><a href="#最终的效果" class="headerlink" title="最终的效果"></a>最终的效果</h3><p>先上几张效果图，图中绿色的表示障碍，灰色表示道路(<del>我的世界既视感</del>).</p><p><br></p><center><img src="/img/blog/blog-18-1.png" width="500"></center><p><br></p><center><img src="/img/blog/blog-18-2.png" width="500"></center><p><br></p><center><img src="/img/blog/blog-18-3.png" width="500"></center><h3 id="如何描述迷宫"><a href="#如何描述迷宫" class="headerlink" title="如何描述迷宫"></a>如何描述迷宫</h3><p>迷宫其实就是一个复杂的地形图,在这个地形中有基本的障碍和通道,当然也可以有其他元素。</p><p>我们这里用最简单的方式描述迷宫——矩阵。迷宫中的地形也只有障碍和通道两种元素。可以用0和1表示这两种元素。</p><p>因此我们用一个存储着0和1,M*N大小的矩阵就可以描述迷宫啦!</p><h3 id="迷宫的特点"><a href="#迷宫的特点" class="headerlink" title="迷宫的特点"></a>迷宫的特点</h3><ol><li>从设定的起点到终点必须是连通的(<del>否则,还能不能好好玩耍了</del>)</li><li>从起点到终点只有一条通路.(其实也可以有多条,根据实际需要设定)</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从迷宫特点的描述有没有想到什么?</p><p>迷宫就是一个图,要求任意设定的起点和终点之间是连通的,就是一个 <strong>全连通图</strong>.但是如果这个图的连通度太高,迷宫就没有难度了,所以我们要求图中任意顶点之间只有一条路.</p><p>什么样的图只有一条路, <strong>无环图</strong>.</p><p>所以我们需要的是无环的连通图,这是什么? <strong>树</strong></p><p>我们的迷宫就是一个树,因此迷宫的生成算法就是树的生成算法,树的生成算法有深度优先遍历和广度优先遍历, 在这里使用深度优先.</p><h3 id="迷宫的生成过程"><a href="#迷宫的生成过程" class="headerlink" title="迷宫的生成过程"></a>迷宫的生成过程</h3><h4 id="1-初始状态"><a href="#1-初始状态" class="headerlink" title="1 初始状态"></a>1 初始状态</h4><blockquote><p>图中绿色的表示障碍，灰色表示道路(空白)</p></blockquote><center><img src="/img/blog/blog-18-4.png" width="500"></center><p>由于迷宫四周都是障碍, 图的宽和高都必须是奇数.</p><h4 id="2-迷宫的生成"><a href="#2-迷宫的生成" class="headerlink" title="2 迷宫的生成"></a>2 迷宫的生成</h4><p>1 任意选择一个空白块, 将该空白块作为树的根结点.</p><p>2 从根节点出发隔一个元素块查找四周(上,下,左,右,四个方向,不包括对角线方向)其他的空白块.</p><center><img src="/img/blog/blog-18-5.png" width="500"><p>从该结点出发,四周只有两个空白块</p></center><center><img src="/img/blog/blog-18-6.png" width="500"><p>从该结点出发,四周有四个空白块</p></center><p>3 随机选取其中一个空白块, 将道路沿该方向拓展, 即把夹在这两个空白块之间的障碍块去掉, 改成空白块.</p><center><img src="/img/blog/blog-18-7.png" width="500"><p>把夹在这两个空白块之间的障碍块去掉</p></center><p>4 更新当前结点, 然后从当前结点出发,重复步骤2,3.</p><p>5 当遇到一个结点周围没有空白块时, 即没有可拓展道路的方向时, 回退并更新当前结点, 直至当前结点四周有空白块, 重复步骤2,3.</p><center><img src="/img/blog/blog-18-8.png" width="500"><p>该结点周围没有空白块</p></center><p>6 当回退到根节点没有任何可以拓展的道路时, 算法结束, 迷宫也就生成了.</p><center><img src="/img/blog/blog-18-1.png" width="500"></center><h4 id="3-设定起点和终点"><a href="#3-设定起点和终点" class="headerlink" title="3 设定起点和终点"></a>3 设定起点和终点</h4><p>选取迷宫中的两个空白块作为迷宫的起点和终点,一个完整的迷宫就诞生了.</p><h3 id="核心算法—深度优先"><a href="#核心算法—深度优先" class="headerlink" title="核心算法—深度优先"></a>核心算法—深度优先</h3><blockquote><p>由于这部分算法是程序的一部分,不能完整运行,仅供参考.</p><p>在程序中用到了Qt中的容器QVector,可以用STL中的std::vector代替; 用到的qsrand()和qrand()生成随机数,可以使用C标准库中的srand()和rand()函数代替.</p></blockquote><pre><code class="lang-cpp">/*@ 生成迷宫*/void GenerateMaze::Maze(int width, int height){    //初始化矩阵, 申请内存    maze_matrix_ = new int*[height];    for(int i=0; i&lt;height; i++)    {        maze_matrix_[i] = new int[width];    }    for(int i=0; i&lt;height; i++)    {        for(int j=0; j&lt;width;j++)        {            if(i % 2 == 0 || j % 2==0)            {                maze_matrix_[i][j] = 1;  //障碍            }            else            {                maze_matrix_[i][j] = 0;  //道路(空白)            }        }    }    qsrand(QTime(0,0,0).secsTo(QTime::currentTime())); //设置随机数种子    maze_matrix_[1][1] = 2; //选取(1,1)作为根节点, 并将根节点的状态设置成2    this-&gt;generateMaze(1, 1);   //深度优先遍历    for(int i=0; i&lt;height; i++)    {        for(int j=0; j&lt;width;j++)        {            if(maze_matrix_[i][j] == 2)            {                maze_matrix_[i][j] = 0; //将状态为2的结点重新设置为0, 表示可通行道路            }        }    }}/*@ brief:深度优先生成迷宫(递归实现)*/void Maze::generateMaze(int pos_i, int pos_j){    //到达边界, 返回    if(pos_j &lt; 0 || pos_j &gt;= width || pos_i &lt; 0 || pos_i &gt;= height)    {        return;    }    QVector&lt;int&gt; vec = existedRoad((const int**)maze_matrix_, pos_i, pos_j); //查找当前结点四周空白块    //四周没有空白块, 返回    if(vec.size() == 0)    {        return;    }    for(int i=0; i &lt; vec.size();)    {        int index = qrand()%vec.size(); //随机选择其中一个空白块        switch(vec[index])        {        case D_LEFT:    //左            if(maze_matrix_[pos_i][pos_j-2] != 2)            {                maze_matrix_[pos_i][pos_j-1] = 2;    //将走过的路径设为2, 防止重复经过                maze_matrix_[pos_i][pos_j-2] = 2;                this-&gt;generateMaze(pos_i, pos_j-2); //更新结点, 递归            }            break;        case D_RIGHT:   //右            if(maze_matrix_[pos_i][pos_j+2] != 2)            {                maze_matrix_[pos_i][pos_j+1] = 2;                maze_matrix_[pos_i][pos_j+2] = 2;                this-&gt;generateMaze(pos_i, pos_j+2); //更新结点, 递归            }            break;          case D_UP:  //上            if(maze_matrix_[pos_i-2][pos_j] != 2)            {                maze_matrix_[pos_i-1][pos_j] = 2;                maze_matrix_[pos_i-2][pos_j] = 2;                this-&gt;generateMaze(pos_i-2, pos_j); //更新结点, 递归            }            break;        case D_DOWN:    //下            if(maze_matrix_[pos_i+2][pos_j] != 2)            {                maze_matrix_[pos_i+1][pos_j] = 2;                maze_matrix_[pos_i+2][pos_j] = 2;                this-&gt;generateMaze(pos_i+2, pos_j); //更新结点, 递归            }            break;        }        vec.remove(index);  //清空vec    }}/*@brief: 查找结点周围的空白块*/const QVector&lt;int&gt; Maze::existedRoad(const int **mat, int i, int j){    QVector&lt;int&gt; vec;    if(j-2 &gt;= 0 &amp;&amp; mat[i][j-2] == 0)    {        vec.push_back(D_LEFT);  //左边有空白块    }    if(j+2 &lt; width &amp;&amp; mat[i][j+2] == 0)    {        vec.push_back(D_RIGHT); //右边有空白块    }    if(i-2 &gt;= 0 &amp;&amp; mat[i-2][j] == 0)    {        vec.push_back(D_UP);    //上边有空白块    }    if(i+2 &lt; height &amp;&amp; mat[i+2][j] == 0)    {        vec.push_back(D_DOWN);  //下边有空白块    }    return vec;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近做课设时,有一个部分需要用到迷宫的生成算法. 在这里介绍一种使用深度优先搜索生成迷宫的算法.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="游戏" scheme="https://yx1302317313.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Qt" scheme="https://yx1302317313.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>回溯法的多米诺性质</title>
    <link href="https://yx1302317313.github.io/2019/05/05/%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%80%A7%E8%B4%A8/"/>
    <id>https://yx1302317313.github.io/2019/05/05/回溯法中的多米诺性质/</id>
    <published>2019-05-05T03:32:37.000Z</published>
    <updated>2019-06-22T03:26:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在复习算法, <del>没办法,要考试啦</del>. 在复习回溯法的时候终于理解了之前不是很清楚的多米诺性质.</p></blockquote><a id="more"></a><div align="center"><audio controls>    <source src="/music/情深深雨蒙蒙-张杰.mp3"></audio><p>情深深雨蒙蒙-张杰</p></div><h3 id="1-回溯法"><a href="#1-回溯法" class="headerlink" title="1 回溯法"></a>1 回溯法</h3><p>由于这篇博客主要讲解多米诺性质, 默认大家已经了解回溯法啦,这里对回溯法的具体内容就不进行讲解了,<del>其实是太懒不想写</del>.</p><p>回溯法是一个很实用的算法,适合求解搜索问题和优化问题.你也可以将它看做是蛮力法(枚举法)的改进.</p><p>但不是什么情况下都可以使用回溯法, 那么就要问了,回溯法的适用条件是什么? 这就是今天的主角: <strong>多米诺性质</strong></p><h3 id="2-多米诺性质"><a href="#2-多米诺性质" class="headerlink" title="2 多米诺性质"></a>2 多米诺性质</h3><p>先不看多米诺性质是什么,在了解了回溯法的基本思想后,我们可以总结一下什么情况下可以使用回溯法.</p><h4 id="2-1-回溯法的基本思想"><a href="#2-1-回溯法的基本思想" class="headerlink" title="2.1 回溯法的基本思想"></a>2.1 回溯法的基本思想</h4><blockquote><p>将待求解问题看做一个解空间树, 问题的解可以表示为$X= (x_1, x_2, …, x_n )$.<br>然后利用深度优先搜索逐步确定每一个解$x_i$, 当搜索到树的叶子结点时, 就得到问题的一个解$X_i$.<br>当然这个解不一定是最优解,在将整个解空间树搜索完之后,通比较得到的每个$X_i$,便可以得到最优解.</p></blockquote><p>其实上面的思想是枚举搜索的思想,并不是回溯法.但是加上下面这一部分就成了回溯法了. <strong>下面这一部分是回溯法的核心</strong></p><blockquote><p> 在搜索的过程中, 问题的解$X$需要满足约束条件$P(X)$.<br>在搜索到一个结点的时候发现当前结点不满足约束条件,则放弃向下搜索,即不再搜索该结点的子结点, 而是回溯到上一个结点继续搜索.</p></blockquote><p>由于在搜索过程中,放弃了一些没有必要搜索的结点,整个算法的效率就提高了.</p><p><strong>为什么能够放弃? that is the question.</strong></p><p>如果当前结点不满足约束条件,能够推导出它的子结点也不满足约束条件,那么就可以放弃搜索它的子结点.其实这就是多米诺性质.</p><h4 id="2-2-多米诺性质的定义"><a href="#2-2-多米诺性质的定义" class="headerlink" title="2.2 多米诺性质的定义"></a>2.2 多米诺性质的定义</h4><blockquote><p>设$X = (x<em>1, x_2, …, x_n )$是问题的解,<br>$X_i= (x_1, x_2, …, x_i), X</em>{i+1} = (x<em>1, x_2, …, x_i, x</em>{i+1}), X<em>i, X</em>{i+1} \subseteq X$.<br>$X<em>{i}和X</em>{i+1}$ 分别是搜索到第i层和第i+1层的解.<br>如果 $P(X<em>{i+1}) \rightarrow P(X_i)$ , 即 $P(X</em>{i+1})$ 蕴含 $P(X_i)$, 则称该问题满足多米诺性质.</p></blockquote><p>是不是很难理解?<del>数学是个好东西,表达简洁优雅,没有二义性,但是太难理解.</del></p><p>其实上面定义的意思是: 如果子结点满足约束条件能够推导出其父结点满足约束条件,那么就满足多米诺性质.</p><p>为什么感觉和之前说的不太一样? 对比一下</p><ul><li>如果当前结点不满足约束条件,能够推导出它的子结点也不满足约束条件.</li><li>如果子结点满足约束条件能够推导出其父结点满足约束条件.</li></ul><p>你会发现其实这两个命题互为逆否命题,也就是这两个命题说的是同一件事.下面给出证明.(涉及一点数理逻辑的知识,但是逻辑很简单)</p><p><strong>[证明]</strong>:</p><script type="math/tex; mode=display">\begin{aligned}& 如果问题满足多米诺性质, 则有P(X_{i+1}) \rightarrow P(X_i)\\& 有逆否命题 \neg P(X_{i}) \rightarrow \neg P(X_{i+1}) 成立\\& 在当前结点不满足约束条件时, 即\neg P(X_{i}).\\& 可得到\neg P(X_{i+1})成立\\& 即当前结点不满足约束条件时, 它的子结点也不满足约束条件.\end{aligned}</script><p><strong>因此只要求解的问题满足多米诺性质,我们在使用回溯法时, 当发现当前结点不满足约束条件,就可以放弃对其子节点的搜索.</strong></p><p><strong>[理解]</strong>:</p><blockquote><p>考察多米诺性质的目的是为了确认, 在对解空间搜索的过程中, 在当前结点不满足约束条件时, 能不能放弃对当前结点的子结点的搜索.如果问题满足多米诺性质,则可以;否则, 不可以, 在这种情况下回溯法可能会丢解.</p></blockquote><h3 id="3-Example"><a href="#3-Example" class="headerlink" title="3 Example"></a>3 Example</h3><h4 id="3-1-背包问题"><a href="#3-1-背包问题" class="headerlink" title="3.1 背包问题"></a>3.1 背包问题</h4><blockquote><p>背包问题的描述在这里不进行赘诉.</p></blockquote><p>背包问题的约束条件</p><ol><li>$n$: 物品的数量</li><li>$x_i$: 表示是否选择该物品</li><li>$w_i$: 物品的重量 </li><li>$C$:背包容量</li></ol><script type="math/tex; mode=display">\left\{\begin{aligned}    &\Sigma_{i=1}^{n} x_i*w_i \le C, 0 < i \le n\\    &x_i \in \{0,1\}, 0 < i \le n\\    &w_i > 0,0 < i \le n\\\end{aligned}\right.</script><h5 id="背包问题的多米诺性质"><a href="#背包问题的多米诺性质" class="headerlink" title="背包问题的多米诺性质"></a>背包问题的多米诺性质</h5><p><strong>[证明]</strong>:</p><script type="math/tex; mode=display">\begin{aligned}& 设X_{i}= \Sigma_{k=1}^{i} x_k*w_k, X_{i+1}= \Sigma_{k=1}^{i+1} x_k*w_k\\ & \because X_{i+1} \le C, w_k > 0, x_k \in \{0,1\}\\& \therefore X_{i} < X_{i+1} \le C\end{aligned}</script><p>因此背包问题满足多米诺条件,可以使用回溯法解决.</p><h4 id="3-2-不等式的整数解"><a href="#3-2-不等式的整数解" class="headerlink" title="3.2 不等式的整数解"></a>3.2 不等式的整数解</h4><blockquote><p>求解不等式$5x_1 + 4x_2 - x_3 \le 10, 1 \le x_i \le 3, i=1,2,3$ 的整数解.</p></blockquote><p>这个问题不满足多米诺性质<del>否则为什么要举这个例子</del></p><p><strong>[证明]</strong>:</p><script type="math/tex; mode=display">\begin{aligned}& 当 5x_1 + 4x_2 - x_3 \le 10 成立时 \\& 显然 5x_1 + 4x_2 \le 10 不一定成立\\\end{aligned}</script><p>因此如果只是这样的话,没办法用回溯法解决.</p><p>但也是可以用回溯法解决的. </p><p>将不等式 $5x_1 + 4x_2 - x_3 \le 10, 1 \le x_i \le 3, i=1,2,3$ 修改为 $- x_1 + 5x_2 + 4x_3 \le 10, 1 \le x_i \le 3, i=1,2,3$ , 就可以使用回溯法了.</p><p><strong>[证明]</strong>:</p><script type="math/tex; mode=display">\begin{aligned}& 当 - x_1 + 5x_2 + 4x_3 \le 10 成立时 \\& 显然 - x_1 + 5x_2 \le - x_1 + 5x_2 + 4x_3 \le 10 成立\\& 当 - x_1 + 5x_2 \le 10 成立时\\& 显然 - x_1 \le - x_1 + 5x_2 \le 10成立\\\end{aligned}</script><p>因此不等式$-x_1 + 5x_2 + 4x_3 \le 10, 1 \le x_i \le 3, i=1,2,3$满足多米诺性质.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在复习算法, &lt;del&gt;没办法,要考试啦&lt;/del&gt;. 在复习回溯法的时候终于理解了之前不是很清楚的多米诺性质.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="https://yx1302317313.github.io/2019/04/13/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>https://yx1302317313.github.io/2019/04/13/优先队列/</id>
    <published>2019-04-13T13:53:40.000Z</published>
    <updated>2019-10-19T08:20:57.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列是一个特殊的队列.</p><ul><li>相同点: 元素从队尾插入, 从队首删除.</li><li>不同点:<ul><li>队列: 队列是先进先出(FIFO)</li><li>优先队列: 优先队列是根据元素的大小决定元素的出队顺序. 所以称之为优先队列.</li></ul></li></ul><a id="more"></a><h2 id="C-STL的优先队列"><a href="#C-STL的优先队列" class="headerlink" title="C++ STL的优先队列"></a>C++ STL的优先队列</h2><pre><code class="lang-cpp">#include &lt;queue&gt;#include &lt;iostream&gt;int main(){    std::priority_queue&lt;int&gt; pq;    pq.push(1);    pq.push(10);    pq.push(20);    pq.push(18);    pq.push(3);    pq.push(12);    int size = pq.size();    for (int i=0; i &lt; size; i++)    {        std::cout&lt;&lt;pq.top()&lt;&lt;&#39; &#39;;        pq.pop();    }    std::cout&lt;&lt;std::endl;    return 0;}</code></pre><pre><code># 运行结果:20 18 12 10 3 1</code></pre><h3 id="自定义优先队列比较函数"><a href="#自定义优先队列比较函数" class="headerlink" title="自定义优先队列比较函数"></a>自定义优先队列比较函数</h3><p>优先队列实际上是的一个堆, 在STL中,优先队列默认是一个大顶堆, 从排序角度看, 就是降序排序(从大到小).</p><p>让我们看一下优先队列在STL中的说明</p><pre><code class="lang-cpp">/**   *  @brief  A standard container automatically sorting its contents.   *   *  @ingroup sequences   *   *  @tparam _Tp  Type of element.   *  @tparam _Sequence  Type of underlying sequence, defaults to vector&lt;_Tp&gt;.   *  @tparam _Compare  Comparison function object type, defaults to   *                    less&lt;_Sequence::value_type&gt;.   */    template&lt;typename _Tp, typename _Sequence = vector&lt;_Tp&gt;,       typename _Compare  = less&lt;typename _Sequence::value_type&gt; &gt;    class priority_queue    {}</code></pre><p>可以看到priority_queue类模板实际有三个参数.</p><ol><li>_Tp: 元素类型,就是我们存放在优先队列中的元素类型.</li><li>_Sequence: 元素序列, 默认是vector<_tp>.</_tp></li><li>_Compare: 比较函数, 默认是less<_sequence::value_type>. 从这里可以知道默认是大顶堆.</_sequence::value_type></li></ol><p>如果我们需要一个从小到大的优先队列, 则要多增加一个比较函数的参数，但是这时第二个参数也需要传入，否则默认参数匹配会出错。</p><pre><code class="lang-cpp">std::priority_queue&lt;int, std::vector&lt;int&gt;, greater&lt;int&gt; pq;    //从小到大的优先队列</code></pre><h3 id="重载比较运算符"><a href="#重载比较运算符" class="headerlink" title="重载比较运算符"></a>重载比较运算符</h3><pre><code class="lang-cpp">struct Test{    int num;    char c;    //注意：必须要用const修饰重载函数    bool operator &gt; (const Test&amp; obj) const    {        return this-&gt;num &gt; obj.num;    }    bool operator &lt; (const Test&amp; obj) const    {        return this-&gt;num &lt; obj.num;    }}Test;int main(){    priority_queue&lt;Test, vector&lt;Test&gt;, less&lt;Test&gt;&gt; pq1;    priority_queue&lt;Test, vector&lt;Test&gt;, greater&lt;Test&gt;&gt; pq2;    return 0;}</code></pre><h3 id="自定义比较类"><a href="#自定义比较类" class="headerlink" title="自定义比较类"></a>自定义比较类</h3><h2 id="优先队列代码实现"><a href="#优先队列代码实现" class="headerlink" title="优先队列代码实现"></a>优先队列代码实现</h2><p>上面已经提到优先队列实际是一个堆,<br>因此可以通过堆的相关算法实现优先队列.</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;template&lt;class T&gt;class PriorityQueue{private:    std::vector&lt;T&gt; data;public:    PriorityQueue()    {    }    bool empty() const     {        return data.size()? false:true;    }    int size() const     {        return data.size();    }    T top() const     {        if (!this-&gt;empty())        {            return this-&gt;data[0];        }        return 0;    }    void push(T data)    {        this-&gt;pushHeap(data);    }    void pop()    {        this-&gt;popHeap();    }private:     void popHeap()    {        this-&gt;data.erase(this-&gt;data.begin());    //delete the top         this-&gt;adjustHeap(0, this-&gt;data.size());    //adjust heap     }    void adjustHeap(int i, int length)    {        for(int child = 2*i+1; child &lt; length; child = 2*i+1)        {            if(child + 1 &lt; length &amp;&amp; this-&gt;data[child+1] &gt; this-&gt;data[child])            {                child += 1;            }            if(this-&gt;data[child] &gt; this-&gt;data[i])            {                this-&gt;swap(this-&gt;data[child], this-&gt;data[i]);                i = child;            }            else             {                break; // adjust over             }        }    }    void pushHeap(T data)    {        this-&gt;data.push_back(data);        int end = this-&gt;data.size()-1;          for(int i=floor(end*0.5 - 0.5); i&gt;=0; i=floor(i*0.5 - 0.5))        {            this-&gt;adjustHeap(i, end+1);        }    }    void swap(T &amp;a, T &amp;b)    {        T temp = a;        a = b;        b = temp;    }};int main(){    PriorityQueue&lt;int&gt; pq;    pq.push(1);    pq.push(10);    pq.push(20);    pq.push(18);    pq.push(3);    pq.push(12);    int size = pq.size();    for (int i=0; i &lt; size; i++)    {        std::cout&lt;&lt;pq.top()&lt;&lt;&#39; &#39;;        pq.pop();    }    std::cout&lt;&lt;std::endl;            return 0;}</code></pre><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优先队列&quot;&gt;&lt;a href=&quot;#优先队列&quot; class=&quot;headerlink&quot; title=&quot;优先队列&quot;&gt;&lt;/a&gt;优先队列&lt;/h2&gt;&lt;p&gt;优先队列是一个特殊的队列.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相同点: 元素从队尾插入, 从队首删除.&lt;/li&gt;
&lt;li&gt;不同点:&lt;ul&gt;
&lt;li&gt;队列: 队列是先进先出(FIFO)&lt;/li&gt;
&lt;li&gt;优先队列: 优先队列是根据元素的大小决定元素的出队顺序. 所以称之为优先队列.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Code" scheme="https://yx1302317313.github.io/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>IEEE浮点数</title>
    <link href="https://yx1302317313.github.io/2019/04/11/IEEE%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    <id>https://yx1302317313.github.io/2019/04/11/IEEE浮点数/</id>
    <published>2019-04-11T11:33:46.000Z</published>
    <updated>2019-10-19T08:21:33.053Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前在看卡马克快速开方的程序时, 看到了一些神奇的操作.其中有两条语句与浮点数在计算机中的表示方式有关.最近计算机组成原理刚讲完浮点数的表示, 于是写篇博客记录一下.</p></blockquote><a id="more"></a><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=402073807&auto=1&height=66"></iframe></center><h3 id="计算机中定点数的表示"><a href="#计算机中定点数的表示" class="headerlink" title="计算机中定点数的表示"></a>计算机中定点数的表示</h3><p><strong>定点数</strong>: 顾名思义, 定点数就是小数点的位置固定. 但是我们一般不会在计算机中用专门的一个位表示小数点,那样太浪费了. 因为小数点的位置的固定,只要我们知道它的位置就可以确定这个定点数, 没有必要把它表示出来.</p><p>下图是纯小数和纯整数的表示, 这个比较简单, 不进行赘诉.</p><center><img src="http://ww1.sinaimg.cn/mw690/78f9859egw1eysn2zlj5sg20cg03h3yc.gif"></center><h3 id="计算机中浮点数的表示"><a href="#计算机中浮点数的表示" class="headerlink" title="计算机中浮点数的表示"></a>计算机中浮点数的表示</h3><p><strong>浮点数</strong>: 与定点数相对, 浮点数就是这个数的小数点是不固定的(浮动的). </p><h3 id="IEEE浮点数"><a href="#IEEE浮点数" class="headerlink" title="IEEE浮点数"></a>IEEE浮点数</h3><h3 id="转换demo"><a href="#转换demo" class="headerlink" title="转换demo"></a>转换demo</h3><h3 id="卡马克快速开方"><a href="#卡马克快速开方" class="headerlink" title="卡马克快速开方"></a>卡马克快速开方</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前在看卡马克快速开方的程序时, 看到了一些神奇的操作.其中有两条语句与浮点数在计算机中的表示方式有关.最近计算机组成原理刚讲完浮点数的表示, 于是写篇博客记录一下.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MCU" scheme="https://yx1302317313.github.io/categories/MCU/"/>
    
    
      <category term="计算机组成" scheme="https://yx1302317313.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>阅读:流星之绊</title>
    <link href="https://yx1302317313.github.io/2019/03/17/%E9%98%85%E8%AF%BB-%E6%B5%81%E6%98%9F%E4%B9%8B%E7%BB%8A/"/>
    <id>https://yx1302317313.github.io/2019/03/17/阅读-流星之绊/</id>
    <published>2019-03-17T14:43:38.000Z</published>
    <updated>2019-06-22T03:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们三人就像流星, 毫无目标的飞逝, 不知将在何处燃烧殆尽. 但不论何时, 都会有一根纽带将我们紧密相联: 一定要手刃凶手.</p></blockquote><a id="more"></a><center><img src="/img/blog/star.jpg"></center><blockquote><p>开学三个星期了, 虽然感觉课不多, 但是一直没有时间写博客. 今天终于在肝完一个动态规划之后还有点时间(&gt;<em>&lt;).<br>于是写写开学前两周看完的一本书. <em>_流星之绊—东野圭吾</em></em></p><p>之前也看过几本东野圭吾的书, 这本书还是东野圭吾一贯的风格, 不过感觉结局相对其他书较好一点.</p></blockquote><div align="center"><audio controls>    <source src="/music/重生-容祖儿.mp3"></audio><p>重生-容祖儿</p></div><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>故事开篇, 兄妹三人(老大:功一; 老二: 泰辅; 妹妹: 静奈)背着父母跑出去看流星, 然而由于天气原因, 无功而返. 但他们回到家之后, 发现父母已经被人杀死了. 这对于几个还在上小学的孩子来说绝对如世界末日一般. 随后警察到来, 当然肯定是找不到凶手的啦(否则作者怎么往下写呀). 几个月的调查, 都是一些不痛不痒的线索, 无奈之下只能不了了之, 兄妹三人被送到了孤儿所.</p><h3 id="中篇"><a href="#中篇" class="headerlink" title="中篇"></a>中篇</h3><p>兄妹三人一直在孤儿所生活直到高中毕业. 期间他们又去看了几次流星, 并且下定决心一定要找到凶手.</p><blockquote><p>我们三人就像流星, 毫无目标的飞逝, 不知将在何处燃烧殆尽. 但不论何时, 都会有一根纽带将我们紧密相联: 一定要手刃凶手.</p></blockquote><p>离开孤儿院后, 三人走上了一条行骗之路. 利用三人各自的特点骗钱.<br>决定走上诈骗这条路是因为功一和静奈都被人骗过, 三人感到社会不公, 决定以其人之道还制其人之身, 用诈骗的方式为自己找公道(好像很有道理, 嘻嘻!).</p><p>大哥功一思维缜密, 制定行动方案. 泰辅擅长表演, 非常适合扮演各类角色. 而妹妹则是另外一个重要环节, 由于妹妹是一个翩若惊鸿,婉若游龙(<del>在这里不得不佩服一下曹植</del>)的美女, 在接触诈骗对象时可以降低他们的防御心理.(<del>不要想歪了</del>)</p><p>所以诈骗对象都是一些有钱的但是没有女朋友的青年男子(<del>好惨…</del>).</p><p>基本套路就是妹妹先接触诈骗对象, 而后伙同泰辅扮演的角色按照大哥功一制定的计划进行诈骗.<br>就这样兄妹三人非常顺利的完成了几次诈骗. 同时父母的案件也快要到期了, 凶手仍然无从找起.</p><h3 id="高潮"><a href="#高潮" class="headerlink" title="高潮"></a>高潮</h3><p>就在兄妹三人准备完成最后一次诈骗就金盆洗手时, 他们发现了凶手. 这次的诈骗对象是一家洋食店老板的儿子(行成). 本来打算想让他喜欢上静奈, 然后给静奈买一枚戒指. 然而老二却发现这家洋食店的老板就是当时案发从他家后门跑出的人. 于是三人开始寻找证据手刃凶手, 然而没有找到, 于是三人打算制造证据让警察调查凶手.<br>在这种关键时刻, 他们的嫁祸行为被行成发现了, 同时静奈也真正喜欢上了行成(<del>故事当然要一波三折啦</del>). 本以为一切都泡汤了, 谁知行成也发现了父亲的可疑, 想知道真相,帮助他们完成了嫁祸行动(未免也太正直了吧).<br>就在所有证据都指向行成的父亲时, 他父亲仍然否认他是凶手. 随后抛出了一个 <strong>惊人的秘密</strong>.(<del>半夜写这种东西, 有点惊悚</del>)</p><h3 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h3><p>行成的父亲拿出了一把雨伞, 原来行成的父亲真的在案发当天去了兄妹三人家中, 但是他去的的时候他们的父母已经被人迫害. 惊慌之下他拿错了雨伞, 因为案发当天正在下雨(<del>正常操作</del>), 凶手和他用着同一款雨伞, 而他那错的那把伞是真正的凶手的, 留有凶手的指纹. 最终发现, 凶手居然是一开始帮助兄妹三人积极调查案件的警察. 这位警察为了给自己的儿子治病, 向兄妹三人的父亲借钱, 但是没有谈妥, 情急之下杀了他们的父母. 但是这个警察的儿子还是不治而终.(或许是报应吧)</p><p>虽然找到了凶手, 但是功一决定原谅这位警察. 而这位警察却选择自杀了, 或许是因为儿子的死已经绝望, 或许是为自己的罪行救赎.<br>经过这件事之后, 老大和老二决定为他们的行骗行为赎罪, 决定自首. 但是他们不想自己的妹妹去自首, 于是把妹妹托付给了行成.</p><p>故事到这里就结束了.</p><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><ol><li>其实还是很难接受这个结果, 警察居然为了钱杀了兄妹三人的父母, 一直以为他是好人的, 虽然东野圭吾在写的时候已经留下了伏笔.</li><li><p>还有一个问题, 行成的父亲发现了案发现场为什么不去报警.</p></li><li><p>这篇小说中能感受到一些令人感到温暖的情节, 尤其是兄妹三人在父母去世后互帮互助, 能感受到一种令人欣慰的亲情.  还有兄弟二人在找到凶手后, 为自己之前的行骗行为赎罪.</p></li><li>书中另外一个重要的角色行成, 一个认真, 正直的人, 让我们感觉到这个世界还是有好人的.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们三人就像流星, 毫无目标的飞逝, 不知将在何处燃烧殆尽. 但不论何时, 都会有一根纽带将我们紧密相联: 一定要手刃凶手.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="阅读" scheme="https://yx1302317313.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>IIC为什么需要用开漏输出和上拉电阻</title>
    <link href="https://yx1302317313.github.io/2019/03/09/IIC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%94%A8%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E5%92%8C%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB/"/>
    <id>https://yx1302317313.github.io/2019/03/09/IIC为什么需要用开漏输出和上拉电阻/</id>
    <published>2019-03-09T07:28:44.000Z</published>
    <updated>2019-06-22T03:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在调ICM20602模块(一个六轴陀螺仪和加速度计), 使用IIC通信协议, 这个过程中遇到一个困扰我很长时间的问题.<br>IIC协议正确, 但是一直读取失败.最后发现因为没配置GPIO为开漏输出.</p></blockquote><a id="more"></a><center><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/I2C.svg/1920px-I2C.svg.png" width="500"></center><h3 id="推挽输出和开漏输出"><a href="#推挽输出和开漏输出" class="headerlink" title="推挽输出和开漏输出"></a>推挽输出和开漏输出</h3><ul><li>推挽输出: 输出逻辑0，则N-MOS激活；输出逻辑1，P-MOS激活。</li><li>开漏输出: <ul><li>在不接上拉电阻时, 输出逻辑0，则N-MOS激活；输出逻辑1，P-MOS不会激活, 不会输出高电平。</li><li>在接上拉电阻时, 输出逻辑0，则N-MOS激活；输出逻辑1，P-MOS激活, 可以输出高电平。</li></ul></li></ul><blockquote><p>也就是说开漏输出如果不接上拉电阻, 没有输出高电平的能力.<br>如果需要开漏输出有输出高电平的能力需要接一个上拉电阻. 目前很多单片机GPIO可以通过软件配置上拉电阻.</p></blockquote><center><img src="https://user-images.githubusercontent.com/39959472/59958504-50bf3380-94da-11e9-90aa-b133d878cdb4.png" width="500"><p>左图为开漏输出(接上拉电阻), 右图为推挽输出</p></center><h3 id="开漏输出的作用"><a href="#开漏输出的作用" class="headerlink" title="开漏输出的作用"></a>开漏输出的作用</h3><ul><li>防止短路: 在一些情况下(比如总线), 多个GPIO口可能会连接在同一根线上, 存在某个GPIO输出高电平, 另一个GPIO输出低电平的情况. 如果使用推挽输出, 你会发现这个GPIO的VCC和另一个GPIO的GND接在了一起, 也就是短路了(<del>凉凉了</del>). 如果换成开漏输出呢? VCC和GND多了个电阻, 这样电路就是安全的.<strong>所以总线一般会使用开漏输出.</strong></li></ul><center><img src="https://www.allaboutcircuits.com/uploads/articles/I2C2_circuit3.jpg" width="300"><p>VCC与GND连到了一起</p></center><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=480579211&auto=1&height=66"></iframe></center><ul><li>线与: 开漏输出还能实现 <strong>线与</strong> (自行百度), 减少一个与门, 简化电路.</li></ul><p><br></p><h3 id="IIC为什么用开漏输出和上拉电阻"><a href="#IIC为什么用开漏输出和上拉电阻" class="headerlink" title="IIC为什么用开漏输出和上拉电阻"></a>IIC为什么用开漏输出和上拉电阻</h3><blockquote><p>其实知道了开漏输出的作用, 这个问题不难回答</p></blockquote><ol><li><p>IIC协议支持多个主设备与多个从设备在一条总线上, 如果不用开漏输出, 而用推挽输出, 会出现主设备之间短路的情况. 至于为什么需要上拉电阻, 那是因为IIC通信需要输出高电平的能力.</p></li><li><p>为了实现多个主设备抢占总线时的仲裁. </p><p>IIC只有两根线(SCL和SDA), 怎么判断哪个主设备占用总线(当然是先来后到了). 假设主设备A需要启动IIC, 他需要在SCL高电平时, 将SDA由高电平转换为低电平作为启动信号. 主设备A在把SDA拉高后, 它需要再检查一下SDA的电平.</p><ul><li>SDA是高电平, 说明主设备A可以占用总线, 然后主设备A将SDA拉低, 开始通信.</li><li>SDA是低电平, 说明有人已经捷足先登了, 主设备A不能占用总线, 结束通信.</li></ul><p>为什么? 因为线与. 如果主设备A拉高SDA时, 已经有其他主设备将SDA拉低了. 由于 <strong>1 &amp; 0 = 0</strong> 那么主设备A在检查SDA电平时, 会发现不是高电平, 而是低电平. <strong>说明其他主设备抢占总线的时间比它早</strong>, 主设备A只能放弃占用总线. 如果是高电平, 则可以占用.</p><p>这就是开漏输出在IIC通信中的另一个作用.</p></li></ol><p><strong>因此, 模拟IIC一定要将GPIO端口设置为开漏输出并加上上拉电阻.(硬件IIC会自动配置为开漏输出)</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在调ICM20602模块(一个六轴陀螺仪和加速度计), 使用IIC通信协议, 这个过程中遇到一个困扰我很长时间的问题.&lt;br&gt;IIC协议正确, 但是一直读取失败.最后发现因为没配置GPIO为开漏输出.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MCU" scheme="https://yx1302317313.github.io/categories/MCU/"/>
    
    
      <category term="通信协议" scheme="https://yx1302317313.github.io/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="电路" scheme="https://yx1302317313.github.io/tags/%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>梯度与梯度下降法</title>
    <link href="https://yx1302317313.github.io/2019/02/25/%E6%A2%AF%E5%BA%A6%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/"/>
    <id>https://yx1302317313.github.io/2019/02/25/梯度与梯度下降法/</id>
    <published>2019-02-25T11:53:53.000Z</published>
    <updated>2019-06-24T15:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>声明: 本文有一部分本人自己的观点和理解, 不一定完全正确, 仅供参考. 如果发现错误或者有疑问的地方, 请指出, 谢谢!</strong></p><a id="more"></a><h3 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h3><blockquote><p>导数和偏导数的概念比较简单而且很多人接触过，这里不进行赘诉。</p></blockquote><p>我们直接看方向导数。<br>对于多变量函数$F(x, y, z)$, 我们想知道它在点$P<em>0$沿方向$\vec l$ 的变化率，用$\left. \frac {\partial F} {\partial {\vec l}} \right| </em>{P_0} $ 表示。这就是函数F在P点沿方向$\vec l$ 的方向导数。</p><blockquote><p>如果你熟悉偏导数的话， 你可以看出来方向导数和偏导数很像。偏导数是函数在特定方向上（如x轴， y轴）的变化率。 方向导数是函数在任意方向上的变化率。<strong>方向导数可以理解为在任意方向上的偏导数</strong>。毕竟我们对于函数的研究不能仅仅局限在某几个方向。</p></blockquote><p>方向导数公式</p><script type="math/tex; mode=display">\begin{align}\left. \frac {\partial F} {\partial {\vec l}} \right| _{P_0} &= lim \frac {F(P) - F(P_0)} {|PP_0|} \\&= \left. \frac {\partial F} {\partial x} \right| _{P_0} cos \alpha + \left. \frac {\partial F} {\partial y} \right| _{P_0} cos \beta +  \left. \frac {\partial F} {\partial z} \right| _{P_0} cos \gamma\end{align}</script><p>其中$cos \alpha$, $cos \beta$, $cos \gamma$ 分别为$\vec l$ 与x, y, z 的方向余弦。</p><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><blockquote><p>知道了方向导数，我们考虑一个问题：一个点有无数个方向，也就有无数个方向导数（前提是方向导数存在），那么我们最关心的是哪个？（总不能都关心吧，那也太花心了）答案是我们关心最大的方向导数。</p></blockquote><p><strong>最大的方向导数意为着沿着这个方向函数变化最快（函数的变化率最大）。</strong></p><h4 id="哪个方向的方向导数最大？"><a href="#哪个方向的方向导数最大？" class="headerlink" title="哪个方向的方向导数最大？"></a>哪个方向的方向导数最大？</h4><p>把方向导数的公式变换一下</p><script type="math/tex; mode=display">\begin{align}\left. \frac {\partial F} {\partial {\vec l}} \right| _{P_0}&= \left. \frac {\partial F} {\partial x} \right| _{P_0} cos \alpha + \left. \frac {\partial F} {\partial y} \right| _{P_0} cos \beta +  \left. \frac {\partial F} {\partial z} \right| _{P_0} cos \gamma \\&= G *（cos \alpha, cos \beta, cos \gamma）\\&= |G| cos<G, \vec l>\end{align}</script><p>其中$G=(\left. \frac {\partial F} {\partial x} \right| <em>{P_0}, \left. \frac {\partial F} {\partial y} \right| </em>{P<em>0},  \left. \frac {\partial F} {\partial z} \right| </em>{P_0})$<br>由向量的知识，我们知道当$\vec l$与G同向时，即$cos(G, \vec{l})=1$时值最大。</p><p><strong>梯度至此诞生</strong></p><blockquote><p>梯度的意义就是用来表示最大的方向导数。</p></blockquote><script type="math/tex; mode=display">grad F = ( \frac {\partial F} {\partial x}, \frac {\partial F} {\partial y},   \frac {\partial F} {\partial z})</script><p><strong>说明</strong></p><ul><li>梯度是一个向量</li><li>梯度的方向是最大方向导数的方向。</li><li>梯度的大小是这个最大方向导数的值。</li></ul><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><blockquote><p>梯度下降法就是利用梯度的性质求解函数最小值的方法.</p></blockquote><p><strong>[思考]:</strong>  对于一元函数我们求解函数最小值的方法有很多, 很多人比较喜欢的就是求导. 如果是多元函数求解最小值或者最大值, 我们还能如此简单的解决吗?该怎么求导? 求偏导吗?求哪个偏导?</p><p>显然这个问题不是简单的求导就可以解决的, 我们可以通过梯度下降法解决.</p><p>想一想, 梯度代表着什么? 表示最大方向导数的向量. 最大方向导数的代表着函数沿着这个方向增长最快, 如果我们反其道而行之, 是不是方向就是函数减小最快的方向. 如果我们每次都能沿着减小最快的方向逼近最小值, 我们是不是就可以最快的找到最小值(或者近似的最小值).</p><p>像这样:</p><center><img src="https://user-images.githubusercontent.com/39959472/59958596-c8da2900-94db-11e9-91f5-b644e5130018.png" width="500"></center><blockquote><p>可以这样理解梯度下降法, 我们在当前点找到该点的梯度, 然后沿着梯度的负方向前进一段距离到达一个新的点, 然后再计算梯度, 前进一段距离. 一直这样重复下去, 直到找到最小值或者接近最小值.</p></blockquote><h4 id="公式"><a href="#公式" class="headerlink" title="公式:"></a>公式:</h4><script type="math/tex; mode=display">\theta_{i+1} = \theta_{i} - \alpha * grad F(\theta_{i})</script><p>其中$\theta<em>{i}$ 为当前点, 可以是一个向量, 表示函数的多个自变量.$\theta</em>{i+1}$为下一个点,   $grad F(\theta_{i}) $是当前点的梯度.$\alpha$表示步长或者学习率(在深度学习中被称为学习率).</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h4><ol><li>式中的$\alpha$不能太大也不能太小.</li></ol><ul><li>太小, 计算速度慢, 需要迭代很多次.</li><li>太大, 可能会跳过最小值.</li></ul><p>2.由于我们每次更新点都会有一定的步长, 在这段距离中梯度是变化的, 我们在一个点找到的梯度不一定就是这一段的梯度, 所以我们不是一直沿着梯度的负方向前进的. 这一点有点像贪心算法, 基于这一点, 我们也不能让$\alpha$太大.</p><h4 id="梯度下降法的缺点"><a href="#梯度下降法的缺点" class="headerlink" title="梯度下降法的缺点"></a>梯度下降法的缺点</h4><p>如果函数比较复杂, 存在很多局部最小值, 可能最后梯度下降找到的是局部最小值, 而不是全局最小值.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;声明: 本文有一部分本人自己的观点和理解, 不一定完全正确, 仅供参考. 如果发现错误或者有疑问的地方, 请指出, 谢谢!&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="机器学习" scheme="https://yx1302317313.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数学" scheme="https://yx1302317313.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>博客中使用外链音乐</title>
    <link href="https://yx1302317313.github.io/2019/02/18/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%96%E9%93%BE%E9%9F%B3%E4%B9%90/"/>
    <id>https://yx1302317313.github.io/2019/02/18/博客中使用外链音乐/</id>
    <published>2019-02-18T07:05:04.000Z</published>
    <updated>2019-06-22T02:32:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在博客中加入音乐, 可以使读者在阅读时纵享丝滑(德芙是不是应该给我广告费&lt;^_^&gt;)。</p></blockquote><a id="more"></a><p>一般在博客中嵌入的音乐有两种方式:</p><ul><li>使用本地音乐 :就是将自己本地的音乐上传到服务器上, 加载到不可中.</li><li>使用其他音乐平台的音乐: 通过链接访问其他服务器的音乐资源, 将资源加载到你的博客.</li></ul><h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><blockquote><p>自从入坑网易云之后, 一直再用网易云. 网易云网页版自身提供了生成外链的接口.</p></blockquote><div align="center"><img src="/img/blog/blog-music1.png" width="500"></div><p>网易云外链:</p><blockquote><p>只需要修改src=””网址中的id为对应音乐的id即可.</p></blockquote><pre><code class="lang-html">&lt;div align=center&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=1312971394&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;</code></pre><p>效果如下:</p><div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=414118616&auto=1&height=66"></iframe></div><p>再来一个:</p><div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=526464293&auto=1&height=66"></iframe></div><p>咦,你会发现上面的音乐不能播放.原因如下:</p><p><strong>由于我国版权意识越来越强(&gt;_&lt;), 有些音乐需要付费才能下载, 同样需要付费下载的音乐不能通过外链播放.所以使用网易云外链只能链接免费歌曲(<del>也就是大多数音乐是不能外链的</del>).</strong></p><blockquote><p>其他音乐平台的音乐也可以外链,比如QQ音乐.具体方法类似,只是链接的html格式不同,这里就不多说了.</p></blockquote><p>对于付费歌曲还是有解决办法的, 就是上面提到的第一种方法—本地音乐.</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>提供一个链接: <a href="https://music.liuzhijin.cn/" target="_blank" rel="noopener">https://music.liuzhijin.cn/</a></p><div align="center"><img src="/img/blog/blog-music2.png" width="700"></div><p>在该网站中, 搜索你需要的音乐, 复制右边的链接.将下面代码中src的内容改为你复制的链接, 就搞定了.</p><pre><code class="lang-html">&lt;div align=center&gt;&lt;audio controls&gt;    &lt;source src=&quot;http://m10.music.126.net/20190218180725/937019887458e8d14806f9b1623ec119/ymusic/6428/0c3d/4a14/cef6263c9a09bfc03fafbb15f6a99533.mp3&quot; &gt;&lt;/audio&gt;&lt;/div&gt;</code></pre><p>效果如下:</p><blockquote><p>和之前的网易云外链比起来, 界面确实”空空如也”…<br>但也知足吧.如果你想美化界面, 也是可以的.</p></blockquote><div align="center"><audio controls>    <source src="/music/空空如也.mp3"></audio><p>空空如也-任然</p></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在博客中加入音乐, 可以使读者在阅读时纵享丝滑(德芙是不是应该给我广告费&amp;lt;^_^&amp;gt;)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://yx1302317313.github.io/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>卡尔曼滤波 [翻译]</title>
    <link href="https://yx1302317313.github.io/2019/02/18/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2-%E7%BF%BB%E8%AF%91/"/>
    <id>https://yx1302317313.github.io/2019/02/18/卡尔曼滤波-翻译/</id>
    <published>2019-02-18T05:18:48.000Z</published>
    <updated>2019-10-19T08:19:45.776Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近学习卡尔曼滤波, 发现了一篇很好的博客. 也就是从这篇博客开始, 才逐渐开始理解卡尔曼滤波.<br>这篇博客没有像其他很多教程那样用一大堆公式让初学者望而却步. 但是看完之后, 你会发现你不仅理解了卡尔曼滤波的过程, 也对那些看着头痛欲裂的数学公式有所了解.</p><p>个人感觉这是一篇很棒的文章.<br>由于原文章是英文的, 这里将其翻译为中文.(由于水平有限, 翻译的质量本人也不敢恭维, 请见谅!)</p></blockquote><a id="more"></a><blockquote><p>如果英文水平还可以, 建议直接阅读原英文文章. 这里给出原文链接. <a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/#mathybits" target="_blank" rel="noopener">How a Kalman filter works, in pictures</a></p></blockquote><p><strong>如有侵权, 请联系我删除 !</strong>(博客末尾有本人邮箱联系方式)</p><p><br></p><div align="center"><audio controls>    <source src="/music/一千年以后-林俊杰.mp3"></audio><p>一千年以后-林俊杰</p></div><p>翻译如下:<br><strong>注意: 如果文中数学公式加载错误, 请刷新后重试</strong></p><h3 id="卡尔曼滤波可以做什么"><a href="#卡尔曼滤波可以做什么" class="headerlink" title="卡尔曼滤波可以做什么"></a>卡尔曼滤波可以做什么</h3><p>让我们看一个玩具的例子: 假设你有一个可以在树林中运动的小机器人， 这个机器人需要确切的位置用于导航。</p><p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/robot_forest-300x160.png"></p><p>这个机器人有一个状态$\vec {x_k}$, 它包含位置和速度信息。</p><script type="math/tex; mode=display">\vec{x_k} = (\vec{p}, \vec{v})</script><p>注意状态仅仅是关于你的系统底层配置的一系列数字,它可以是任何数字.在我们的例子中它是位置和速度, 但它可以是有关水池中的液体量的数据, 可以是汽车引擎的温度, 可以是用户手指在触摸板上的位置, 或者是任何你需要跟踪的数据.</p><p>我们的机器人同时有一个精度是10米的GPS传感器, 这很好, 但是我们需要知道机器人的位置精度要高于10米. 在树林中有大量的水沟和悬崖, 如果机器人运动出错超过几英尺, 他可能会掉下悬崖. 所以它携带的GPS传感器不是足够的好.</p><p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/robot_ohnoes-300x283.png"></p><p>我们可能也知道一些关于机器人运动的信息. 例如, 它知道发送给机器人动机的指令, 它知道如果它一直不受干扰的向着一个方向前进, 在下一个瞬间它可能会在相同的方向走的更远. 当然它不知道关于电机的所有信息: 它可能受到风的冲击, 轮子可能有一点打滑, 或者是滚过崎岖不平的地形; 所以车轮转动的数量可能并不完全代表机器人实际行驶的距离，这样的预测是不完美的.</p><p>GPS <strong>传感器</strong> 告诉了我们一些关于机器人状态的信息, 但仅仅是间接的, 并且伴随着一些不确定性和不准确性. 我们的 <strong>预测</strong> 告诉我们一些机器人如何移动的信息,但只是间接的, 同样伴随着一些不确定性和不准确性.</p><p>但是如果我们使用所有可用信息, 我们是否能够得到一个比估计更好的答案? 当然答案是肯定的, 这就是卡尔曼滤波的作用.</p><h3 id="卡尔曼滤波怎么看待你的问题"><a href="#卡尔曼滤波怎么看待你的问题" class="headerlink" title="卡尔曼滤波怎么看待你的问题"></a>卡尔曼滤波怎么看待你的问题</h3><p>我们看一下我们尝试解决的问题的背景. 我们继续用一个只有位置和速度信息的状态进行讨论.</p><script type="math/tex; mode=display">\vec{x} = \begin{bmatrix} p\\ v \end{bmatrix}</script><p>我们不知道实际的位置和速度是什么; 有大量位置和速度的组合可能是正确的.但是有一些组合会比其他组合更有可能.</p><p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_0.png" width="400"></p><p>卡尔曼滤波假设所有变量(在我们的例子中是位置和速度)都是随机的并且符合高斯分布. 每一个变量都有一个均值$\mu$, 它是随机分布的平均值(它也是最可能的状态), 和一个方差$\sigma^2$, 它表示了不确定度.</p><p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_1.png" width="400"></p><p>在上面的图片中, 位置和速度是不相关的, 意味着一个变量的状态不会告诉你其他变量可能的任何信息.</p><p>下面的例子展示了一些更有趣的事情: 位置和速度是相关的.观察到一个特定位置的可能性取决于你拥有的速度.</p><p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_3.png" width="400"></p><p>这种情况是可能出现的, 例如, 你正在基于一个旧的位置估计一个新的位置.如果我们的速度很高, 我们可能移动的更远, 因此我们的位置将会更远. 如果我们移动的比较慢, 我们就不能达到那么远.</p><p>这种关系对于跟踪数据非常重要，因为它为我们提供了更多信息: 一个测量数据告诉了我们一些关于其他数据可能的信息. 这就是卡尔曼滤波的目的, 我们希望尽可能地从我们不确定的测量中得到更多的信息.</p><p>这种相关性可以用<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E6%96%B9%E5%B7%AE" target="_blank" rel="noopener">协方差矩阵</a>描述. 总之, 矩阵$\Sigma<em>{ij}$的每一个元素是第i个状态变量和第j个状态变量的相关度.(您可能会猜到协方差矩阵是对称的，这意味着如果交换i和j是无关紧要的). 协方差矩阵通常标记为“$\Sigma$”，因此我们将其元素称为“$\Sigma</em>{ij}$”。</p><p><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_2.png" width="400"></p><h3 id="用矩阵描述问题"><a href="#用矩阵描述问题" class="headerlink" title="用矩阵描述问题"></a>用矩阵描述问题</h3><p>我们将关于机器人状态的信息建模为斑点, 因此我们需要时间k时的两条信息: 我们将把我们的最佳估计称为$\mathbf{\hat{x}_k}$ (均值, 也称为$\mu$), 和它的协方差矩阵$P_k$</p><script type="math/tex; mode=display">\mathbf{\hat{x}_k} = \left[ \begin{matrix}  \text{position}\\  \text{velocity}  \end{matrix}\right]\\P_k = \left[ \begin{matrix}  \Sigma_{pp} & \Sigma_{pv} \\  \Sigma_{vp} & \Sigma_{vv} \end{matrix}\right]</script><p>当然我们在这里只使用位置和速度，但是请记住, 状态可以包含任意数量的变量, 用来代表你想要的任何东西.</p><p>接下来，我们需要一些方法来查看当前状态（在时间k-1时）并预测在时间k时的下一个状态.</p><p>请记住，我们不知道哪个状态是“真正的”状态，但我们的预测功能并不关心这个。它适用于这些情况，并为我们提供一个新的分布.</p><div align="center"><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_7.jpg" width="500"></div><p>我们可以使用矩阵 $F_k$重新表示这个预测步骤.</p><div align="center"><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_8.jpg" width="500"></div><p>如果原估计是正确的, 它将原始估计的每一个点移动到一个新的预测位置.</p><p>让我们应用这个矩阵, 我们怎样使用这个矩阵预测接下来的一个瞬间的位置和速度呢?<br>我们将会使用一个非常基础的运动公式.</p><script type="math/tex; mode=display">{\color{deeppink}{p_k}} = {\color{royalblue}{p_{k-1}}} + \Delta t \color{royalblue}{v_{k-1}} \\{\color{deeppink}{v_k}} = \color{royalblue}{v_{k-1}}</script><p>换成矩阵的形式:</p><script type="math/tex; mode=display">{\color{deeppink} {\hat{x}}_k} =\begin{bmatrix}   1 & \Delta t \\   0 & 1 \end{bmatrix} {\color{royalblue} {\hat{x}}_{k-1}} = {F}_k {\color{royalblue} {\hat{x}}_{k-1}}</script><p>现在我们有一个可以给出下一个状态的预测矩阵, 但是我们仍然不知道怎么更新它的协方差矩阵.</p><p>这里我们需要另外一个公式. 如果我们用一个矩阵A乘以一个分布的每一个点, 然后它的协方差矩阵将会怎么变化?</p><p>好, 它很简单. 这里给出定义:</p><script type="math/tex; mode=display">Cov(x) = \Sigma\\Cov({\color{firebrick}{\mathbf{A}}}x) = {\color{firebrick}{\mathbf{A}}} \Sigma {\color{firebrick}{\mathbf{A}}^T}</script><p>所以</p><script type="math/tex; mode=display">{\color{deeppink}{\mathbf{\hat{x}}_k}} = \mathbf{F}_k {\color{royalblue}{\mathbf{\hat{x}}_{k-1}}}\\{\color{deeppink}{\mathbf{P}_k}} = \mathbf{F_k} {\color{royalblue}{\mathbf{P}_{k-1}}} \mathbf{F}_k^T</script><h3 id="外部影响"><a href="#外部影响" class="headerlink" title="外部影响"></a>外部影响</h3><p>但是, 我们还没有抓住一切影响状态的因素. 可能有一些变化和状态本身没有直接关系—外部世界可能会影响系统.</p><p>例如, 如果状态表示火车的运动, 火车司机可能会推动油门, 造成火车加速. 相似的, 在我们的机器人系统中, 导航软件可能会发出使轮子转动或者停止的命令. 如果我们知道这个关于外部世界将要如何变化的额外信息, 我们可以把它放进一个叫做$\color{darkorange}{\vec{\mathbf{u}_k}}$的向量, 用它做一些事情, 把它加入到我们的预测中作为矫正.</p><p>我们说由于我们知道了油门设置或者控制命令, 我们得到了期望的加速度$\color{darkorange}{a}$</p><p>由基础的运动学只是我们得到:</p><script type="math/tex; mode=display">{\color{deeppink}{p_k}} = {\color{royalblue}{p_{k-1}}} + {\Delta t} {\color{royalblue}{v_{k-1}}} + \frac{1}{2} {\color{darkorange}{a}} {\Delta t}^2\\{\color{deeppink}{v_k}} = {\color{royalblue}{v_{k-1}}} +  {\color{darkorange}{a}} {\Delta t}</script><p>矩阵形式:</p><script type="math/tex; mode=display">{\color{deeppink}{\mathbf{\hat{x}}_k}} = \mathbf{F}_k {\color{royalblue}{\mathbf{\hat{x}}_{k-1}}} + \begin{bmatrix} \frac{\Delta t^2}{2} \\\Delta t \end{bmatrix}\\{\color{darkorange}{a}}= \mathbf{F}_k {\color{royalblue}{\mathbf{\hat{x}}_{k-1}}} + \mathbf{B}_k {\color{darkorange}{\vec{\mathbf{u}_k}}}</script><p>$B_k$被称为控制矩阵, $\vec{u_k}$被称为控制向量.(对于没有外部影响的简单的系统, 你可以忽略它们).</p><p>让我们在多添加一个细节. 如果我们对于将要发生的预测不是一个100%精确的模型将会发生什么?</p><h3 id="外部不确定性"><a href="#外部不确定性" class="headerlink" title="外部不确定性"></a>外部不确定性</h3><p>如果事物的状态都基于自己的属性演变, 一切都很好. 同样, 如果其状态基于外部的影响变化, 一切仍然很好, 只要我们知道这些外部的影响都是什么.</p><p>但是对于我们不知道的影响怎么办? 例如, 我们正在跟踪一个四轴飞行器, 它可能会受到风的冲击. 如果我们正在跟踪一个轮式机器人, 它的轮胎可能会打滑, 可能会因为颠簸路面减速. 我们不可能考虑到一切外部影响, 如果这些外部影响中的任何一个发生了, 我们的预测就可能因为没有考虑到这些外部影响<br>而发生偏离.</p><p>我们可以通过在每一步预测之后添加一些新的不确定性来模拟与这个”世界”(即我们没有考虑的因素)相关的不确定性.</p><center><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_9.jpg" width="500"></center><p>我们原始估计中的每一个状态都可以变为一系列的状态. 因为我们非常的喜欢高斯亮斑, 我们让$x_{k-1}$中的每一个点都移动到协方差为$Q_k$的高斯亮斑内部的某一个位置, 换句话说就是我们将没有考虑到的影响看做协方差为$Q_k$的噪声.</p><center><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_10a.jpg" width="500"></center><p>这样就产生了一个新的协方差不同的高斯亮斑(但是具有相同的均值).</p><center><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_10b.jpg" width="500"></center><p>通过简单的增加一个$Q_k$, 我们得到了一个扩大的协方差, 这样就给出了预测部分完整的表达式.</p><script type="math/tex; mode=display">\begin{aligned}\color{deeppink}{\mathbf{\hat{x}}_k} &= \mathbf{F}_k {\color{royalblue}{\mathbf{\hat{x}}_{k-1}}} + \mathbf{B}_k \color{darkorange}{\vec{\mathbf{u}_k}} \\ \color{deeppink}{\mathbf{P}_k} &= \mathbf{F_k} {\color{royalblue}{\mathbf{P}_{k-1}}} \mathbf{F}_k^T + \color{mediumaquamarine}{\mathbf{Q}_k} \end{aligned}</script><p>换句话说, 当前最优估计值是从上一次最优估计值得到的一个预测值, 同时加上一个对已知外影响的矫正.</p><p>同样, 当前不确定度是从上一次不确定度得到的一个预测值, 加上一些来自外部环境的不确定度.</p><p>好吧, 这很简单. 我们已经对我们系统的状态有了一个模糊的估计, 这个模糊估计由$\color{deeppink}{\mathbf{\hat{x}}_k}$和$\color{deeppink}P_k$ 给出.</p><h3 id="通过测量细化估计"><a href="#通过测量细化估计" class="headerlink" title="通过测量细化估计"></a>通过测量细化估计</h3><p>我们已经有了若干个可以给出系统状态信息的传感器。目前它们测量的数据并不重要；也许一个传感器读到的是位置，另一个得到的是速度。每一个传感器都可以告诉我们一些间接的状态信息—换句话说，传感器在某个状态下运行并且读取到一系列的信息。</p><center><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_12-624x287.jpg" width="500"></center><p>我们注意到读取信息的单位和范围可能与我们想要追踪的状态的单位和范围并不一致。你可能猜到了将要做什么了：我们将用一个矩阵$H_K$对传感器建模。</p><center><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_13.jpg" width="500"></center><p>我们可以计算出传感器读取数据的分布像我们通常希望的那样。</p><script type="math/tex; mode=display">\begin{equation} \begin{aligned} \vec{\mu}_{\text{expected}} &= \mathbf{H}_k \color{deeppink}{\mathbf{\hat{x}}_k} \\ \mathbf{\Sigma}_{\text{expected}} &= \mathbf{H}_k \color{deeppink}{\mathbf{P}_k} \mathbf{H}_k^T \end{aligned} \end{equation}</script><p>卡尔曼滤波擅长的一件事就是处理传感器噪声。换句话说，我们的传感器至少在一定程度上是不可信的，我们原始估计的每一个状态可能会产生一系列的传感器数据。</p><center><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_14.jpg" width="500"></center><p>从观察到的每一个读取数据，我们可以猜测出出系统在一个特殊的状态。但是因为有不确定性存在，一些状态比其他状态更有可能产生我们所看到的数据：</p><center><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_11.jpg" width="500"></center><p>我们称不确定性（例如：传感器噪声）的协方差$\color{mediumaquamarine}{\mathbf{R}_k}$，分布的均值等于我们观察到的读取数据，我们称之为$\color{yellowgreen}{\vec{\mathbf{z}_k}}$.</p><p>现在我们有了两个高斯亮斑：一个在经过转化后的预测值周围，一个在我们得到的实际传感器数据周围。</p><center><img src="https://www.bzarg.com/wp-content/uploads/2015/08/gauss_4.jpg" width="500"></center><h3 id="合并高斯分布"><a href="#合并高斯分布" class="headerlink" title="合并高斯分布"></a>合并高斯分布</h3><h3 id="整合在一起"><a href="#整合在一起" class="headerlink" title="整合在一起"></a>整合在一起</h3><p><strong>未完待续……</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近学习卡尔曼滤波, 发现了一篇很好的博客. 也就是从这篇博客开始, 才逐渐开始理解卡尔曼滤波.&lt;br&gt;这篇博客没有像其他很多教程那样用一大堆公式让初学者望而却步. 但是看完之后, 你会发现你不仅理解了卡尔曼滤波的过程, 也对那些看着头痛欲裂的数学公式有所了解.&lt;/p&gt;
&lt;p&gt;个人感觉这是一篇很棒的文章.&lt;br&gt;由于原文章是英文的, 这里将其翻译为中文.(由于水平有限, 翻译的质量本人也不敢恭维, 请见谅!)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://yx1302317313.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="数学" scheme="https://yx1302317313.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="卡尔曼" scheme="https://yx1302317313.github.io/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC/"/>
    
  </entry>
  
  <entry>
    <title>OSTU算法</title>
    <link href="https://yx1302317313.github.io/2019/02/16/OSTU%E7%AE%97%E6%B3%95/"/>
    <id>https://yx1302317313.github.io/2019/02/16/OSTU算法/</id>
    <published>2019-02-16T10:32:12.000Z</published>
    <updated>2019-06-22T02:19:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OSTU算法"><a href="#OSTU算法" class="headerlink" title="OSTU算法"></a>OSTU算法</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>OSTU算法(最大类间方差法、大津算法): 用来自动对基于聚类的图像进行二值化,或者说将一个灰度图像退化为二值图像。</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%B4%A5%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">大津算法wiki</a></p><a id="more"></a><div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1312971394&auto=1&height=66"></iframe></div><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理:"></a>算法原理:</h4><blockquote><p>通过一个阈值T将图像分为背景和前景, 求出背景的像素均值, 前景的像素均值和整幅图的像素均值, 计算背景和前景的方差. 方差越大意味着背景与前景的区分度越明显, 只要求出使得方差最大的阈值$T<em>{max}$, 则 $T</em>{max}$就是最适合的阈值.</p></blockquote><h4 id="公式"><a href="#公式" class="headerlink" title="公式:"></a>公式:</h4><p><strong>注意: 如果文中数学公式加载错误, 请刷新后重试</strong></p><ul><li>图像大小: M * N</li><li>小于阈值的像素点数量: $N_0$</li><li>大于阈值的像素点数量: $N_1$</li><li>方差: $\sigma^2$</li></ul><script type="math/tex; mode=display">\omega_0 = \frac {N_0} {M * N}\\\omega_1 = \frac {N_1} {M * N}\\\omega_0 + \omega_1 = 1\\\mu = \omega_0 * \mu_0 + \omega_1 * \mu_1\\\sigma^2 = \omega_0 * (\mu_0 - \mu)^2 + \omega_1 * (\mu_1 - \mu)^2</script><p>将$\mu$带入$\sigma^2$得到</p><script type="math/tex; mode=display">\sigma^2 = \omega_0 * \omega_1 * (\mu_0 - \mu_1)^2</script><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul><li>统计灰度图中各像素的个数, 生成像素直方图.</li><li>计算各像素的概率.</li><li>计算阈值 <ul><li>遍历每一个像素值(0-255)作为阈值.</li><li>分别计算前景和背景的像素均值以及概率.</li><li>计算全局均值.</li><li>计算方差.</li><li>更新最大方差和最优阈值.</li></ul></li></ul><h4 id="代码-Opencv"><a href="#代码-Opencv" class="headerlink" title="代码(Opencv)"></a>代码(Opencv)</h4><pre><code class="lang-cpp">#include &lt;opencv/highgui.h&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;cmath&gt;//OSTU算法int OSTU(cv::Mat&amp; src){    int threshold=0;    //阈值    float sigma_temp=0.0f;        float sigma_max = 0.0f;        int pixel_num = src.rows * src.cols;    //像素点个数    int pixel_count[256];    //各像素个数    float pixel_pro[256];    //各像素概率    //初始化    for(int i=0; i&lt;256; i++)    {        pixel_count[i] = 0;    }    // 统计像素个数    for(int i=0; i &lt; src.rows; i++)    {            uchar* data = src.ptr&lt;uchar&gt;(i);        for(int j=0; j &lt; src.cols; j++)        {            pixel_count[data[j]]++;        }    }    //计算像素概率    for(int i=0; i&lt;256; i++)    {        pixel_pro[i] = (float)(pixel_count[i]) / (float)(pixel_num);    }    //计算阈值    for(int i=0; i&lt;256; i++)    {        float w0=0, w1=0, u0=0, u1=0, u=0;        //遍历像素        for(int j=0; j&lt;256; j++)        {                //背景像素            if(j &lt; i)            {                w0 += pixel_pro[j];                u0 += pixel_pro[j] * j;                }            else    //前景像素            {                u1 += pixel_pro[j] * j;            }        }        //全图像素均值        //u = w0 * u0 + (1-w0) * u1;        //方差        sigma_temp = w0 * (1-w0) * pow((u0 - u1), 2);        //更新阈值        if(sigma_temp &gt; sigma_max)        {            sigma_max = sigma_temp;            threshold = i;        }    }    return threshold;}//二值化图像void BinaryImage(cv::Mat&amp; src, cv::Mat&amp; des, int threshold){    for(int i=0; i &lt; src.rows; i++)    {            uchar* src_data = src.ptr&lt;uchar&gt;(i);        uchar* des_data = des.ptr&lt;uchar&gt;(i);        for(int j=0; j &lt; src.cols; j++)        {            if(src_data[j] &lt; threshold)            {                des_data[j] = 0;            }            else            {                des_data[j] = 255;            }        }    }}int main(){        cv::Mat src, gray;    cv::namedWindow(&quot;src&quot;, cv::WINDOW_NORMAL);    cv::namedWindow(&quot;gray&quot;, cv::WINDOW_NORMAL);    cv::namedWindow(&quot;binary&quot;, cv::WINDOW_NORMAL);    src = cv::imread(&quot;../wallhaven-698240.jpg&quot;, cv::IMREAD_COLOR);    cv::cvtColor(src, gray, cv::COLOR_RGB2GRAY);    //转换成灰度图    int threshold = OSTU(gray);        //计算阈值    cv::Mat binary = cv::Mat(gray.rows, gray.cols, CV_8U);        //初始化二值化图像    BinaryImage(gray, binary, threshold);    printf(&quot;threshold: %d\n&quot;, threshold);    //显示RGB图像, 灰度图像, 二值化图像    cv::imshow(&quot;src&quot;, src);    cv::imshow(&quot;gray&quot;, gray);    cv::imshow(&quot;binary&quot;, binary);    cv::waitKey(0);    return 0;}</code></pre><h5 id="RGB图像-原图"><a href="#RGB图像-原图" class="headerlink" title="RGB图像(原图)"></a>RGB图像(原图)</h5><div align="center"><img src="/img/blog/OSTU1.png" width="500"></div><h5 id="灰度图像-经过Opencv转化"><a href="#灰度图像-经过Opencv转化" class="headerlink" title="灰度图像(经过Opencv转化)"></a>灰度图像(经过Opencv转化)</h5><div align="center"><img src="/img/blog/OSTU2.png" width="500"></div><h5 id="二值化图像-OSTU算法"><a href="#二值化图像-OSTU算法" class="headerlink" title="二值化图像(OSTU算法)"></a>二值化图像(OSTU算法)</h5><div align="center"><img src="/img/blog/OSTU3.png" width="500"></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OSTU算法&quot;&gt;&lt;a href=&quot;#OSTU算法&quot; class=&quot;headerlink&quot; title=&quot;OSTU算法&quot;&gt;&lt;/a&gt;OSTU算法&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;OSTU算法(最大类间方差法、大津算法): 用来自动对基于聚类的图像进行二值化,或者说将一个灰度图像退化为二值图像。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%B4%A5%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;大津算法wiki&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://yx1302317313.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图像处理" scheme="https://yx1302317313.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu更换登录界面壁纸</title>
    <link href="https://yx1302317313.github.io/2019/02/11/Ubuntu%E6%9B%B4%E6%8D%A2%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/"/>
    <id>https://yx1302317313.github.io/2019/02/11/Ubuntu更换登录界面壁纸/</id>
    <published>2019-02-11T02:18:53.000Z</published>
    <updated>2019-10-19T08:22:37.486Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Ubuntu默认的登录界面有点不敢恭维, 实在不符合现代人的审美.<br>为此找了半天找哪里可以修改, 但是最终还是要求助Google.</p></blockquote><a id="more"></a><h3 id="1-将准备设置为登录界面壁纸的图片移动到-usr-share-background"><a href="#1-将准备设置为登录界面壁纸的图片移动到-usr-share-background" class="headerlink" title="1. 将准备设置为登录界面壁纸的图片移动到/usr/share/background"></a>1. 将准备设置为登录界面壁纸的图片移动到/usr/share/background</h3><pre><code class="lang-shell">$ mv your_picture.jpg /usr/share/background</code></pre><h3 id="2-Ubuntu18-04登录背景相关的配置文件是-etc-alternatives-gdm3-css"><a href="#2-Ubuntu18-04登录背景相关的配置文件是-etc-alternatives-gdm3-css" class="headerlink" title="2. Ubuntu18.04登录背景相关的配置文件是 /etc/alternatives/gdm3.css"></a>2. Ubuntu18.04登录背景相关的配置文件是 /etc/alternatives/gdm3.css</h3><blockquote><p>因为需要修改这个文件, 以防万一先将该文件复制一份</p></blockquote><pre><code class="lang-shell">$ cp /etc/alternatives/gdm3.css /etc/alternatives/gdm3.css.temp</code></pre><h3 id="3-修改-etc-alternatives-gdm3-css"><a href="#3-修改-etc-alternatives-gdm3-css" class="headerlink" title="3. 修改/etc/alternatives/gdm3.css"></a>3. 修改/etc/alternatives/gdm3.css</h3><pre><code class="lang-css">#找到默认的这个部分#lockDialogGroup {  background: #2c001e url(resource:///org/gnome/shell/theme/noise-texture.png);  background-repeat: repeat; }#改为#lockDialogGroup {  background: #2c001e url(file:///usr/share/backgrounds/your_picture.jpg);           background-repeat: no-repeat;  background-size: cover;  background-position: center; }</code></pre><h3 id="4-保存文件-重启之后就可以看到新的登录界面了"><a href="#4-保存文件-重启之后就可以看到新的登录界面了" class="headerlink" title="4. 保存文件, 重启之后就可以看到新的登录界面了."></a>4. 保存文件, 重启之后就可以看到新的登录界面了.</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Ubuntu默认的登录界面有点不敢恭维, 实在不符合现代人的审美.&lt;br&gt;为此找了半天找哪里可以修改, 但是最终还是要求助Google.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://yx1302317313.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://yx1302317313.github.io/tags/Ubuntu/"/>
    
      <category term="美化" scheme="https://yx1302317313.github.io/tags/%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
</feed>
